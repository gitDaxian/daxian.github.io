<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>背包问题</title>
      <link href="/posts/60354/"/>
      <url>/posts/60354/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁0-1背包问题"><a href="#🍁0-1背包问题" class="headerlink" title="🍁0-1背包问题"></a>🍁0-1背包问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>n个物品都是固体，有重量和价值。现在要取走<strong>不超过10克</strong>的物品。每次<strong>可以不拿或全拿</strong>，问最高价值是多少？</p><p>示例：</p><table><thead><tr><th>编号</th><th>重量（g）</th><th>价值</th><th>描述</th><th>简称</th></tr></thead><tbody><tr><td>0</td><td>4</td><td>1600</td><td>黄金一块</td><td>A</td></tr><tr><td>1</td><td>8</td><td>2400</td><td>红宝石一块</td><td>R</td></tr><tr><td>2</td><td>5</td><td>30</td><td>白银一块</td><td>S</td></tr><tr><td>3</td><td>1</td><td>1,000,000</td><td>钻石一粒</td><td>D</td></tr></tbody></table><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>该问题不能使用贪心求解，正确思路为动态规划</p><p>考虑二维dp数组，<strong>行代表该编号对应的物品，列代表背包重量</strong>（0~n）,<code>dp[i][j]</code>代表<strong>i种物体下j重量的最大价值</strong></p><p>分析如下：</p><p>​012345678910</p><p>0  0000AAAAAAA黄金</p><p>1  0000AAAARRR红宝石</p><p>2  0000AAAARRR白银</p><p>3  0D    D   D   D    DA DA DA DA DR DR  钻石</p><hr><p>转为递推式如下：</p><p>1.装不下：保持上一行不变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line"><span class="comment">// 如dp[1][7] = dp[0][7];</span></span><br></pre></td></tr></table></figure><p>2.装得下：max(上一行价值，当前物品价值+<strong>上一行</strong>中减去当前物品重量的价值)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(dp[i-<span class="number">1</span>][j],item.value+dp[i-<span class="number">1</span>][j-item.weight]);</span><br><span class="line"><span class="comment">// 如dp[3][5] = dp[2][5] + dp[2][5-D.weight];</span></span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KnapsackProblem</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1   2   3   4   5   6   7   8   9   10</span></span><br><span class="line"><span class="comment">                    a</span></span><br><span class="line"><span class="comment">                    a               r</span></span><br><span class="line"><span class="comment">                    a               r</span></span><br><span class="line"><span class="comment">        d               da          da  dr  dr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="type">int</span> weight;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Item</span><span class="params">(<span class="type">int</span> index, String name, <span class="type">int</span> weight, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.weight = weight;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Item(&quot;</span> + name + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Item[] items = <span class="keyword">new</span> <span class="title class_">Item</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">1</span>, <span class="string">&quot;黄金&quot;</span>, <span class="number">4</span>, <span class="number">1600</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">2</span>, <span class="string">&quot;宝石&quot;</span>, <span class="number">8</span>, <span class="number">2400</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">3</span>, <span class="string">&quot;白银&quot;</span>, <span class="number">5</span>, <span class="number">30</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">4</span>, <span class="string">&quot;钻石&quot;</span>, <span class="number">1</span>, <span class="number">10000</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(select(items, <span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">(Item[] items, <span class="type">int</span> total)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[items.length][total + <span class="number">1</span>]; <span class="comment">// total + 1是防止0</span></span><br><span class="line">        print(dp);</span><br><span class="line">        <span class="type">Item</span> <span class="variable">item0</span> <span class="operator">=</span> items[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; total + <span class="number">1</span>; j++) &#123; <span class="comment">// 先处理第一行</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= item0.weight) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = item0.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        print(dp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">            <span class="type">Item</span> <span class="variable">item</span> <span class="operator">=</span> items[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; total + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="comment">// x: 上一次同容量背包的最大价值</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= item.weight) &#123;</span><br><span class="line">                    <span class="comment">// j-item.weight: 当前背包容量-这次物品重量=剩余背包空间</span></span><br><span class="line">                    <span class="comment">// y: 剩余背包空间能装下的最大价值 + 这次物品价值</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> dp[i - <span class="number">1</span>][j - item.weight] + item.value;</span><br><span class="line">                    dp[i][j] = Integer.max(x, y);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = x;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            print(dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[dp.length - <span class="number">1</span>][total];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[][] dp)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;   &quot;</span> + <span class="string">&quot;-&quot;</span>.repeat(<span class="number">63</span>));</span><br><span class="line">        Object[] array = IntStream.range(<span class="number">0</span>, dp[<span class="number">0</span>].length + <span class="number">1</span>).boxed().toArray();</span><br><span class="line">        System.out.printf((<span class="string">&quot;%5d &quot;</span>.repeat(dp[<span class="number">0</span>].length)) + <span class="string">&quot;%n&quot;</span>, array);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] d : dp) &#123;</span><br><span class="line">            array = Arrays.stream(d).boxed().toArray();</span><br><span class="line">            System.out.printf((<span class="string">&quot;%5d &quot;</span>.repeat(d.length)) + <span class="string">&quot;%n&quot;</span>, array);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🍁完全背包问题"><a href="#🍁完全背包问题" class="headerlink" title="🍁完全背包问题"></a>🍁完全背包问题</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>n个物品都是固体，有重量和价值。现在要取走<strong>不超过10克</strong>的物品。问最高价值是多少？</p><p>与0-1背包问题的区别在于可以<strong>拿多次</strong></p><p>示例：</p><table><thead><tr><th>编号</th><th>重量（g）</th><th>价值</th><th>描述</th><th>简称</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td><td>青铜</td><td>C</td></tr><tr><td>2</td><td>3</td><td>4</td><td>白银</td><td>S</td></tr><tr><td>3</td><td>4</td><td>7</td><td>黄金</td><td>A</td></tr></tbody></table><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>和0-1背包同样的思路，考虑二维dp数组，<strong>行代表该编号对应的物品，列代表背包重量</strong>（0~n）,<code>dp[i][j]</code>代表<strong>i种物体下j重量的最大价值</strong></p><p>分析如下：</p><p>​0123456</p><p>1  00CC   2C  2C 3C青铜</p><p>1  00CS   2C  SC 3C 白银</p><p>1  00CS   A    A    AC黄金</p><hr><p>转为递推式如下：</p><p>1.装不下：保持上一行不变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br></pre></td></tr></table></figure><p>2.装得下：max(上一行价值，当前物品价值+<strong>本行</strong>中减去当前物品重量的价值)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(dp[i-<span class="number">1</span>][j],item.value+dp[i][j-item.weight]);</span><br></pre></td></tr></table></figure><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KnapsackProblemComplete</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="type">int</span> weight;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Item</span><span class="params">(<span class="type">int</span> index, String name, <span class="type">int</span> weight, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.weight = weight;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Item(&quot;</span> + name + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Item[] items = <span class="keyword">new</span> <span class="title class_">Item</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">1</span>, <span class="string">&quot;青铜&quot;</span>, <span class="number">2</span>, <span class="number">3</span>),    <span class="comment">// c</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">2</span>, <span class="string">&quot;白银&quot;</span>, <span class="number">3</span>, <span class="number">4</span>),    <span class="comment">// s</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">3</span>, <span class="string">&quot;黄金&quot;</span>, <span class="number">4</span>, <span class="number">7</span>),    <span class="comment">// a</span></span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(select(items, <span class="number">6</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">            0   1   2   3   4   5   6</span></span><br><span class="line"><span class="comment">        1   0   0   c   c   cc  cc  ccc</span></span><br><span class="line"><span class="comment">        2   0   0   c   s   cc  cs  ccc</span></span><br><span class="line"><span class="comment">        3   0   0   c   s   a   a   ac</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">(Item[] items, <span class="type">int</span> total)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[items.length][total + <span class="number">1</span>];</span><br><span class="line">        <span class="type">Item</span> <span class="variable">item0</span> <span class="operator">=</span> items[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; total + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= item0.weight) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - item0.weight] + item0.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        print(dp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">            <span class="type">Item</span> <span class="variable">item</span> <span class="operator">=</span> items[i];            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; total + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="comment">// x: 上一次同容量背包的最大价值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= item.weight) &#123;</span><br><span class="line">                    <span class="comment">// j-item.weight: 当前背包容量-这次物品重量=剩余背包空间</span></span><br><span class="line">                    <span class="comment">// y: 剩余背包空间能装下的最大价值 + 这次物品价值</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> dp[i][j - item.weight] + item.value;</span><br><span class="line">                    dp[i][j] = Integer.max(x, y);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = x;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            print(dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[dp.length - <span class="number">1</span>][total];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[][] dp)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;   &quot;</span> + <span class="string">&quot;-&quot;</span>.repeat(<span class="number">63</span>));</span><br><span class="line">        Object[] array = IntStream.range(<span class="number">0</span>, dp[<span class="number">0</span>].length + <span class="number">1</span>).boxed().toArray();</span><br><span class="line">        System.out.printf((<span class="string">&quot;%5d &quot;</span>.repeat(dp[<span class="number">0</span>].length)) + <span class="string">&quot;%n&quot;</span>, array);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] d : dp) &#123;</span><br><span class="line">            array = Arrays.stream(d).boxed().toArray();</span><br><span class="line">            System.out.printf((<span class="string">&quot;%5d &quot;</span>.repeat(d.length)) + <span class="string">&quot;%n&quot;</span>, array);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis缓存问题</title>
      <link href="/posts/8423/"/>
      <url>/posts/8423/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁缓存穿透"><a href="#🍁缓存穿透" class="headerlink" title="🍁缓存穿透"></a>🍁缓存穿透</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>key对应的数据在数据源并不存在，每次<strong>针对此key的请求从缓存获取不到</strong>，请求都会压到数据源，从而可能压垮数据源。</p><img src="/img/8423/Redis缓存1.png" alt="image-20231015222002338" style="zoom:67%;" /><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>（1）  <strong>对空值缓存：</strong>如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟</p><p>（2）  <strong>设置可访问的名单（白名单）：</strong></p><p>使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。</p><p>（3）  <strong>采用布隆过滤器</strong>：(布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。</p><p>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。)</p><p>将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被 这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力。</p><p><strong>（4）</strong>  <strong>进行实时监控：</strong>当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务。</p><h2 id="🍁缓存雪崩"><a href="#🍁缓存雪崩" class="headerlink" title="🍁缓存雪崩"></a>🍁缓存雪崩</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>缓存中<strong>大量key失效</strong>后当高并发到来时导致<strong>大量请求到数据库</strong>，瞬间耗尽数据库资源，导致数据库无法使用。</p><p>造成缓存雪崩问题的原因是是<strong>大量key拥有了相同的过期时间</strong>，比如对课程信息设置缓存过期时间为10分钟，在大量请求同时查询大量的课程信息时，此时就会有大量的课程存在相同的过期时间，一旦失效将同时失效，造成雪崩问题。</p><img src="/img/8423/Redis缓存3.png" alt="image-20231015223549756" style="zoom:67%;" /><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>（1）  <strong>构建多级缓存架构：</strong>nginx缓存 + redis缓存 +其他缓存（ehcache等）</p><p>（2）  <strong>使用锁或队列：</strong></p><p>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况</p><p>（3）  <strong>设置过期标志更新缓存：</strong></p><p>记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存。</p><p>（4）  <strong>将缓存失效时间分散开：</strong></p><p>比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p><h2 id="🍁缓存击穿"><a href="#🍁缓存击穿" class="headerlink" title="🍁缓存击穿"></a>🍁缓存击穿</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p><strong>大量并发访问同一个热点数据</strong>，当热点数据失效后同时去请求数据库，瞬间耗尽数据库资源，导致数据库无法使用。</p><p>比如某手机新品发布，当缓存失效时有大量并发到来导致同时去访问数据库。</p><img src="/img/8423/Redis缓存2.png" alt="image-20231015222718419" style="zoom:67%;" /><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>（1）<strong>预先设置热门数据：</strong>在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长</p><p>（2）<strong>实时调整：</strong>现场监控哪些数据热门，实时调整key的过期时长</p><p>（3）<strong>使用锁：</strong></p><p>​就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db。</p><p>​先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key</p><p>​当操作返回成功时，再进行load db的操作，并回设缓存,最后删除mutex key；</p><p>​当操作返回失败，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java设计模式</title>
      <link href="/posts/18992/"/>
      <url>/posts/18992/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁总览"><a href="#🍁总览" class="headerlink" title="🍁总览"></a>🍁总览</h2><p><img src="/img/18992/design-pattern1.png" alt="img"></p><h3 id="常见创建型"><a href="#常见创建型" class="headerlink" title="常见创建型"></a>常见创建型</h3><p>单例模式(Singleton pattern)：确保一个类<strong>只有一个实例</strong>，并提供该实例的全局访问点</p><p>简单工厂(Simple Factory)：把<strong>实例化的操作单独放到一个类</strong>中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化，这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类</p><p>工厂方法(Factory Method)：它定义了一个<strong>创建对象的接口，但由子类决定要实例化哪个类</strong>。工厂方法把实例化操作推迟到子类</p><p>抽象工厂(Abstract Factory)，抽象工厂模式创建的是对象家族，也就是<strong>很多对象而不是一个对象</strong>，并且这些对象是相关的，也就是说必须一起创建出来</p><p>生成器(Builder)，封装一个对象的构造过程，并允许<strong>按步骤构造</strong>(StringBuilder、StringBuffer)</p><p>原型模式(Prototype)，使用原型实例指定要创建对象的类型，通过<strong>复制这个原型</strong>来创建新对象(Object.clone())</p><h3 id="常见结构型"><a href="#常见结构型" class="headerlink" title="常见结构型"></a>常见结构型</h3><p>适配器模式(Adapter pattern): 将一个类的接口, <strong>转换成客户期望的另一个接口</strong>。 适配器让原本接口不兼容的类可以合作无间。 对象适配器使用组合, 类适配器使用多重继承</p><p>桥接模式(Bridge pattern): 使用桥接模式通过将实现和抽象放在两个不同的类层次中而使它们可以独立改变</p><p>组合模式(Composite pattern): 允许你将对象组合成<strong>树形结构</strong>来表现”整体&#x2F;部分”层次结构. 组合能让客户以一致的方式处理个别对象以及对象组合</p><p>装饰者模式(Decorator pattern): 动态地将责任附加到对象上, 若要<strong>扩展功能</strong>, 装饰者提供了比继承更有弹性的替代方案</p><p>代理模式(Proxy pattern): 为另一个对象<strong>提供一个替身或占位符</strong>以控制对这个对象的访问</p><h3 id="常见行为型"><a href="#常见行为型" class="headerlink" title="常见行为型"></a>常见行为型</h3><p>责任链模式(Chain of responsibility pattern): 通过责任链模式, 你可以为某个请求<strong>创建一个对象链</strong>. 每个对象依序检查此请求并对其进行处理或者将它传给链中的下一个对象</p><p>策略模式(Strategy pattern): 定义了算法族, 分别封闭起来, 让它们之间可以互相替换, 此模式让算法的变化独立于使用算法的客户</p><p>模板方法模式(Template pattern): 在一个方法中定义一个<strong>算法的骨架, 而将一些步骤延迟到子类中</strong>. 模板方法使得子类可以在不改变算法结构的情况下, 重新定义算法中的某些步骤</p><h2 id="🍁单例模式（🚩）"><a href="#🍁单例模式（🚩）" class="headerlink" title="🍁单例模式（🚩）"></a>🍁单例模式（🚩）</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>确保一个类只有一个实例，并提供该实例的全局访问点</p></blockquote><p>使用<strong>一个私有构造函数、一个私有静态变量以及一个公有静态函数</strong>来实现</p><p>私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量</p><p><img src="/img/18992/design-pattern3.png" alt="img"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="1-饿汉式"><a href="#1-饿汉式" class="headerlink" title="1.饿汉式"></a>1.饿汉式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton1</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;单例对象不能重复创建&quot;</span>); <span class="comment">//防止反射破坏单例</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Singleton1()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有静态变量，初始化类的时候就创建好实例，称为饿汉式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton1</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有静态函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123; <span class="comment">//重写方法,防止反序列化破坏单例</span></span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-枚举饿汉式"><a href="#2-枚举饿汉式" class="headerlink" title="2.枚举饿汉式"></a>2.枚举饿汉式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton2</span> &#123; <span class="comment">// enum关键字</span></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Singleton2()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>天然防止反射、反序列化破坏单例</p><h4 id="3-懒汉式"><a href="#3-懒汉式" class="headerlink" title="3.懒汉式"></a>3.懒汉式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton3</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Singleton3()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类初始化时暂时不创建实例，称为懒汉式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton3</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Singleton3.class</span></span><br><span class="line">    <span class="comment">// synchronized加锁,在一个时间点只有一个线程能够进入该方法，从而避免了多次实例化 INSTANCE 的问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton3 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton3</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有<strong>首次创建单例对象</strong>时才需要同步，但该代码实际上每次调用都会同步，因此有下面的双检锁DCL方案</p><h4 id="4-双检锁懒汉式"><a href="#4-双检锁懒汉式" class="headerlink" title="4.双检锁懒汉式"></a>4.双检锁懒汉式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton4</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Singleton4()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton4</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//volatile防止指令重排，返回未完成对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 先判断 INSTANCE 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁</span></span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton4.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton4</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-内部类懒汉式"><a href="#5-内部类懒汉式" class="headerlink" title="5.内部类懒汉式"></a>5.内部类懒汉式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton5</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton5</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Singleton5()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">Singleton5</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton5</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当Singleton类加载时，静态内部类Holder没有被加载进内存。只有当调用<code>getInstance()</code>方法从而触发Holder.INSTANCE 时 Holder 才会被加载，此时初始化 INSTANCE 实例</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/img/18992/design-pattern2.png" alt="img"></p><h3 id="体现"><a href="#体现" class="headerlink" title="体现"></a>体现</h3><ul><li>Runtime 饿汉式单例</li><li>Console 双检锁懒汉式单例</li><li>Collections 中的 EmptyNavigableSet 内部类懒汉式单例</li><li>ReverseComparator.REVERSE_ORDER 内部类懒汉式单例</li><li>Comparators.NaturalOrderComparator.INSTANCE 枚举饿汉式单例</li></ul><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul><li>防止其它对象对自己的实例化，确保所有的对象都访问一个实例</li><li>提供了对唯一实例的受控访问</li><li>由于在系统内存中只存在一个对象，因此可以节约系统资源，当需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能</li><li>允许可变数目的实例</li></ul><h2 id="🍁工厂方法模式"><a href="#🍁工厂方法模式" class="headerlink" title="🍁工厂方法模式"></a>🍁工厂方法模式</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><blockquote><p>定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类</p></blockquote><p>在简单工厂中，创建对象的是另一个类，而在工厂方法中，是<strong>由子类来创建对象</strong></p><p><img src="/img/18992/design-pattern4.png" alt="img"></p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> factoryMethod();</span><br><span class="line">        <span class="comment">// do something with the product</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory</span> <span class="keyword">extends</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span> <span class="keyword">extends</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory2</span> <span class="keyword">extends</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🍁原型模式"><a href="#🍁原型模式" class="headerlink" title="🍁原型模式"></a>🍁原型模式</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><blockquote><p>使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象</p></blockquote><p><img src="/img/18992/design-pattern5.png" alt="img"></p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> Prototype <span class="title function_">myClone</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> <span class="keyword">extends</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String filed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcretePrototype</span><span class="params">(String filed)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.filed = filed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Prototype <span class="title function_">myClone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>(filed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> filed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Prototype</span> <span class="variable">prototype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="type">Prototype</span> <span class="variable">clone</span> <span class="operator">=</span> prototype.myClone();</span><br><span class="line">        System.out.println(clone.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：abc</span></span><br></pre></td></tr></table></figure><h2 id="🍁适配器模式"><a href="#🍁适配器模式" class="headerlink" title="🍁适配器模式"></a>🍁适配器模式</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><blockquote><p>将一个类的接口, 转换成客户期望的另一个接口。 适配器让原本接口不兼容的类可以合作无间。 对象适配器使用组合, 类适配器使用多重继承</p></blockquote><p><img src="/img/18992/design-pattern6.png" alt="img"></p><p><img src="/img/18992/design-pattern7.png" alt="img"></p><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Turkey</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">gobble</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WildTurkey</span> <span class="keyword">implements</span> <span class="title class_">Turkey</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gobble</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;gobble!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TurkeyAdapter</span> <span class="keyword">implements</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    Turkey turkey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TurkeyAdapter</span><span class="params">(Turkey turkey)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.turkey = turkey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span> &#123;</span><br><span class="line">        turkey.gobble();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Turkey</span> <span class="variable">turkey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WildTurkey</span>();</span><br><span class="line">        <span class="type">Duck</span> <span class="variable">duck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TurkeyAdapter</span>(turkey);</span><br><span class="line">        duck.quack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 鸭子(Duck)和火鸡(Turkey)拥有不同的叫声，Duck 的叫声调用 quack() 方法，而 Turkey 调用 gobble() 方法。将 Turkey 的 gobble() 方法适配成 Duck 的 quack() 方法，从而让火鸡冒充鸭子</span></span><br></pre></td></tr></table></figure><h2 id="🍁代理模式"><a href="#🍁代理模式" class="headerlink" title="🍁代理模式"></a>🍁代理模式</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><blockquote><p>为另一个对象提供一个替身或占位符以控制对这个对象的访问</p></blockquote><p><img src="/img/18992/design-pattern8.png" alt="img"></p><h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Image</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showImage</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HighResolutionImage</span> <span class="keyword">implements</span> <span class="title class_">Image</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> URL imageURL;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> startTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWidth</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HighResolutionImage</span><span class="params">(URL imageURL)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.imageURL = imageURL;</span><br><span class="line">        <span class="built_in">this</span>.startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="built_in">this</span>.width = <span class="number">600</span>;</span><br><span class="line">        <span class="built_in">this</span>.height = <span class="number">600</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLoad</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟图片加载，延迟 3s 加载完成</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">return</span> endTime - startTime &gt; <span class="number">3000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showImage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Real Image: &quot;</span> + imageURL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageProxy</span> <span class="keyword">implements</span> <span class="title class_">Image</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HighResolutionImage highResolutionImage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ImageProxy</span><span class="params">(HighResolutionImage highResolutionImage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.highResolutionImage = highResolutionImage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showImage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!highResolutionImage.isLoad()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Temp Image: &quot;</span> + highResolutionImage.getWidth() + <span class="string">&quot; &quot;</span> + highResolutionImage.getHeight());</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        highResolutionImage.showImage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageViewer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">image</span> <span class="operator">=</span> <span class="string">&quot;http://image.jpg&quot;</span>;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(image);</span><br><span class="line">        <span class="type">HighResolutionImage</span> <span class="variable">highResolutionImage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HighResolutionImage</span>(url);</span><br><span class="line">        <span class="type">ImageProxy</span> <span class="variable">imageProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageProxy</span>(highResolutionImage);</span><br><span class="line">        imageProxy.showImage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模拟了图片延迟加载的情况下使用与图片大小相等的临时内容去替换原始图片，直到图片加载完成才将图片显示出来</span></span><br></pre></td></tr></table></figure><h2 id="🍁责任链模式"><a href="#🍁责任链模式" class="headerlink" title="🍁责任链模式"></a>🍁责任链模式</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><blockquote><p>通过责任链模式, 你可以为某个请求创建一个对象链. 每个对象依序检查此请求并对其进行处理或者将它传给链中的下一个对象</p></blockquote><p><img src="/img/18992/design-pattern9.png" alt="img"></p><h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Handler successor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(Handler successor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(Request request)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteHandler1</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteHandler1</span><span class="params">(Handler successor)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(successor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.getType() == RequestType.type1) &#123;</span><br><span class="line">            System.out.println(request.getName() + <span class="string">&quot; is handle by ConcreteHandler1&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (successor != <span class="literal">null</span>) &#123;</span><br><span class="line">            successor.handleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteHandler2</span> <span class="keyword">extends</span> <span class="title class_">Handler</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteHandler2</span><span class="params">(Handler successor)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(successor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.getType() == RequestType.type2) &#123;</span><br><span class="line">            System.out.println(request.getName() + <span class="string">&quot; is handle by ConcreteHandler2&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (successor != <span class="literal">null</span>) &#123;</span><br><span class="line">            successor.handleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Request</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> RequestType type;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Request</span><span class="params">(RequestType type, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> RequestType <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RequestType</span> &#123;</span><br><span class="line">    type1, type2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Handler</span> <span class="variable">handler1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteHandler1</span>(<span class="literal">null</span>);</span><br><span class="line">        <span class="type">Handler</span> <span class="variable">handler2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteHandler2</span>(handler1);</span><br><span class="line">        <span class="type">Request</span> <span class="variable">request1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>(RequestType.type1, <span class="string">&quot;request1&quot;</span>);</span><br><span class="line">        handler2.handleRequest(request1);</span><br><span class="line">        <span class="type">Request</span> <span class="variable">request2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>(RequestType.type2, <span class="string">&quot;request2&quot;</span>);</span><br><span class="line">        handler2.handleRequest(request2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// request1 is handle by ConcreteHandler1</span></span><br><span class="line"><span class="comment">// request2 is handle by ConcreteHandler2</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thread方法</title>
      <link href="/posts/4124/"/>
      <url>/posts/4124/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁总览"><a href="#🍁总览" class="headerlink" title="🍁总览"></a>🍁总览</h2><table><thead><tr><th align="center">名称</th><th align="left">说明</th><th align="left">注意事项</th></tr></thead><tbody><tr><td align="center">start()</td><td align="left">启动一个新线程，在新的线程<strong>运行 run 方法</strong></td><td align="left">start 方法只是让线程进入就绪，里面代码<strong>不一定立刻运行</strong>（CPU 的时间片还没分给它）。每个线程对象的 start方法<strong>只能调用一次</strong>，调用了多次会出现 IllegalThreadStateException</td></tr><tr><td align="center">run()</td><td align="left">新线程启动后会 调用的方法</td><td align="left">如果在构造 Thread 对象时传递了 Runnable 参数，则线程启动后会调用 Runnable 中的 run 方法，否则默认不执行任何操作。但可以创建 Thread 的子类对象，来覆盖默认行为</td></tr><tr><td align="center">join()</td><td align="left">等待线程运行结束</td><td align="left"></td></tr><tr><td align="center">join(long n)</td><td align="left">等待线程运行结束</td><td align="left">最多等待 n  毫秒</td></tr><tr><td align="center">setPriority(int)</td><td align="left">修改线程优先级</td><td align="left">java中规定线程优先级是1~10 的整数，较大的优先级<strong>能提高该线程被 CPU 调度的机率</strong></td></tr><tr><td align="center">interrupt()</td><td align="left">打断线程</td><td align="left">如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛出 InterruptedException，<strong>并清除打断标记</strong> ；如果打断的正在运行的线程，则会<strong>设置打断标记</strong> ；park 的线程被打断，也会<strong>设置打断标记</strong></td></tr><tr><td align="center">sleep(long n)</td><td align="left">让当前执行的线程休眠n毫秒， 休眠时让出cpu  的时间片给其它线程</td><td align="left">static，属于Object的方法</td></tr><tr><td align="center">yield()</td><td align="left">提示线程调度器让出当前线程对 CPU的使用</td><td align="left">static，该方法只是对线程调度器的一个建议</td></tr></tbody></table><h2 id="🍁start和run"><a href="#🍁start和run" class="headerlink" title="🍁start和run"></a>🍁start和run</h2><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(Thread.currentThread().getName());</span><br><span class="line">            FileReader.read(Constants.MP4_FULL_PATH);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t1.run();</span><br><span class="line">    <span class="comment">// t1.start();</span></span><br><span class="line">    log.debug(<span class="string">&quot;do other things ...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-调用-run"><a href="#1-调用-run" class="headerlink" title="1.调用 run"></a>1.调用 run</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19</span>:<span class="number">39</span>:<span class="number">14</span> [main] c.TestStart - main</span><br><span class="line"><span class="number">19</span>:<span class="number">39</span>:<span class="number">14</span> [main] c.FileReader - read [<span class="number">1.</span>mp4] start ...</span><br><span class="line"><span class="number">19</span>:<span class="number">39</span>:<span class="number">18</span> [main] c.FileReader - read [<span class="number">1.</span>mp4] end ... cost: <span class="number">4227</span> ms</span><br><span class="line"><span class="number">19</span>:<span class="number">39</span>:<span class="number">18</span> [main] c.TestStart - <span class="keyword">do</span> other things ...</span><br></pre></td></tr></table></figure><p>程序仍在 main 线程运行， FileReader.read() 方法调用是<strong>同步</strong>的</p><h4 id="2-调用-start"><a href="#2-调用-start" class="headerlink" title="2.调用 start"></a>2.调用 start</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">30</span> [main] c.TestStart - <span class="keyword">do</span> other things ...</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">30</span> [t1] c.TestStart - t1</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">30</span> [t1] c.FileReader - read [<span class="number">1.</span>mp4] start ...</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">35</span> [t1] c.FileReader - read [<span class="number">1.</span>mp4] end ... cost: <span class="number">4542</span> ms</span><br></pre></td></tr></table></figure><p>程序在 t1 线程运行， FileReader.read() 方法调用是<strong>异步</strong>的</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>直接调用 run 是在主线程中执行了 run，<strong>没有启动新的线程</strong> </p><p>使用 start 是启动新的线程，通过新的线程<strong>间接执行</strong> run 中的代码</p><h2 id="🍁sleep和yield"><a href="#🍁sleep和yield" class="headerlink" title="🍁sleep和yield"></a>🍁sleep和yield</h2><h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><ol><li>调用 sleep 会让当前线程从 Running 进入 <strong>Timed Waiting</strong> 状态（阻塞）</li><li>其它线程可以使用 <strong>interrupt</strong> 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</li><li>睡眠结束后的线程<strong>未必会立刻</strong>得到执行</li></ol><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><ol><li>调用 yield 会让当前线程从 Running 进入 <strong>Runnable 就绪状态</strong>，然后调度执行其它线程</li><li>具体的实现依赖于操作系统的任务调度器</li></ol><h2 id="🍁join"><a href="#🍁join" class="headerlink" title="🍁join"></a>🍁join</h2><h3 id="应用同步"><a href="#应用同步" class="headerlink" title="应用同步"></a>应用同步</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    test1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        r = <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    log.debug(<span class="string">&quot;结果为:&#123;&#125;&quot;</span>, r);</span><br><span class="line">    log.debug(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为主线程和线程 t1 是并行执行的，t1 线程需要 1 秒之后才能算出 r=10</span></span><br><span class="line"><span class="comment">// 而主线程一开始就要打印 r 的结果，所以只能打印出 r=0</span></span><br></pre></td></tr></table></figure><h4 id="1-方法调用角度看同步、异步："><a href="#1-方法调用角度看同步、异步：" class="headerlink" title="1.方法调用角度看同步、异步："></a>1.方法调用角度看同步、异步：</h4><ul><li>需要等待结果返回，才能继续运行就是同步</li><li>不需要等待结果返回，就能继续运行就是异步</li></ul><h4 id="2-解决方案："><a href="#2-解决方案：" class="headerlink" title="2.解决方案："></a>2.解决方案：</h4><p>t1.start()之后+t1.join()</p><img src="/img/4124/join1.png" alt="image-20231010111653053" style="zoom: 50%;" /><h3 id="更多线程join"><a href="#更多线程join" class="headerlink" title="更多线程join"></a>更多线程join</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">r2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    test2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        r1 = <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        r2 = <span class="number">20</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    log.debug(<span class="string">&quot;r1: &#123;&#125; r2: &#123;&#125; cost: &#123;&#125;&quot;</span>, r1, r2, end - start);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第一个 join：等待 t1 时, t2 并没有停止, 而在运行</span></span><br><span class="line"><span class="comment">// 第二个 join：1s 后, 执行到此, t2 也运行了 1s, 因此也只需再等待 1s</span></span><br></pre></td></tr></table></figure><p>输出（颠倒2个join一样）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">45</span>:<span class="number">43.239</span> [main] c.TestJoin - r1: <span class="number">10</span> r2: <span class="number">20</span> cost: <span class="number">2005</span></span><br></pre></td></tr></table></figure><img src="/img/4124/join2.png" alt="image-20231010112317910" style="zoom: 50%;" /><h3 id="有时效的-join"><a href="#有时效的-join" class="headerlink" title="有时效的 join"></a>有时效的 join</h3><h4 id="1-等够时间：join会提前结束"><a href="#1-等够时间：join会提前结束" class="headerlink" title="1.等够时间：join会提前结束"></a>1.等够时间：join会提前结束</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">r2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    test3();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">1</span>); <span class="comment">// 睡1秒</span></span><br><span class="line">        r1 = <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    t1.start();</span><br><span class="line">    <span class="comment">// 线程执行结束会导致 join 结束</span></span><br><span class="line">    t1.join(<span class="number">1500</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    log.debug(<span class="string">&quot;r1: &#123;&#125; r2: &#123;&#125; cost: &#123;&#125;&quot;</span>, r1, r2, end - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">48</span>:<span class="number">01.320</span> [main] c.TestJoin - r1: <span class="number">10</span> r2: <span class="number">0</span> cost: <span class="number">1010</span></span><br></pre></td></tr></table></figure><h4 id="2-未等够时间"><a href="#2-未等够时间" class="headerlink" title="2.未等够时间"></a>2.未等够时间</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">r2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    test3();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">2</span>); <span class="comment">// 睡2秒</span></span><br><span class="line">        r1 = <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    t1.start();</span><br><span class="line">    <span class="comment">// 线程执行结束会导致 join 结束</span></span><br><span class="line">    t1.join(<span class="number">1500</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    log.debug(<span class="string">&quot;r1: &#123;&#125; r2: &#123;&#125; cost: &#123;&#125;&quot;</span>, r1, r2, end - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">52</span>:<span class="number">15.623</span> [main] c.TestJoin - r1: <span class="number">0</span> r2: <span class="number">0</span> cost: <span class="number">1502</span></span><br></pre></td></tr></table></figure><h2 id="🍁interrupt"><a href="#🍁interrupt" class="headerlink" title="🍁interrupt"></a>🍁interrupt</h2><h3 id="打断-sleep，wait，join-的线程"><a href="#打断-sleep，wait，join-的线程" class="headerlink" title="打断 sleep，wait，join 的线程"></a>打断 sleep，wait，join 的线程</h3><p>打断阻塞的线程，会清空打断状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    sleep(<span class="number">0.5</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">    log.debug(<span class="string">&quot; 打断状态: &#123;&#125;&quot;</span>, t1.isInterrupted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line"> at java.lang.Thread.sleep(Native Method)</span><br><span class="line"> at java.lang.Thread.sleep(Thread.java:<span class="number">340</span>)</span><br><span class="line"> at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:<span class="number">386</span>)</span><br><span class="line"> at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:<span class="number">8</span>)</span><br><span class="line"> at cn.itcast.n4.TestInterrupt.lambda$test1$<span class="number">3</span>(TestInterrupt.java:<span class="number">59</span>)</span><br><span class="line"> at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line"><span class="number">21</span>:<span class="number">18</span>:<span class="number">10.374</span> [main] c.TestInterrupt - 打断状态: <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="打断正常运行的线程"><a href="#打断正常运行的线程" class="headerlink" title="打断正常运行的线程"></a>打断正常运行的线程</h3><p>打断正常运行的线程, 不会清空打断状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> current.isInterrupted();</span><br><span class="line">            <span class="keyword">if</span>(interrupted) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot; 打断状态: &#123;&#125;&quot;</span>, interrupted);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">    sleep(<span class="number">0.5</span>);</span><br><span class="line">    t2.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">57</span>:<span class="number">37.964</span> [t2] c.TestInterrupt - 打断状态: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="🍁setDaemon"><a href="#🍁setDaemon" class="headerlink" title="🍁setDaemon"></a>🍁setDaemon</h2><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。</p><p>而守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会<strong>强制结束</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">log.debug(<span class="string">&quot;开始运行...&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;开始运行...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;运行结束...&quot;</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;daemon&quot;</span>);</span><br><span class="line"><span class="comment">// 设置该线程为守护线程</span></span><br><span class="line">t1.setDaemon(<span class="literal">true</span>);</span><br><span class="line">t1.start();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">log.debug(<span class="string">&quot;运行结束...&quot;</span>);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">08:<span class="number">26</span>:<span class="number">38.123</span> [main] c.TestDaemon - 开始运行... </span><br><span class="line">08:<span class="number">26</span>:<span class="number">38.213</span> [daemon] c.TestDaemon - 开始运行... </span><br><span class="line">08:<span class="number">26</span>:<span class="number">39.215</span> [main] c.TestDaemon - 运行结束... </span><br></pre></td></tr></table></figure><h3 id="常见守护线程"><a href="#常见守护线程" class="headerlink" title="常见守护线程"></a>常见守护线程</h3><p>垃圾回收器线程</p><p>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等 待它们处理完当前请求</p><h2 id="🍁wait-x2F-notify-x2F-notifyAll"><a href="#🍁wait-x2F-notify-x2F-notifyAll" class="headerlink" title="🍁wait()&#x2F;notify()&#x2F;notifyAll()"></a>🍁wait()&#x2F;notify()&#x2F;notifyAll()</h2><h3 id="Monitor-Java对象头"><a href="#Monitor-Java对象头" class="headerlink" title="Monitor-Java对象头"></a>Monitor-Java对象头</h3><p>32 位虚拟机</p><img src="/img/4124/Moniter1.png" alt="image-20231010131540915" style="zoom: 67%;" /><p>其中 Mark Word 结构为</p><img src="/img/4124/Moniter2.png" alt="image-20231010131648053" style="zoom:67%;" /><h3 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h3><h4 id="obj的方法"><a href="#obj的方法" class="headerlink" title="obj的方法"></a>obj的方法</h4><p>obj.wait()——让进入 object 监视器的线程到 waitSet 等待 </p><p>obj.notify()——在 object 上正在 waitSet 等待的线程中挑一个唤醒 </p><p>obj.notifyAll()——让 object 上正在 waitSet 等待的线程全部唤醒</p><p><strong>必须获得此对象的锁，才能调用这几个方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;执行....&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                obj.wait(); <span class="comment">// 让线程在obj上一直等待下去</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;其它代码....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;执行....&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                obj.wait(); <span class="comment">// 让线程在obj上一直等待下去</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;其它代码....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="comment">// 主线程两秒后执行</span></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;唤醒 obj 上其它线程&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        obj.notify(); <span class="comment">// 唤醒obj上一个线程</span></span><br><span class="line">        <span class="comment">// obj.notifyAll(); // 唤醒obj上所有等待线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>notify 的一种结果(随机唤醒)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">00</span>:<span class="number">53.096</span> [Thread-<span class="number">0</span>] c.TestWaitNotify - 执行.... </span><br><span class="line"><span class="number">20</span>:<span class="number">00</span>:<span class="number">53.099</span> [Thread-<span class="number">1</span>] c.TestWaitNotify - 执行.... </span><br><span class="line"><span class="number">20</span>:<span class="number">00</span>:<span class="number">55.096</span> [main] c.TestWaitNotify - 唤醒 obj 上其它线程</span><br><span class="line"><span class="number">20</span>:<span class="number">00</span>:<span class="number">55.096</span> [Thread-<span class="number">0</span>] c.TestWaitNotify - 其它代码.... </span><br></pre></td></tr></table></figure><p>notifyAll 的结果(唤醒所有)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19</span>:<span class="number">58</span>:<span class="number">15.457</span> [Thread-<span class="number">0</span>] c.TestWaitNotify - 执行.... </span><br><span class="line"><span class="number">19</span>:<span class="number">58</span>:<span class="number">15.460</span> [Thread-<span class="number">1</span>] c.TestWaitNotify - 执行.... </span><br><span class="line"><span class="number">19</span>:<span class="number">58</span>:<span class="number">17.456</span> [main] c.TestWaitNotify - 唤醒 obj 上其它线程</span><br><span class="line"><span class="number">19</span>:<span class="number">58</span>:<span class="number">17.456</span> [Thread-<span class="number">1</span>] c.TestWaitNotify - 其它代码.... </span><br><span class="line"><span class="number">19</span>:<span class="number">58</span>:<span class="number">17.456</span> [Thread-<span class="number">0</span>] c.TestWaitNotify - 其它代码....</span><br></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>wait() ——会释放对象的锁，进入 WaitSet 等待区，从而让<strong>其他线程有机会获取对象的锁</strong>。无限制等待，直到 notify 为止 </p><p>wait(long n) ——有时限的等待, 到 n 毫秒后结束等待，或是被 notify</p><h3 id="wait-x2F-notify-的正确使用"><a href="#wait-x2F-notify-的正确使用" class="headerlink" title="wait&#x2F;notify 的正确使用"></a>wait&#x2F;notify 的正确使用</h3><h4 id="1-区别sleep和notify"><a href="#1-区别sleep和notify" class="headerlink" title="1.区别sleep和notify"></a>1.区别sleep和notify</h4><p>sleep 是 Thread 方法，而 wait 是 Object 的方法 </p><p>sleep 不需要强制和 synchronized 配合使用，但 <strong>wait 需要和 synchronized 一起用</strong> </p><p>sleep 在睡眠的同时<strong>不会释放对象锁</strong>，但 wait 在等待的时候<strong>会释放对象锁</strong></p><h4 id="2-示例"><a href="#2-示例" class="headerlink" title="2.示例"></a>2.示例</h4><img src="/img/4124/wait1.png" alt="image-20231010143349416" style="zoom: 67%;" /><p><strong>步骤1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasCigarette</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasTakeout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">        <span class="keyword">if</span> (!hasCigarette) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">        <span class="keyword">if</span> (hasCigarette) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;其它人&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 这里能不能加 synchronized (room)？</span></span><br><span class="line">    hasCigarette = <span class="literal">true</span>;</span><br><span class="line">    log.debug(<span class="string">&quot;烟到了噢！&quot;</span>);</span><br><span class="line">&#125;, <span class="string">&quot;送烟的&quot;</span>).start();</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">49</span>:<span class="number">49.883</span> [小南] c.TestCorrectPosture - 有烟没？[<span class="literal">false</span>] </span><br><span class="line"><span class="number">20</span>:<span class="number">49</span>:<span class="number">49.887</span> [小南] c.TestCorrectPosture - 没烟，先歇会！</span><br><span class="line"><span class="number">20</span>:<span class="number">49</span>:<span class="number">50.882</span> [送烟的] c.TestCorrectPosture - 烟到了噢！</span><br><span class="line"><span class="number">20</span>:<span class="number">49</span>:<span class="number">51.887</span> [小南] c.TestCorrectPosture - 有烟没？[<span class="literal">true</span>] </span><br><span class="line"><span class="number">20</span>:<span class="number">49</span>:<span class="number">51.887</span> [小南] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line"><span class="number">20</span>:<span class="number">49</span>:<span class="number">51.887</span> [其它人] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line"><span class="number">20</span>:<span class="number">49</span>:<span class="number">51.887</span> [其它人] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line"><span class="number">20</span>:<span class="number">49</span>:<span class="number">51.888</span> [其它人] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line"><span class="number">20</span>:<span class="number">49</span>:<span class="number">51.888</span> [其它人] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line"><span class="number">20</span>:<span class="number">49</span>:<span class="number">51.888</span> [其它人] c.TestCorrectPosture - 可以开始干活了</span><br></pre></td></tr></table></figure><p>分析</p><ul><li>其它干活的线程，都要一直阻塞，效率太低</li><li>小南线程必须睡足 2s 后才能醒来，就算烟提前送到，也无法立刻醒来</li><li>加了 synchronized (room) 后，就好比小南在里面反锁了门睡觉，烟根本没法送进门，main 没加<br>synchronized 就好像 main 线程是翻窗户进来的</li></ul><p><strong>步骤2-[使用wait&#x2F;notify]</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">        <span class="keyword">if</span> (!hasCigarette) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                room.wait(<span class="number">2000</span>); <span class="comment">// 使用wait等待</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">        <span class="keyword">if</span> (hasCigarette) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;其它人&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">        hasCigarette = <span class="literal">true</span>;</span><br><span class="line">        log.debug(<span class="string">&quot;烟到了噢！&quot;</span>);</span><br><span class="line">        room.notify(); <span class="comment">// 使用notify唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;送烟的&quot;</span>).start();</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">20:51:42.489 [小南] c.TestCorrectPosture - 有烟没？[false] </span><br><span class="line">20:51:42.493 [小南] c.TestCorrectPosture - 没烟，先歇会！</span><br><span class="line">20:51:42.493 [其它人] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line">20:51:42.493 [其它人] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line">20:51:42.494 [其它人] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line">20:51:42.494 [其它人] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line">20:51:42.494 [其它人] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line">20:51:43.490 [送烟的] c.TestCorrectPosture - 烟到了噢！</span><br><span class="line">20:51:43.490 [小南] c.TestCorrectPosture - 有烟没？[true] </span><br><span class="line">20:51:43.490 [小南] c.TestCorrectPosture - 可以开始干活了</span><br></pre></td></tr></table></figure><p>分析</p><p>解决了其它干活的线程阻塞的问题</p><p><strong>步骤3-[多线程等待]</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">        <span class="keyword">if</span> (!hasCigarette) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                room.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">        <span class="keyword">if</span> (hasCigarette) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;没干成活...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">        <span class="keyword">if</span> (!hasTakeout) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;没外卖，先歇会！&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                room.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">        <span class="keyword">if</span> (hasTakeout) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;没干成活...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;小女&quot;</span>).start();</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">        hasTakeout = <span class="literal">true</span>;</span><br><span class="line">        log.debug(<span class="string">&quot;外卖到了噢！&quot;</span>);</span><br><span class="line">        room.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;送外卖的&quot;</span>).start();</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">53</span>:<span class="number">12.173</span> [小南] c.TestCorrectPosture - 有烟没？[<span class="literal">false</span>] </span><br><span class="line"><span class="number">20</span>:<span class="number">53</span>:<span class="number">12.176</span> [小南] c.TestCorrectPosture - 没烟，先歇会！</span><br><span class="line"><span class="number">20</span>:<span class="number">53</span>:<span class="number">12.176</span> [小女] c.TestCorrectPosture - 外卖送到没？[<span class="literal">false</span>] </span><br><span class="line"><span class="number">20</span>:<span class="number">53</span>:<span class="number">12.176</span> [小女] c.TestCorrectPosture - 没外卖，先歇会！</span><br><span class="line"><span class="number">20</span>:<span class="number">53</span>:<span class="number">13.174</span> [送外卖的] c.TestCorrectPosture - 外卖到了噢！</span><br><span class="line"><span class="number">20</span>:<span class="number">53</span>:<span class="number">13.174</span> [小南] c.TestCorrectPosture - 有烟没？[<span class="literal">false</span>] </span><br><span class="line"><span class="number">20</span>:<span class="number">53</span>:<span class="number">13.174</span> [小南] c.TestCorrectPosture - 没干成活...</span><br></pre></td></tr></table></figure><p>分析</p><p>notify 只能随机唤醒一个 WaitSet 中的线程，这时如果有其它线程也在等待，那么就可能唤醒不了正确的线<br>程，称之为<strong>虚假唤醒</strong></p><p><strong>步骤4-[使用notifyAll]</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">        hasTakeout = <span class="literal">true</span>;</span><br><span class="line">        log.debug(<span class="string">&quot;外卖到了噢！&quot;</span>);</span><br><span class="line">        room.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;送外卖的&quot;</span>).start();</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">55</span>:<span class="number">23.978</span> [小南] c.TestCorrectPosture - 有烟没？[<span class="literal">false</span>] </span><br><span class="line"><span class="number">20</span>:<span class="number">55</span>:<span class="number">23.982</span> [小南] c.TestCorrectPosture - 没烟，先歇会！</span><br><span class="line"><span class="number">20</span>:<span class="number">55</span>:<span class="number">23.982</span> [小女] c.TestCorrectPosture - 外卖送到没？[<span class="literal">false</span>] </span><br><span class="line"><span class="number">20</span>:<span class="number">55</span>:<span class="number">23.982</span> [小女] c.TestCorrectPosture - 没外卖，先歇会！</span><br><span class="line"><span class="number">20</span>:<span class="number">55</span>:<span class="number">24.979</span> [送外卖的] c.TestCorrectPosture - 外卖到了噢！</span><br><span class="line"><span class="number">20</span>:<span class="number">55</span>:<span class="number">24.979</span> [小女] c.TestCorrectPosture - 外卖送到没？[<span class="literal">true</span>] </span><br><span class="line"><span class="number">20</span>:<span class="number">55</span>:<span class="number">24.980</span> [小女] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line"><span class="number">20</span>:<span class="number">55</span>:<span class="number">24.980</span> [小南] c.TestCorrectPosture - 有烟没？[<span class="literal">false</span>] </span><br><span class="line"><span class="number">20</span>:<span class="number">55</span>:<span class="number">24.980</span> [小南] c.TestCorrectPosture - 没干成活... </span><br></pre></td></tr></table></figure><p>分析</p><p>用 notifyAll 仅解决某个线程的唤醒问题，但使用 if + wait 判断仅有一次机会，一旦条件不成立，就<strong>没有重新判断的机会</strong>了</p><p><strong>步骤5-[使用while]</strong></p><p>将 if 改为 while</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!hasCigarette) &#123;</span><br><span class="line"> log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> room.wait();</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">58</span>:<span class="number">34.322</span> [小南] c.TestCorrectPosture - 有烟没？[<span class="literal">false</span>] </span><br><span class="line"><span class="number">20</span>:<span class="number">58</span>:<span class="number">34.326</span> [小南] c.TestCorrectPosture - 没烟，先歇会！</span><br><span class="line"><span class="number">20</span>:<span class="number">58</span>:<span class="number">34.326</span> [小女] c.TestCorrectPosture - 外卖送到没？[<span class="literal">false</span>] </span><br><span class="line"><span class="number">20</span>:<span class="number">58</span>:<span class="number">34.326</span> [小女] c.TestCorrectPosture - 没外卖，先歇会！</span><br><span class="line"><span class="number">20</span>:<span class="number">58</span>:<span class="number">35.323</span> [送外卖的] c.TestCorrectPosture - 外卖到了噢！</span><br><span class="line"><span class="number">20</span>:<span class="number">58</span>:<span class="number">35.324</span> [小女] c.TestCorrectPosture - 外卖送到没？[<span class="literal">true</span>] </span><br><span class="line"><span class="number">20</span>:<span class="number">58</span>:<span class="number">35.324</span> [小女] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line"><span class="number">20</span>:<span class="number">58</span>:<span class="number">35.324</span> [小南] c.TestCorrectPosture - 没烟，先歇会！</span><br></pre></td></tr></table></figure><p><strong>模板总结</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line"> <span class="keyword">while</span>(条件不成立) &#123;</span><br><span class="line"> lock.wait();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 干活</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//另一个线程</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line"> lock.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis事务和锁</title>
      <link href="/posts/61575/"/>
      <url>/posts/61575/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁概述"><a href="#🍁概述" class="headerlink" title="🍁概述"></a>🍁概述</h2><p>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断</p><p>Redis事务就是<strong>一次性、顺序性、排他性</strong>的执行一个队列中的一系列命令</p><h2 id="🍁使用"><a href="#🍁使用" class="headerlink" title="🍁使用"></a>🍁使用</h2><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><blockquote><p>MULTI ：开启事务，redis会将后续的命令逐个放入队列中，然后使用EXEC命令来原子化执行这个命令系列。</p><p>EXEC：执行事务中的所有操作命令。</p><p>DISCARD：取消事务，放弃执行事务块中的所有命令。</p><p>WATCH：监视一个或多个key,如果事务在执行前，这个key(或多个key)被其他命令修改，则事务被中断，不会执行事务中的任何命令。</p><p>UNWATCH：取消WATCH对所有key的监视。</p></blockquote><h3 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h3><p>从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行。</p><p>直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。</p><p>组队的过程中可以通过Discard来放弃组队。</p><img src="/img/61575/redis1.png" alt="image-20231005110525637" style="zoom:80%;" /><h4 id="标准执行示例"><a href="#标准执行示例" class="headerlink" title="标准执行示例"></a>标准执行示例</h4><p>给k1、k2分别赋值，在事务中修改k1、k2，执行事务后，查看k1、k2值都被修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 11</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 22</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line"><span class="string">&quot;11&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line"><span class="string">&quot;22&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="事务取消示例"><a href="#事务取消示例" class="headerlink" title="事务取消示例"></a>事务取消示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 33</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 34</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; DISCARD</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h4 id="事务错误示例"><a href="#事务错误示例" class="headerlink" title="事务错误示例"></a>事务错误示例</h4><p><strong>1.编译器错误</strong>：组队中某个命令出现了报告错误，执行时<strong>整个的队列命令都会被取消</strong></p><img src="/img/61575/redis2.png" alt="image-20231005111315260" style="zoom:80%;" /><p>在开启事务后，修改k1值为11，k2值为22，但k2语法错误，最终导致事务提交失败，k1、k2保留原值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 11</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; sets k2 22</span><br><span class="line">(error) ERR unknown <span class="built_in">command</span> `sets`, with args beginning with: `k2`, `22`, </span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line"><span class="string">&quot;v2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p><strong>2.运行时错误</strong>：执行阶段某个命令报出了错误，则<strong>只有报错的命令不会被执行，而其他的命令都会执行</strong>，不会回滚</p><img src="/img/61575/redis3.png" alt="image-20231005111523706" style="zoom:80%;" /><p>在开启事务后，修改k1值为11，k2值为22，但将k2的类型作为List，在运行时检测类型错误，最终导致事务提交失败，此时事务并没有回滚，而是跳过错误命令继续执行， 结果k1值改变、k2保留原值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 11</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; lpush k2 22</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) (error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line"><span class="string">&quot;11&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line"><span class="string">&quot;v2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h3 id="CAS操作实现乐观锁"><a href="#CAS操作实现乐观锁" class="headerlink" title="CAS操作实现乐观锁"></a>CAS操作实现乐观锁</h3><h4 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h4><p><strong>悲观锁(Pessimistic Lock)<strong>，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。</strong>传统的关系型数据库里边就用到了很多这种锁机制</strong>，比如<strong>行锁</strong>，<strong>表锁</strong>等，<strong>读锁</strong>，<strong>写锁</strong>等，都是在做操作之前先上锁。</p><p><strong>乐观锁(Optimistic Lock)<strong>，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。</strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。<strong>Redis就是利用这种check-and-set机制（CAS）实现事务的。</strong></p><h4 id="WATCH监视key"><a href="#WATCH监视key" class="headerlink" title="WATCH监视key"></a>WATCH监视key</h4><p>在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果在事务<strong>执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断</strong></p><hr><p><strong>原理</strong></p><p>原子性地为某个值进行增 1 操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val = GET mykey</span><br><span class="line">val = val + 1</span><br><span class="line">SET mykey <span class="variable">$val</span></span><br></pre></td></tr></table></figure><p>当多个客户端同时对同一个键进行这样的操作时， 就会产生竞争条件。举个例子， 如果客户端 A 和 B 都读取了键原来的值， 比如 10 ， 那么两个客户端都会将键的值设为 11 ， 结果错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WATCH mykey</span><br><span class="line">val = GET mykey</span><br><span class="line">val = val + 1</span><br><span class="line">MULTI</span><br><span class="line">SET mykey <span class="variable">$val</span></span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure><p>使用上面的代码，如果在 WATCH 执行之后， EXEC 执行之前， 有其他客户端修改了 mykey 的值， 那么当前客户端的事务就会失败。 程序不断重试这个操作， 直到没有发生碰撞为止</p><hr><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; WATCH k1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 11</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 12</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 22</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line"><span class="string">&quot;11&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line"><span class="string">&quot;v2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="UNWATCH取消监视key"><a href="#UNWATCH取消监视key" class="headerlink" title="UNWATCH取消监视key"></a>UNWATCH取消监视key</h4><p>取消 WATCH 命令对所有 key 的监视</p><p>如果在执行 WATCH 命令之后，EXEC 命令或DISCARD 命令先被执行了的话，那么就不需要再执行UNWATCH 了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; WATCH k1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 11</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; UNWATCH</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 12</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 22</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line"><span class="string">&quot;12&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line"><span class="string">&quot;22&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h2 id="🍁事务性质"><a href="#🍁事务性质" class="headerlink" title="🍁事务性质"></a>🍁事务性质</h2><ul><li>单独的隔离操作</li></ul><p>​事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 </p><ul><li>没有隔离级别的概念</li></ul><p>​队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行</p><ul><li>不保证原子性</li></ul><p>​事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚 </p><h2 id="🍁事务其他实现"><a href="#🍁事务其他实现" class="headerlink" title="🍁事务其他实现"></a>🍁事务其他实现</h2><p>基于<strong>Lua</strong>脚本，Redis可以保证脚本内的命令一次性、按顺序地执行，其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完</p><p>基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和</title>
      <link href="/posts/26737/"/>
      <url>/posts/26737/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁概述"><a href="#🍁概述" class="headerlink" title="🍁概述"></a>🍁概述</h2><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>求数列的和时，Sn &#x3D; a1+a2+a3+…an; 此时Sn就是数列的前 n 项和。例 S5 &#x3D; a1 + a2 + a3 + a4 + a5; S2 &#x3D; a1 + a2。可以通过 S5-S2 得到 a3+a4+a5 的值，前缀和数组里保存的就是前 n 项的和</p><img src="/img/26737/前缀和1.png" alt="前缀和" style="zoom:80%;" /><h3 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h3><p><strong>前缀和 + HashMap[两数之和]</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map  = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//一次遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="comment">//存在时，我们用数组得值为 key，索引为 value</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(target - nums[i]))&#123;              </span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,map.get(target-nums[i])&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//存入值</span></span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="和为K的子数组"><a href="#和为K的子数组" class="headerlink" title="和为K的子数组"></a>和为K的子数组</h4><p>链接：<a href="https://leetcode.cn/problems/subarray-sum-equals-k/description/">560. 和为 K 的子数组 - 力扣（LeetCode）</a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>将所有的前缀和该前缀和出现的次数存到map里，可以通过 presum - k的个数获得 k 的个数</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// &lt;前缀，次数&gt;</span></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//细节，这里需要预存前缀和为 0 的情况，会漏掉前几位就满足的情况</span></span><br><span class="line">        <span class="comment">//例如输入[1,1,0]，k = 2 如果没有这行代码，则会返回0,漏掉了1+1=2，和1+1+0=2的情况</span></span><br><span class="line">        <span class="comment">//输入：[3,1,1,0] k = 2时则不会漏掉</span></span><br><span class="line">        <span class="comment">//因为presum[3] - presum[0]表示前面 3 位的和，所以需要map.put(0,1),垫下底</span></span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">presum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            presum += x;</span><br><span class="line">            <span class="comment">//当前前缀和已知，判断是否含有 presum - k的前缀和，那么就知道某一区间的和为 k 了。</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(presum - k)) &#123;</span><br><span class="line">                count += map.get(presum - k);<span class="comment">//获取次数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新</span></span><br><span class="line">            map.put(presum,map.getOrDefault(presum,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://leetcode.cn/circle/discuss/EQWhUd/">分享｜得了，前缀和被我一下给扒光了 - 力扣（LeetCode）</a></p><h2 id="🍁E1：平均数为k的最长连续子数组"><a href="#🍁E1：平均数为k的最长连续子数组" class="headerlink" title="🍁E1：平均数为k的最长连续子数组"></a>🍁E1：平均数为k的最长连续子数组</h2><blockquote><p>2023年美团秋招笔试</p></blockquote><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>给定<em>n</em>个正整数组成的数组，求平均数正好等于 <em>k</em> 的最长连续子数组的长度</p><h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a><strong>输入描述:</strong></h5><blockquote><p>第一行输入两个正整数n和k，用空格隔开。<br>第二行输入n个正整数ai，用来表示数组。<br>1≤n≤200000<br>1≤k,ai≤10^9</p></blockquote><h5 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a><strong>输出描述:</strong></h5><blockquote><p>如果不存在任何一个连续子数组的平均数等于k，则输出-1。<br>否则输出平均数正好等于 k 的最长连续子数组的长度。</p></blockquote><p><strong>示例1</strong></p><p><strong>输入</strong></p><blockquote><p>5 2<br>1 3 2 4 1</p></blockquote><p><strong>输出</strong></p><blockquote><p>3</p></blockquote><p><strong>说明</strong></p><blockquote><p>取前三个数即可，平均数为2。</p></blockquote><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>1.既然要求平均数为k,只需把所有元素<strong>减去k</strong>,若一些元素和为0即说明这些元素平均数为k<br>2.使用map&lt;sum,i&gt;表示<strong>前i个位置的和</strong><br>3.遍历元素进行求和：<br>    当出现不存在的sum时进行记录<br>    当出现已存在的sum时,假设此时下标为j，记录sum下标为i<br>    则说明在(i+1,j)这一段所有元素的和为0,即其平均数是k,是符合要求的<br>4.找出最长的子数组即可</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">    <span class="type">long</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> cur;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 第一次出现的值和下标</span></span><br><span class="line">    HashMap&lt;Long,Integer&gt; m = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 第一个值有可能就为k</span></span><br><span class="line">    m.put(<span class="number">0L</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cur = pre + in.nextInt() - k;</span><br><span class="line">        <span class="keyword">if</span>(m.containsKey(cur))&#123;</span><br><span class="line">            res = Math.max(res,i-m.get(cur));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            m.put(cur,i);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据类型</title>
      <link href="/posts/6834/"/>
      <url>/posts/6834/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁概述"><a href="#🍁概述" class="headerlink" title="🍁概述"></a>🍁概述</h2><p>Redis中所有的key（键）都是字符串，值的数据类型有5种：<strong>String、List、Set、Zset、Hash</strong></p><img src="/img/6834/redis1.jpeg" alt="img" style="zoom:67%;" /><table><thead><tr><th align="center">类型</th><th align="center">存储的值</th><th align="center">操作</th></tr></thead><tbody><tr><td align="center">String</td><td align="center">可以是字符串、整数或浮点数</td><td align="center">对整个字符串或字符串的一部分进行操作；对整数或浮点数进行自增或自减操作</td></tr><tr><td align="center">List</td><td align="center">一个链表，链表上的每个节点都包含一个字符串</td><td align="center">对链表的两端进行push和pop操作，读取单个或多个元素；根据值查找或删除元素</td></tr><tr><td align="center">Set</td><td align="center">包含字符串的无序集合</td><td align="center">字符串的集合，包含基础的方法有看是否存在添加、获取、删除；还包含计算交集、并集、差集等</td></tr><tr><td align="center">Hash</td><td align="center">包含键值对的无序散列表</td><td align="center">包含方法有添加、获取、删除单个元素</td></tr><tr><td align="center">Zset</td><td align="center">和散列一样，用于存储键值对</td><td align="center">字符串成员与浮点数分数之间的有序映射；元素的排列顺序由分数的大小决定；包含方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素</td></tr></tbody></table><h2 id="🍁String"><a href="#🍁String" class="headerlink" title="🍁String"></a>🍁String</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>String类型是<strong>二进制安全</strong>的，string可以包含任何数据，如数字，字符串，jpg图片或者序列化的对象</p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><img src="/img/6834/redis2.jpeg" alt="image-20230926151736752" style="zoom: 80%;" /><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p><strong>缓存</strong>： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis<strong>作为缓存层</strong>，mysql做持久化层，降低mysql的读写压力</p><p><strong>计数器</strong>：redis是单线程模型（<strong>原子性</strong>），一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源</p><p><strong>session</strong>：spring session + redis实现session共享</p><h2 id="🍁List"><a href="#🍁List" class="headerlink" title="🍁List"></a>🍁List</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>List底层为双端链表</p><ul><li>元素较少的情况下会使用一块连续的内存存储，即压缩列表ziplist（元素较少的情况下会使用一块连续的内存存储）</li><li>当数据量比较多的时候会改成quicklist，将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余</li></ul><img src="/img/6834/redis4.jpeg" alt="image-20230926153312332" style="zoom:80%;" /><h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><img src="/img/6834/redis3.jpeg" alt="image-20230926152748719" style="zoom:80%;" /><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><p>lpush+lpop&#x3D;Stack(栈)</p><p>lpush+rpop&#x3D;Queue（队列）</p><p>lpush+ltrim&#x3D;Capped Collection（有限集合）</p><p>lpush+brpop&#x3D;Message Queue（消息队列）</p><h2 id="🍁Set"><a href="#🍁Set" class="headerlink" title="🍁Set"></a>🍁Set</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>Set 是 String 类型的<strong>无序集合</strong>。集合成员是唯一的，这就意味着集合中<strong>不能出现重复</strong>的数据</p><p>底层其实是一个value为null的hash表，所以添加，删除，查找的<strong>复杂度都是O(1)</strong></p><h3 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h3><img src="/img/6834/redis5.jpeg" alt="image-20230926153655152" style="zoom:80%;" /><h3 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h3><p><strong>标签</strong>（tag）：给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人</p><p><strong>点赞，或点踩，收藏等</strong>：可以放到set中实现</p><h2 id="🍁Hash"><a href="#🍁Hash" class="headerlink" title="🍁Hash"></a>🍁Hash</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>Hash是一个string类型的field和value的映射表，hash特别适合用于<strong>存储对象</strong>。类似Java里面的<strong>Map&lt;String,Object&gt;</strong></p><h3 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h3><img src="/img/6834/redis6.jpeg" alt="image-20230926173013194" style="zoom:80%;" /><h3 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h3><p>存储对象类型</p><h2 id="🍁Zset"><a href="#🍁Zset" class="headerlink" title="🍁Zset"></a>🍁Zset</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。</p><p>不同之处是有序集合的每个成员都关联了一个<strong>评分（score）</strong>,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复的</p><p><strong>底层结构</strong></p><p>hash：hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。<br>跳跃表（<strong>zSkiplist</strong>）：跳跃表的目的在于给元素value排序，根据score的范围获取元素列表</p><h3 id="命令-4"><a href="#命令-4" class="headerlink" title="命令"></a>命令</h3><img src="/img/6834/redis7.jpeg" alt="image-20230926221106241" style="zoom:80%;" /><h3 id="应用-4"><a href="#应用-4" class="headerlink" title="应用"></a>应用</h3><p>排行榜：有序集合经典使用场景。例如小说视频等网站需要对用户上传的小说视频做排行榜，榜单可以按照用户关注数，更新时间，字数等打分，做排行。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式锁</title>
      <link href="/posts/18358/"/>
      <url>/posts/18358/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁概述"><a href="#🍁概述" class="headerlink" title="🍁概述"></a>🍁概述</h2><blockquote><p>当多个进程不在同一个系统中(比如分布式系统中控制共享资源访问)，用分布式锁控制多个进程对资源的访问</p></blockquote><p><strong>设计原则：安全性和有效性</strong></p><p><strong>互斥</strong>（属于安全性）：在任何给定时刻，只有一个客户端可以持有锁。</p><p><strong>无死锁</strong>（属于有效性）：即使锁定资源的客户端崩溃或被分区，也总是可以获得锁；通常通过超时机制实现。</p><p><strong>容错性</strong>（属于有效性）：只要大多数节点都启动，客户端就可以获取和释放锁</p><h2 id="🍁基于数据库实现"><a href="#🍁基于数据库实现" class="headerlink" title="🍁基于数据库实现"></a>🍁基于数据库实现</h2><h3 id="1-基于数据库表"><a href="#1-基于数据库表" class="headerlink" title="1 基于数据库表"></a>1 基于数据库表</h3><p>直接创建一张锁表，然后通过操作该表中的数据来实现了。当我们想要获得锁的时候，就可以在该表中增加一条记录，想要释放锁的时候就删除这条记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> database_lock (</span><br><span class="line">`id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`resource` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;锁定的资源&#x27;</span>,</span><br><span class="line">`description` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> &quot;&quot; COMMENT <span class="string">&#x27;描述&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line"><span class="keyword">UNIQUE</span> KEY uiq_idx_resource (resource)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;数据库分布式锁表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>获得锁时，插入一条数据:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> database_lock(resource, description) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;lock&#x27;</span>);</span><br></pre></td></tr></table></figure><p>释放锁时，删除这条数据:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> database_lock <span class="keyword">WHERE</span> resource<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="2-基于悲观锁"><a href="#2-基于悲观锁" class="headerlink" title="2 基于悲观锁"></a>2 基于悲观锁</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li>在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。</li><li>如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 </li><li>如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。</li><li>其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或抛出异常。</li></ol><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="number">0.</span>开始事务</span><br><span class="line"><span class="keyword">begin</span>;<span class="operator">/</span><span class="keyword">begin</span> work;<span class="operator">/</span><span class="keyword">start</span> transaction; (三者选一就可以)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="number">1.</span>查询出商品信息,使用<span class="keyword">select</span>…<span class="keyword">for</span> <span class="keyword">update</span>的方式，开启排他锁</span><br><span class="line"><span class="keyword">select</span> status <span class="keyword">from</span> t_goods <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="number">2.</span>根据商品信息生成订单</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_orders (id,goods_id) <span class="keyword">values</span> (<span class="keyword">null</span>,<span class="number">1</span>);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="number">3.</span>修改商品status为<span class="number">2</span></span><br><span class="line"><span class="keyword">update</span> t_goods <span class="keyword">set</span> status<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="number">4.</span>提交事务</span><br><span class="line"><span class="keyword">commit</span>;<span class="operator">/</span><span class="keyword">commit</span> work;</span><br></pre></td></tr></table></figure><h3 id="3-基于乐观锁"><a href="#3-基于乐观锁" class="headerlink" title="3 基于乐观锁"></a>3 基于乐观锁</h3><p>使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>查询出商品信息</span><br><span class="line"><span class="keyword">select</span> (status,status,version) <span class="keyword">from</span> t_goods <span class="keyword">where</span> id<span class="operator">=</span>#&#123;id&#125;</span><br><span class="line"><span class="number">2.</span>根据商品信息生成订单</span><br><span class="line"><span class="number">3.</span>修改商品status为<span class="number">2</span></span><br><span class="line"><span class="keyword">update</span> t_goods </span><br><span class="line"><span class="keyword">set</span> status<span class="operator">=</span><span class="number">2</span>,version<span class="operator">=</span>version<span class="operator">+</span><span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> id<span class="operator">=</span>#&#123;id&#125; <span class="keyword">and</span> version<span class="operator">=</span>#&#123;version&#125;;</span><br></pre></td></tr></table></figure><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>对数据库依赖，开销大问题，行锁变表锁问题，无法解决数据库单点和可重入的问题</p><h2 id="🍁基于redis实现"><a href="#🍁基于redis实现" class="headerlink" title="🍁基于redis实现"></a>🍁基于redis实现</h2><h3 id="1-set-NX-PX-Lua"><a href="#1-set-NX-PX-Lua" class="headerlink" title="1 set NX PX + Lua"></a>1 set NX PX + Lua</h3><h4 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h4><blockquote><p>命令：SET productId:lock 0xx9p03001 NX PX 30000</p></blockquote><p>productId：由自己定义，可以是与本次业务有关的id</p><p>0xx9p03001：是一串随机值，必须保证全局唯一</p><p>NX：指的是当且仅当key(也就是案例中的”productId:lock”)在Redis中不存在时，返回执行成功，否则执行失败</p><p>PX 30000：指的是在30秒后，key将被自动删除</p><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>伪代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if(缓存中有)&#123;</span><br><span class="line">  返回缓存中的数据</span><br><span class="line">&#125;else&#123;</span><br><span class="line">  获取分布式锁</span><br><span class="line">  if(获取锁成功）&#123;</span><br><span class="line">       try&#123;</span><br><span class="line">         查询数据库</span><br><span class="line">      &#125;finally&#123;</span><br><span class="line">         释放锁</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lock</span><span class="params">(String key, <span class="type">long</span> expire, <span class="type">int</span> retryTimes, <span class="type">long</span> retryDuration)</span> &#123;</span><br><span class="line">    <span class="comment">// use JedisCommands instead of setIfAbsense</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> setRedis(key, expire);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// retry if needed</span></span><br><span class="line">    <span class="keyword">while</span> ((!result) &amp;&amp; retryTimes-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;lock failed, retrying...&quot;</span> + retryTimes);</span><br><span class="line">            Thread.sleep(retryDuration);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// use JedisCommands instead of setIfAbsense</span></span><br><span class="line">        result = setRedis(key, expire);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">setRedis</span><span class="params">(String key, <span class="type">long</span> expire)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        RedisCallback&lt;String&gt; redisCallback = connection -&gt; &#123;</span><br><span class="line">            <span class="type">JedisCommands</span> <span class="variable">commands</span> <span class="operator">=</span> (JedisCommands) connection.getNativeConnection();</span><br><span class="line">            <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> SnowIDUtil.uniqueStr();</span><br><span class="line">            lockFlag.set(uuid);</span><br><span class="line">            <span class="keyword">return</span> commands.set(key, uuid, NX, PX, expire); <span class="comment">// 加分布式锁</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> redisTemplate.execute(redisCallback);</span><br><span class="line">        <span class="keyword">return</span> !StringUtil.isEmpty(result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;set redis occurred an exception&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解锁：使用原子性的Lua语言</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>, KEYS[<span class="number">1</span>])==ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line"><span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="2-Redisson"><a href="#2-Redisson" class="headerlink" title="2 Redisson"></a>2 Redisson</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>redisson所有指令都通过lua脚本执行，保证了操作的原子性</p><p>redisson设置了watchdog看门狗，“看门狗”的逻辑保证了没有死锁发生</p><p>redisson支持Redlock的实现方式</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><img src="/img/18358/%E5%88%86%E5%B8%83%E5%BC%8F3.png" alt="image-20230925094317807"></p><p><strong>加锁机制</strong></p><p>线程去获取锁，获取成功: 执行lua脚本，保存数据到redis数据库。</p><p>线程去获取锁，获取失败: 一直通过while循环尝试获取锁，获取成功后，执行lua脚本，保存数据到redis</p><p><strong>WatchDog-自动延期</strong></p><p>情况一：在一个分布式环境下，假如一个线程获得锁后，突然服务器宕机了，那么这个时候在一定时间后这个锁会自动释放，也可以设置锁的有效时间(默认30秒），这样的目的主要是防止死锁的发生</p><p>情况二：线程A业务还没有执行完，时间就过了，线程A 还想持有锁的话，就会启动一个watch dog后台线程，不断的延长锁key的生存时间。</p><p><strong>lua脚本-保证原子性</strong></p><p>如果业务逻辑复杂，通过封装在lua脚本中发送给redis，由于redis是单线程的，这样就保证这段复杂业务逻辑执行的原子性</p><h4 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h4><p>使用RLock操作分布锁，RLock继承JDK的Lock接口，所以他有Lock接口的所有特性，比如lock、unlock、trylock等特性,同时它还有很多新特性：强制锁释放，带有效期的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RLock</span> &#123;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//----------------------Lock接口方法-----------------------</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁 锁的有效期默认30秒</span></span><br><span class="line"><span class="comment">     •如果主线程未释放，且当前锁未调用unlock方法，则进入到watchDog机制</span></span><br><span class="line"><span class="comment"> •如果主线程未释放，且当前锁调用unlock方法，则直接释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁 可以手动设置锁的有效时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leaseTime 锁有效时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit      时间单位 小时、分、秒、毫秒等</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">long</span> leaseTime, TimeUnit unit)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * tryLock()方法是有返回值的，用来尝试获取锁，</span></span><br><span class="line"><span class="comment">     * 如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false .</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，</span></span><br><span class="line"><span class="comment">     * 只不过区别在于这个方法在拿不到锁时会等待一定的时间，</span></span><br><span class="line"><span class="comment">     * 在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 等待时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit 时间单位 小时、分、秒、毫秒等</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 比上面多一个参数，多添加一个锁的有效时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> waitTime  等待时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leaseTime 锁有效时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit      时间单位 小时、分、秒、毫秒等</span></span><br><span class="line"><span class="comment">     * waitTime 大于 leaseTime</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式理论</title>
      <link href="/posts/27486/"/>
      <url>/posts/27486/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁分布式系统"><a href="#🍁分布式系统" class="headerlink" title="🍁分布式系统"></a>🍁分布式系统</h2><p>分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统。即<strong>一群独立计算机集合共同对外提供服务，但是对于系统的用户来说，就像是一台计算机在提供服务一样</strong></p><h3 id="分布性"><a href="#分布性" class="headerlink" title="分布性"></a>分布性</h3><p>分布式系统中的多台计算机之间在空间位置上可以随意分布</p><h3 id="对等性"><a href="#对等性" class="headerlink" title="对等性"></a>对等性</h3><p>分布式系统中的计算机没有主／从之分，即没有控制整个系统的主机，也没有被控制的从机，组成分布式系统的所有计算机节点都是对等的</p><h3 id="自治性"><a href="#自治性" class="headerlink" title="自治性"></a>自治性</h3><p>分布式系统中的各个节点都包含自己的处理机和内存，各自具有独立的处理数据的功能</p><h3 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h3><p>在一个计算机网络中，程序运行过程的并发性操作</p><h2 id="🍁CAP理论"><a href="#🍁CAP理论" class="headerlink" title="🍁CAP理论"></a>🍁CAP理论</h2><img src="/img/27486/分布式1.png" alt="image-20230920222012832" style="zoom: 50%;" /><p><code>一致性 (Consistency)</code>: 一个写操作返回成功，那么之后的读请求都必须读到这个新数据；如果返回失败，那么所有读操作都不能读到这个数据。<strong>所有节点访问同一份最新的数据</strong></p><p><code>可用性 (Availability)</code>: 对数据更新具备高可用性，请求能够<strong>及时处理</strong>，不会一直等待，即使出现节点失效。</p><p><code>分区容错性 (Partition tolerance)</code>: 能容忍网络分区，在网络断开的情况下，<strong>被分隔的节点仍能正常对外提供服务</strong></p><p>🚩CAP理论三选二：C、A、P三者不能同时满足，<strong>最多只能满足其中两个</strong></p><h2 id="🍁BASE理论"><a href="#🍁BASE理论" class="headerlink" title="🍁BASE理论"></a>🍁BASE理论</h2><img src="/img/27486/分布式2.png" alt="image-20230921090547793" style="zoom:50%;" /><blockquote><p>BASE是“Basically Available, Soft state, Eventually consistent(基本可用、软状态、最终一致性)”的首字母缩写，BASE 理论是对 CAP 理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP 的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）</p></blockquote><p><code>Basically Available（基本可用）</code>：分布式系统在出现不可预知故障的时候，允许<strong>损失部分可用性</strong></p><p><code>Soft state（软状态）</code>：软状态也称为弱状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程<strong>存在延时</strong>。</p><p><code>Eventually consistent（最终一致性）</code>：最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，<strong>最终能够达到一个一致的状态</strong>。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL优化</title>
      <link href="/posts/43137/"/>
      <url>/posts/43137/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁主键优化"><a href="#🍁主键优化" class="headerlink" title="🍁主键优化"></a>🍁主键优化</h2><p>主键顺序插入的性能是要高于乱序插入的</p><h3 id="数据组织方式"><a href="#数据组织方式" class="headerlink" title="数据组织方式"></a>数据组织方式</h3><p>InnoDB存储引擎中，表数据都是<strong>根据主键顺序组织存放</strong>的，这种存储方式的表称为索引组织表</p><img src="/img/43137/SQL优化1.png" alt="image-20230918093027151" style="zoom:80%;" /><p>数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K。  一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不下，将会存储到下一个页中，页与页之间会通过<strong>指针连接</strong></p><img src="/img/43137/SQL优化2.png" alt="image-20230918093248803" style="zoom:80%;" /><h3 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h3><p>页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行溢出)，根据主键排列</p><h4 id="1-主键顺序插入"><a href="#1-主键顺序插入" class="headerlink" title="1 主键顺序插入"></a>1 主键顺序插入</h4><p>每页写满后申请新页插入</p><p><img src="/img/43137/SQL%E4%BC%98%E5%8C%963.png" alt="image-20230918093542862"></p><h4 id="2-主键乱序插入"><a href="#2-主键乱序插入" class="headerlink" title="2 主键乱序插入"></a>2 主键乱序插入</h4><p>1）1，2页已经写满</p><p><img src="/img/43137/SQL%E4%BC%98%E5%8C%964.png" alt="image-20230918093737894"></p><p>2）再插入id为50的记录</p><p>按照顺序，应该存储在47之后。但是47所在的1#页，已经写满了，存储不了50对应的数据了。 那么此时会开辟一个新的3#页。<strong>将1#页后一半的数据，移动到3#页，然后在3#页，插入50</strong>。</p><p><img src="/img/43137/SQL%E4%BC%98%E5%8C%965.png" alt="image-20230918094017708"></p><p>重新设置链表指针：</p><p><img src="/img/43137/SQL%E4%BC%98%E5%8C%966.png" alt="image-20230918094052329"></p><p>以上就是“页分裂”现象</p><h3 id="页合并"><a href="#页合并" class="headerlink" title="页合并"></a>页合并</h3><p>目前有这些数据</p><p><img src="/img/43137/SQL%E4%BC%98%E5%8C%967.png" alt="image-20230918094229806"></p><p>当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间<strong>变得允许被其他记录声明使用</strong></p><p><img src="/img/43137/SQL%E4%BC%98%E5%8C%968.png" alt="image-20230918094328029"></p><p>当页中删除的记录达到 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前 或后）看看是否可以<strong>将两个页合并以优化空间使用</strong></p><p><img src="/img/43137/SQL%E4%BC%98%E5%8C%969.png" alt="image-20230918094418506"></p><p>以上就是“页合并”现象</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>满足业务需求的情况下，尽量降低主键的长度。</li><li>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</li><li>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</li><li>业务操作时，避免对主键的修改。</li></ol><h2 id="🍁order-by优化"><a href="#🍁order-by优化" class="headerlink" title="🍁order by优化"></a>🍁order by优化</h2><h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><p>排序的方式：</p><blockquote><p>Using filesort : 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</p><p>Using index : 通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。</p></blockquote><p>对于以上的两种排序方式，Using index的性能高，而Using filesort的性能低，我们在优化排序操作时，尽量要优化为 <strong>Using index</strong></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol><li>根据排序字段建立合适的索引，多字段排序时，也遵循<strong>最左前缀法则</strong>。</li><li>尽量使用覆盖索引。</li><li>多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的<strong>规则</strong>（ASC&#x2F;DESC）。</li></ol><p>​创建联合索引(age 升序排序，phone 倒序排序)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_user_age_phone_ad <span class="keyword">on</span> tb_user(age <span class="keyword">asc</span> ,phone <span class="keyword">desc</span>);</span><br></pre></td></tr></table></figure><p><img src="/img/43137/SQL%E4%BC%98%E5%8C%9610.png" alt="image-20230918145133521"></p><p><img src="/img/43137/SQL%E4%BC%98%E5%8C%9611.png" alt="image-20230918145158669"></p><p>​4.如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size(默认256k)。</p><h2 id="🍁group-by优化"><a href="#🍁group-by优化" class="headerlink" title="🍁group by优化"></a>🍁group by优化</h2><ol><li>在分组操作时，可以通过索引来提高效率。 </li><li>分组操作时，索引的使用也是满足最左前缀法则的。</li></ol><h2 id="🍁limit优化"><a href="#🍁limit优化" class="headerlink" title="🍁limit优化"></a>🍁limit优化</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>越往后，分页查询效率越低，这是分页查询的问题。</p><p>当在进行分页查询时，如果执行 limit 2000000,10 ，此时需要MySQL排序前2000010 记录，仅仅返回 2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><strong>覆盖索引加子查询形式</strong>进行优化</p><blockquote><p>explain select * from tb_sku t , (select id from tb_sku order by id limit 2000000,10) a where t.id &#x3D; a.id;</p></blockquote><h2 id="🍁count优化"><a href="#🍁count优化" class="headerlink" title="🍁count优化"></a>🍁count优化</h2><p>count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数<strong>不是 NULL，累计值就加 1</strong>，否则不加，最后<strong>返回累计值</strong></p><p><img src="/img/43137/SQL%E4%BC%98%E5%8C%9612.png" alt="image-20230918150102423"></p><p>效率排序：count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(✳)，所以尽 量使用 count(✳)。</p><h2 id="🍁update优化"><a href="#🍁update优化" class="headerlink" title="🍁update优化"></a>🍁update优化</h2><p>where条件后面字段尽量用索引字段，否则行锁会升级为表锁</p><p>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁升级为表锁 。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-MVCC</title>
      <link href="/posts/59324/"/>
      <url>/posts/59324/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁概述"><a href="#🍁概述" class="headerlink" title="🍁概述"></a>🍁概述</h2><h3 id="1-当前读"><a href="#1-当前读" class="headerlink" title="1 当前读"></a>1 当前读</h3><blockquote><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</p></blockquote><p>select … lock in share mode(共享锁)，select … for update、update、insert、delete(排他锁)都是一种当前读</p><h3 id="2-快照读"><a href="#2-快照读" class="headerlink" title="2 快照读"></a>2 快照读</h3><blockquote><p>简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</p></blockquote><p>Read Committed：每次select，都生成一个快照读。</p><p>Repeatable Read：开启事务后第一个select语句才是快照读的地方。</p><p>Serializable：快照读会退化为当前读。</p><h3 id="3-MVCC"><a href="#3-MVCC" class="headerlink" title="3 MVCC"></a>3 MVCC</h3><blockquote><p>Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本， 使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。</p></blockquote><p>MVCC的具体实现，依赖于数据库记录中的<strong>三个隐式字段、undo log日志、readView</strong></p><h2 id="🍁隐藏字段"><a href="#🍁隐藏字段" class="headerlink" title="🍁隐藏字段"></a>🍁隐藏字段</h2><p>创建表后，InnoDB还会自动的添加三个隐藏字段：</p><p><img src="/img/59324/MVCC1.png" alt="image-20230914152245645"></p><p>前两个字段是肯定会添加的， 是否添加最后一个字段DB_ROW_ID，得看当前表有没有主键，如果有主键，则不会添加该隐藏字段</p><h2 id="🍁undolog"><a href="#🍁undolog" class="headerlink" title="🍁undolog"></a>🍁undolog</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h3><p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。<br>当<strong>insert</strong>的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被<strong>立即删除</strong>。<br>而<strong>update、delete</strong>的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，<strong>不会立即被删除</strong></p><h3 id="2-版本链"><a href="#2-版本链" class="headerlink" title="2 版本链"></a>2 版本链</h3><p>初始有一张表格</p><img src="/img/59324/MVCC2.png" alt="image-20230914152848234" style="zoom:80%;" /><p>DB_TRX_ID : 代表最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID，是自增的。<br>DB_ROLL_PTR ： 由于这条数据是才插入的，没有被更新过，所以该字段值为null。</p><p>假设有四个并发事务访问该表</p><p>(1)第一步</p><p><img src="/img/59324/MVCC3.png" alt="image-20230914153054302"></p><p>当事务2执行第一条修改语句时，会记录undo log日志，记录数据变更之前的样子; </p><p>然后更新记录， 并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本</p><p><img src="/img/59324/MVCC4.png" alt="image-20230914153149797"></p><p>(2)第二步</p><p><img src="/img/59324/MVCC5.png" alt="image-20230914153222905"></p><p>当事务3执行第一条修改语句时，也会记录undo log日志; </p><p>然后更新记录，并且记录本次操作的事务ID，回滚指针</p><p><img src="/img/59324/MVCC6.png" alt="image-20230914153309216"></p><p>(3)第三步</p><p><img src="/img/59324/MVCC7.png" alt="image-20230914153416045"></p><p>当事务4执行第一条修改语句时，也会记录undo log日志; </p><p>然后更新记录，并且记录本次操作的事务ID，回滚指针</p><p><img src="/img/59324/MVCC8.png" alt="image-20230914153454702"></p><p>最终，不同事务或相同事务对同一条记录进行修改，会导致该记录的undo log生成一条<strong>记录版本链表</strong>，链表的头部是最新的旧记录，链表尾部是最早的旧记录</p><h2 id="🍁readview"><a href="#🍁readview" class="headerlink" title="🍁readview"></a>🍁readview</h2><blockquote><p>ReadView（读视图）是快照读SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务 （未提交的）id</p></blockquote><p>ReadView中包含了四个核心字段：</p><p><img src="/img/59324/MVCC9.png" alt="image-20230914160018273"></p><p>Readview中规定了版本链数据的访问规则：</p><p>trx_id 代表当前undolog版本链对应事务ID</p><p><img src="/img/59324/MVCC10.png" alt="image-20230914160209474"></p><p>生成ReadView的时机不同： </p><p>READ COMMITTED ：在事务中每一次执行快照读时生成ReadView </p><p>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView</p><h2 id="🍁原理"><a href="#🍁原理" class="headerlink" title="🍁原理"></a>🍁原理</h2><h3 id="RC隔离级别"><a href="#RC隔离级别" class="headerlink" title="RC隔离级别"></a>RC隔离级别</h3><p>RC隔离级别下，在事务中每一次执行快照读时生成ReadView</p><p><strong>分析上例事务5：</strong></p><p>在事务5中，查询了两次id为30的记录，由于隔离级别为Read Committed，所以每一次进行快照读都会生成一个ReadView，两次生成的ReadView如下：</p><p><img src="/img/59324/MVCC11.png" alt="image-20230914162427358"></p><p>两次快照读在获取数据时，就需要根据所生成的ReadView以及ReadView的版本链访问规则，到undolog版本链中匹配数据，最终决定此次快照读返回的数据</p><p>1、先来看第一次快照读具体的读取过程：</p><p><img src="/img/59324/MVCC12.png" alt="image-20230914162920984"></p><p>先匹配左侧的正常记录，这条记录对应的 trx_id为4，也就是将4带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ， 都不满足，则继续匹配undo log版本链的下一条。</p><p>再匹配0x00003这条记录，对应的trx_id为3，也就是将3带入右侧的匹配规则中。①不满足 ②不满足 ③不满足 ④也 不满足 ，都不满足，则继续匹配undo log版本链的下一条。</p><p>再匹配0x00002这条记录，对应的trx_id为2，也就是将2带入右侧的匹配规则中。①不满足 ②满足 <strong>终止匹配</strong>，此次快照读，返回的数据就是版本链中记录的这条数据。</p><p>2、再来看第二次快照读具体的读取过程：</p><p><img src="/img/59324/MVCC13.png" alt="image-20230915214410722"></p><p>先匹配左侧的正常记录，这条记录对应的 trx_id为4，也就是将4带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ， 都不满足，则继续匹配undo log版本链的下一条。</p><p>再匹配0x00003这条记录，这条记录对应的trx_id为3，也就是将3带入右侧的匹配规则中。①不满足 ②满足 。终止匹配，此次 快照读，返回的数据就是版本链中记录的这条数据。</p><h3 id="RR隔离级别"><a href="#RR隔离级别" class="headerlink" title="RR隔离级别"></a>RR隔离级别</h3><p>RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。 而RR 是可重复读，<strong>在一个事务中，执行两次相同的select语句，查询到的结果是一样的</strong>。</p><p><img src="/img/59324/MVCC14.png" alt="image-20230915214939945"></p><p>在RR隔离级别下，只是在事务中第一次快照读时生成ReadView，后续都是复用该 ReadView，那么既然ReadView都一样， ReadView的版本链匹配规则也一样， 那么最终快照读返回的结果也是一样的</p><h2 id="🍁总结"><a href="#🍁总结" class="headerlink" title="🍁总结"></a>🍁总结</h2><p>MVCC + 锁，实现了事务的隔离性。 而一致性则是由redolog 与 undolog保证</p><p><img src="/img/59324/MVCC15.png" alt="image-20230915215116732"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap</title>
      <link href="/posts/58651/"/>
      <url>/posts/58651/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁ConcurrentHashMap1-7"><a href="#🍁ConcurrentHashMap1-7" class="headerlink" title="🍁ConcurrentHashMap1.7"></a>🍁ConcurrentHashMap1.7</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><code>Segment(大数组) + HashEntry(小数组) + 链表</code>，每个 Segment 对应一把锁，如果多个线程访问不同的Segment，则不会冲突</p><h3 id="并发度"><a href="#并发度" class="headerlink" title="并发度"></a>并发度</h3><p><strong>Segment 数组大小即并发度</strong>，决定了同一时刻最多能有多少个线程并发访问。Segment 数组<strong>不能扩容</strong>，意味着并发度在 ConcurrentHashMap 创建时就固定了</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><img src="/img/58651/CHM1.png" alt="image.png"></p><p>clevel代表<strong>并发度</strong>，capacity&#x2F;clevel&#x3D;64&#x2F;8 &#x3D; 8，代表<strong>每个Segment 数组大小</strong></p><h3 id="索引计算"><a href="#索引计算" class="headerlink" title="索引计算"></a>索引计算</h3><ul><li>假设大数组长度是2的m次方，key 在大数组内的索引是 key 的二次 hash 值的高 m 位</li><li>假设小数组长度是2的n次方，key 在小数组内的索引是 key 的二次 hash 值的低 n 位</li></ul><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>每个小数组的扩容相对<strong>独立</strong>，小数组在<strong>超过</strong>扩容因子时会触发扩容，每次<strong>扩容翻倍</strong></p><h3 id="Segment-0-原型"><a href="#Segment-0-原型" class="headerlink" title="Segment[0] 原型"></a>Segment[0] 原型</h3><p>首次创建其它小数组时，会<strong>以此原型为依据</strong>，数组长度，扩容因子都会以原型为准（原型模式）</p><p><img src="/img/58651/CHM2.png" alt="image.png"></p><p>这里的Segment[6]首次创建按照Segment[0]的标准，大小为4</p><h2 id="🍁ConcurrentHashMap1-8"><a href="#🍁ConcurrentHashMap1-8" class="headerlink" title="🍁ConcurrentHashMap1.8"></a>🍁ConcurrentHashMap1.8</h2><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p><code>Node 数组 + 链表或红黑树</code>，数组的<strong>每个头节点作为锁</strong>，如果多个线程访问的头节点不同，则不会冲突。首次生成头节点时如果发生竞争，利用 cas 而非 syncronized，进一步提升性能</p><h3 id="并发度-1"><a href="#并发度-1" class="headerlink" title="并发度"></a>并发度</h3><p><strong>Node数组有多大</strong>，并发度就有多大，与 1.7 不同，<strong>Node 数组可以扩容</strong></p><h3 id="扩容条件"><a href="#扩容条件" class="headerlink" title="扩容条件"></a>扩容条件</h3><p>Node 数组满 <strong>3&#x2F;4</strong> 时就会扩容，每次<strong>扩容翻倍</strong></p><p><img src="/img/58651/CHM3.png" alt="image-20230913152614695"></p><p>这里put会立即扩容，容量翻倍为32：</p><p><img src="/img/58651/CHM4.png" alt="image-20230913152704689"></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>与 1.7 相比是<strong>懒惰初始化</strong></li><li>capacity 代表<strong>预估</strong>的元素个数，capacity &#x2F; factor 来计算出初始数组大小，需要贴近2^n</li><li>factor 只在计算初始数组大小时被使用，之后<strong>扩容固定为 3&#x2F;4</strong></li><li>超过树化阈值时的扩容问题，如果容量已经是 64，直接树化，否则在原来容量基础上做 <strong>3 轮扩容</strong></li></ul><p><strong>示例</strong></p><p><img src="/img/58651/CHM5.png" alt="image.png"></p><p><strong>预估</strong>capacity12个元素，初始化16已经超过阈值（0.75），因此初始化数组长度为32</p><p>如果capacity为11，则初始化数组长度为16</p><h3 id="正常扩容"><a href="#正常扩容" class="headerlink" title="正常扩容"></a>正常扩容</h3><p>以链表为单位<strong>从后向前</strong>迁移链表，迁移完成的将旧数组头节点替换为 <strong>ForwardingNode</strong></p><p><strong>示例</strong></p><p>1.开始时，元素个数12个&#x3D;16×0.75，触发扩容</p><img src="/img/58651/CHM6.png" alt="image-20230913153248107" style="zoom:80%;" /><p>2.<strong>从后向前</strong>迁移链表，迁移完成的将旧数组头节点替换为 <strong>ForwardingNode</strong></p><img src="/img/58651/CHM7.png" alt="image-20230913153436375" style="zoom:80%;" /><p>3.重新计算索引</p><img src="/img/58651/CHM8.png" alt="image-20230913153534408" style="zoom:80%;" /><p>4.迁移完毕</p><img src="/img/58651/CHM9.png" alt="image-20230913153625276" style="zoom:80%;" /><p><strong>总结</strong></p><p>如果链表长度超过 1，则需要对节点进行复制（创建新节点），怕的是节点迁移后 next 指针改变</p><p>​比如示例中：原数组10号下的链表，转为新数组下的10号和26号</p><p>如果链表最后几个元素扩容后索引不变，则节点无需复制</p><p>​比如示例中：新数组下的26号链表的5-&gt;6</p><h3 id="并发扩容"><a href="#并发扩容" class="headerlink" title="并发扩容"></a>并发扩容</h3><h4 id="1-并发get"><a href="#1-并发get" class="headerlink" title="1 并发get"></a>1 并发get</h4><p>根据是否为 <strong>ForwardingNode</strong> 来决定是在新数组查找还是在旧数组查找，不会阻塞</p><p><strong>示例</strong></p><p><img src="/img/58651/CHM10.png" alt="image-20230913154241353"></p><p>此时旧线程在迁移，新线程get10号Node会访问<strong>旧数组</strong></p><h4 id="2-并发put"><a href="#2-并发put" class="headerlink" title="2 并发put"></a>2 并发put</h4><p>如果 put 的线程与扩容线程操作的链表是<strong>同一个</strong>，put 线程会阻塞<br>如果 put 的线程操作的链表还未迁移完成，即头节点不是 ForwardingNode，则可以<strong>协助扩容</strong><br>如果 put 的线程操作的链表已经迁移完成，即头结点是 ForwardingNode，则可以并发执行</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的锁</title>
      <link href="/posts/49413/"/>
      <url>/posts/49413/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁概述"><a href="#🍁概述" class="headerlink" title="🍁概述"></a>🍁概述</h2><p>按照锁的粒度分，分为以下三类:</p><ol><li>全局锁：锁定数据库中的所有表。 </li><li>表级锁：每次操作锁住整张表。 </li><li>行级锁：每次操作锁住对应的行数据。</li></ol><h2 id="🍁全局锁"><a href="#🍁全局锁" class="headerlink" title="🍁全局锁"></a>🍁全局锁</h2><blockquote><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于<strong>只读状态</strong>，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将<strong>被阻塞</strong></p></blockquote><p>典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，<strong>保证数据的完整性</strong>。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>1）加锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush tables <span class="keyword">with</span> read lock ;</span><br></pre></td></tr></table></figure><p>2）数据备份</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump  <span class="operator">-</span>uroot –p1234  itcast <span class="operator">&gt;</span> itcast.sql</span><br></pre></td></tr></table></figure><p>3）释放锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables ;</span><br></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆 </li><li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致<strong>主从延迟</strong></li></ol><h2 id="🍁表级锁"><a href="#🍁表级锁" class="headerlink" title="🍁表级锁"></a>🍁表级锁</h2><blockquote><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低</p></blockquote><p>表级锁，主要分为以下三类：</p><ol><li>表锁</li><li>元数据锁（meta data lock，MDL）</li><li>意向锁</li></ol><h3 id="1-表锁"><a href="#1-表锁" class="headerlink" title="1 表锁"></a>1 表锁</h3><p>分为两类： 表共享读锁（read lock）和 表独占写锁（write lock）</p><h4 id="1-语法"><a href="#1-语法" class="headerlink" title="(1)语法"></a>(1)语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">加锁：lock tables 表名... read<span class="operator">/</span>write </span><br><span class="line"></span><br><span class="line">释放锁：unlock tables <span class="operator">/</span> 客户端断开连接 </span><br></pre></td></tr></table></figure><h4 id="2-读锁"><a href="#2-读锁" class="headerlink" title="(2)读锁"></a>(2)读锁</h4><p><img src="/img/49413/%E8%A1%A8%E7%BA%A7%E8%AF%BB%E9%94%81.png" alt="image-20230910170550651"></p><p>左侧为客户端一，对指定表加了读锁，不会影响右侧客户端二的读，但是会阻塞右侧客户端的写。</p><h4 id="3-写锁"><a href="#3-写锁" class="headerlink" title="(3)写锁"></a>(3)写锁</h4><p><img src="/img/49413/%E8%A1%A8%E7%BA%A7%E5%86%99%E9%94%81.png" alt="image-20230910170718587"></p><p>左侧为客户端一，对指定表加了写锁，会阻塞右侧客户端的读和写</p><h4 id="4-结论"><a href="#4-结论" class="headerlink" title="(4)结论"></a>(4)结论</h4><p>读锁<strong>不会阻塞其他客户端的读</strong>，但是会<strong>阻塞写</strong>（包括自己）。</p><p>写锁<strong>既会阻塞其他客户端的读，又会阻塞其他客户端的写</strong>。</p><h3 id="2-元数据锁"><a href="#2-元数据锁" class="headerlink" title="2 元数据锁"></a>2 元数据锁</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="(1)概述"></a>(1)概述</h4><blockquote><p>meta data lock , 元数据锁，简写MDL。 </p></blockquote><p>MDL加锁过程是<strong>系统自动控制</strong>，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。<strong>为了避免DML与DDL冲突，保证读写的正确性。</strong><br>元数据，可以简单理解为就是一张<strong>表的表结构</strong>。 也就是说，某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的</p><h4 id="2-语法"><a href="#2-语法" class="headerlink" title="(2)语法"></a>(2)语法</h4><ol><li>当对一张表进行增删改查的时候，加MDL读锁(共享)；</li><li>当对表结构进行变更操作的时候，加MDL写锁(排他)</li></ol><img src="/img/49413/表级元数据锁.png" alt="image-20230910171525904" style="zoom:80%;" /><h3 id="3-意向锁"><a href="#3-意向锁" class="headerlink" title="3 意向锁"></a>3 意向锁</h3><h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="(1)概述"></a>(1)概述</h4><p>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁<strong>不用检查每行数据是否加锁，使用意向锁来减少表锁的检查</strong></p><h4 id="2-示例"><a href="#2-示例" class="headerlink" title="(2)示例"></a>(2)示例</h4><p>首先客户端一，开启一个事务，然后执行DML操作，在执行DML语句时，会对涉及到的行加行锁：</p><img src="/img/49413/表级意向锁1.png" alt="image-20230910171946046"  /><p>客户端二，想对这张表加表锁时，会检查当前表是否有对应的行锁，如果没有，则添加表锁，此时就会从第一行数据，检查到最后一行数据，效率较低：</p><p><img src="/img/49413/%E8%A1%A8%E7%BA%A7%E6%84%8F%E5%90%91%E9%94%812.png" alt="image-20230910172037718"></p><p>有了意向锁之后，客户端一，在执行DML操作时，会对涉及的行加行锁，同时也会对该表加上意向锁：</p><p><img src="/img/49413/%E8%A1%A8%E7%BA%A7%E6%84%8F%E5%90%91%E9%94%813.png" alt="image-20230910172120609"></p><p>其他客户端，在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而不用逐行判断行锁情况了：</p><p><img src="/img/49413/%E8%A1%A8%E7%BA%A7%E6%84%8F%E5%90%91%E9%94%814.png" alt="image-20230910172204744"></p><h4 id="3-分类"><a href="#3-分类" class="headerlink" title="(3)分类"></a>(3)分类</h4><ol><li>意向共享锁(IS): 由语句select … lock in share mode添加 。与表锁共享锁(read)兼容，与表锁排他锁(write)互斥。</li><li>意向排他锁(IX): 由insert、update、delete、select…for update添加 。与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥</li></ol><p>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</p><h2 id="🍁行级锁"><a href="#🍁行级锁" class="headerlink" title="🍁行级锁"></a>🍁行级锁</h2><blockquote><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。</p></blockquote><p>InnoDB的数据是基于索引组织的，行锁是通过对索引上的<strong>索引项加锁</strong>来实现的，而不是对记录加的锁。</p><p>行级锁分三类：</p><p>1.行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下支持</p><p><img src="/img/49413/%E8%A1%8C%E9%94%811.png" alt="image-20230911090211230"></p><p>2.间隙锁（Gap Lock）：锁定索引记录间隙（<strong>不含该记录</strong>），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下支持</p><p><img src="/img/49413/%E8%A1%8C%E9%94%812.png" alt="image-20230911090320650"></p><p>3.临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。 在RR隔离级别下支持</p><p><img src="/img/49413/%E8%A1%8C%E9%94%813.png" alt="image-20230911090508607"></p><h3 id="1-行锁"><a href="#1-行锁" class="headerlink" title="1 行锁"></a>1 行锁</h3><h4 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="(1)概述"></a>(1)概述</h4><p>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁<br>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁</p><p><img src="/img/49413/%E8%A1%8C%E9%94%814.png" alt="image-20230911091213397"></p><h4 id="2-特点"><a href="#2-特点" class="headerlink" title="(2)特点"></a>(2)特点</h4><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 <strong>next-key 锁</strong>进行搜索和索引扫描，以防止幻读。</p><ul><li>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</li><li>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁</li></ul><h3 id="2-间隙锁-amp-临键锁"><a href="#2-间隙锁-amp-临键锁" class="headerlink" title="2 间隙锁&amp;临键锁"></a>2 间隙锁&amp;临键锁</h3><h4 id="1-特点"><a href="#1-特点" class="headerlink" title="(1)特点"></a>(1)特点</h4><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜<br>索和索引扫描，以防止幻读。</p><ul><li>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。</li><li>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。</li><li>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止</li></ul><p>间隙锁唯一目的是<strong>防止其他事务插入间隙</strong>。间隙锁可以共存，一个事务采用的间隙锁不会 阻止另一个事务在同一间隙上采用间隙锁</p><h4 id="2-示例-1"><a href="#2-示例-1" class="headerlink" title="(2)示例"></a>(2)示例</h4><p><strong>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁</strong></p><p><img src="/img/49413/%E9%97%B4%E9%9A%99%E9%94%811.png" alt="image-20230911092149446"></p><p><strong>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key  lock 退化为间隙锁</strong></p><p><img src="/img/49413/%E9%97%B4%E9%9A%99%E9%94%812.png" alt="image-20230911092425766"></p><p>要根据这个二级索引查询值为18的数据，并加上共享锁，只锁定18这一行就可以了吗？ 并不是，因为是非唯一索引，这个结构中可能有多个18的存在，所以，在加锁时会继续往后找，找到一个不满足条件的值（当前案例中也 就是29）。此时会对18加临键锁，并对29之前的间隙加锁</p><p><img src="/img/49413/%E9%97%B4%E9%9A%99%E9%94%813.png" alt="image-20230911092701785"></p><p><strong>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止</strong></p><p><img src="/img/49413/%E9%97%B4%E9%9A%99%E9%94%814.png" alt="image-20230911092741310"></p><p>查询的条件为id&gt;&#x3D;19，并添加共享锁。 此时可以根据数据库表中现有的数据，将数据分为三个部分：<br>[19](19,25](25,+∞]<br>所以数据库数据在加锁是，就是将19加了行锁，25的临键锁（包含25及25之前的间隙），正无穷的临键锁(正无穷及之前的间隙)</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/posts/61237/"/>
      <url>/posts/61237/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁总览"><a href="#🍁总览" class="headerlink" title="🍁总览"></a>🍁总览</h2><img src="/img/61237/排序1.png" alt="排序1" style="zoom:80%;" /><p>对数阶：快速排序、堆排序和归并排序</p><p>不稳定：选择排序、快速排序、希尔排序、堆排序</p><h2 id="🍁冒泡排序"><a href="#🍁冒泡排序" class="headerlink" title="🍁冒泡排序"></a>🍁冒泡排序</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数</li><li>针对所有的元素重复以上的步骤，除了最后一个</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较</li></ol><p><img src="/img/61237/%E6%8E%92%E5%BA%8F2.png" alt="排序2"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 辅助交换函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble</span><span class="params">(<span class="type">int</span>[] a)</span>&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">swapped</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; a.length-<span class="number">1</span>;j++)&#123;</span><br><span class="line">        swapped = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; a.length-j-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[i+<span class="number">1</span>])&#123;</span><br><span class="line">            swap(a,i,i+<span class="number">1</span>);</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!swapped)&#123; <span class="comment">//没有发生交换，退出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🍁选择排序"><a href="#🍁选择排序" class="headerlink" title="🍁选择排序"></a>🍁选择排序</h2><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>重复第二步，直到所有元素均排序完毕</li></ol><p><img src="/img/61237/%E6%8E%92%E5%BA%8F3.png" alt="排序3"></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selection</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 选择轮数 a.length - 1</span></span><br><span class="line">    <span class="comment">// 2. 交换的索引位置(right) 初始 a.length - 1, 每次递减</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> a.length - <span class="number">1</span>; right &gt; <span class="number">0</span> ; right--) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[max]) &#123;</span><br><span class="line">                max = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max != right) &#123;</span><br><span class="line">            swap(a, max, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🍁插入排序"><a href="#🍁插入排序" class="headerlink" title="🍁插入排序"></a>🍁插入排序</h2><h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h3><p>1.将数组分为两部分 [0 .. low-1]  [low .. a.length-1]</p><ul><li>左边 [0 .. low-1] 是已排序部分</li><li>右边 [low .. a.length-1] 是未排序部分</li></ul><p>2.每次从未排序区域取出 low 位置的元素, 插入到已排序区域</p><p><img src="/img/61237/%E6%8E%92%E5%BA%8F4.png" alt="排序4"></p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span>[] a)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">1</span>; low &lt; a.length; low++) &#123;</span><br><span class="line">        <span class="comment">// 将 low 位置的元素插入至 [0..low-1] 的已排序区域</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[low];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low - <span class="number">1</span>; <span class="comment">// 已排序区域指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; t &lt; a[i]) &#123; <span class="comment">// 没有找到插入位置</span></span><br><span class="line">            a[i + <span class="number">1</span>] = a[i]; <span class="comment">// 空出插入位置</span></span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到插入位置</span></span><br><span class="line">        <span class="keyword">if</span> (i != low - <span class="number">1</span>) &#123;</span><br><span class="line">            a[i + <span class="number">1</span>] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🍁希尔排序"><a href="#🍁希尔排序" class="headerlink" title="🍁希尔排序"></a>🍁希尔排序</h2><h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h3><ol><li>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk &#x3D; 1；</li><li>按增量序列个数 k，对序列进行 k 趟排序；</li><li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ol><p><img src="/img/61237/%E6%8E%92%E5%BA%8F5.png" alt="排序5"></p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shell</span><span class="params">(<span class="type">int</span>[] a)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> a.length&gt;&gt;<span class="number">1</span>; gap &gt;<span class="number">0</span> ; gap=gap&gt;&gt;<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> gap; low &lt; a.length; low ++) &#123;</span><br><span class="line">            <span class="comment">// 将 low 位置的元素插入至 [0..low-1] 的已排序区域</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[low];</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low - gap; <span class="comment">// 已排序区域指针</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; t &lt; a[i]) &#123; <span class="comment">// 没有找到插入位置</span></span><br><span class="line">                a[i + gap] = a[i]; <span class="comment">// 空出插入位置</span></span><br><span class="line">                i -= gap;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到插入位置</span></span><br><span class="line">            <span class="keyword">if</span> (i != low - gap) &#123;</span><br><span class="line">                a[i + gap] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🍁快速排序（重要）"><a href="#🍁快速排序（重要）" class="headerlink" title="🍁快速排序（重要）"></a>🍁快速排序（重要）</h2><h3 id="步骤-双边循环方案"><a href="#步骤-双边循环方案" class="headerlink" title="步骤(双边循环方案)"></a>步骤(双边循环方案)</h3><p>1.选择最左侧元素作为基准点</p><p>2.j 找比基准点小的，i 找比基准点大的，一旦找到，二者进行交换</p><ul><li>i 从左向右</li><li>j 从右向左</li></ul><p>3.最后基准点与 i 交换，i 即为基准点最终索引</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>i 找到比基准点大的5停下来，j 找到比基准点小的1停下来（包含等于），二者交换</p><p><img src="/img/61237/%E5%BF%AB%E6%8E%921.png" alt="快排1"></p><p>i 找到8，j 找到3，二者交换，i 找到7，j 找到2，二者交换</p><p><img src="/img/61237/%E5%BF%AB%E6%8E%922.png" alt="快排2"></p><p>i &#x3D;&#x3D; j，退出循环，基准点与 i 交换</p><p><img src="/img/61237/%E5%BF%AB%E6%8E%923.png" alt="快排3"></p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> l,<span class="type">int</span> h)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= h)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(a,l,h);</span><br><span class="line">    quick(a,l,p-<span class="number">1</span>);</span><br><span class="line">    quick(a,p+<span class="number">1</span>,h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> l,<span class="type">int</span> h)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pv</span> <span class="operator">=</span> a[l]; <span class="comment">//基准点元素</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> h;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="comment">// j 从右找小的</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; a[j] &gt; pv)&#123;</span><br><span class="line">            j -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i 从左找大的</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; a[i] &lt;= pv)&#123;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    swap(a,i,j);   </span><br><span class="line">    &#125;</span><br><span class="line">    swap(a,l,j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>基准点在左边，并且要先 j 后 i </p><p>while( i &lt; j &amp;&amp; a[j] &gt; pv ) j– </p><p>while ( i &lt; j &amp;&amp; a[i] &lt;&#x3D; pv ) i++ </p><h2 id="🍁归并排序"><a href="#🍁归并排序" class="headerlink" title="🍁归并排序"></a>🍁归并排序</h2><h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤"></a>步骤</h3><ol><li>分 - 每次从中间切一刀，处理的数据少一半</li><li>治 - 当数据仅剩一个时可以认为有序</li><li>合 - 两个有序的结果，可以进行合并排序</li></ol><p><img src="/img/61237/%E6%8E%92%E5%BA%8F6.png" alt="排序6"></p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSortTopDown</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        a1 原始数组</span></span><br><span class="line"><span class="comment">        i~iEnd 第一个有序范围</span></span><br><span class="line"><span class="comment">        j~jEnd 第二个有序范围</span></span><br><span class="line"><span class="comment">        a2 临时数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] a1, <span class="type">int</span> i, <span class="type">int</span> iEnd, <span class="type">int</span> j, <span class="type">int</span> jEnd, <span class="type">int</span>[] a2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= iEnd &amp;&amp; j &lt;= jEnd) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a1[i] &lt; a1[j]) &#123;</span><br><span class="line">                a2[k] = a1[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                a2[k] = a1[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; iEnd) &#123;</span><br><span class="line">            System.arraycopy(a1, j, a2, k, jEnd - j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; jEnd) &#123;</span><br><span class="line">            System.arraycopy(a1, i, a2, k, iEnd - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a1)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a2 = <span class="keyword">new</span> <span class="title class_">int</span>[a1.length];</span><br><span class="line">        split(a1, <span class="number">0</span>, a1.length - <span class="number">1</span>, a2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(<span class="type">int</span>[] a1, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] a2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = Arrays.copyOfRange(a1, left, right + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//        System.out.println(Arrays.toString(array));</span></span><br><span class="line">        <span class="comment">// 2. 治</span></span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 分</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        split(a1, left, m, a2);                 <span class="comment">// left = 0 m = 0  9</span></span><br><span class="line">        split(a1, m + <span class="number">1</span>, right, a2);       <span class="comment">// m+1 = 1 right = 1  3</span></span><br><span class="line">        <span class="comment">// 3. 合</span></span><br><span class="line">        merge(a1, left, m, m + <span class="number">1</span>, right, a2);</span><br><span class="line">        System.arraycopy(a2, left, a1, left, right - left + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">9</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🍁堆排序"><a href="#🍁堆排序" class="headerlink" title="🍁堆排序"></a>🍁堆排序</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>堆逻辑上是<strong>完全二叉树</strong>，堆中某个节点的值总是<strong>不大于或不小于其父节点</strong>的值；实现上可以选择<strong>数组</strong></p><p><img src="/img/61237/%E5%A0%86%E6%8E%92%E5%BA%8F1.png" alt="堆排序1"></p><p>堆化步骤：</p><ol><li>找到最后一个非叶子节点</li><li>从后向前，对每个节点执行<strong>下潜</strong></li></ol><p>规律：</p><ul><li>一棵满二叉树节点个数为 2^h-1，如上例中高度 h&#x3D;3 节点数是 2^3-1&#x3D;7</li><li>非叶子节点范围为 [0, size&#x2F;2-1]</li></ul><h3 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤"></a>步骤</h3><ol><li>建立大顶堆</li><li>每次将堆顶元素（最大值）交换到末尾，调整堆顶元素，让它重新符合大顶堆特性</li></ol><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>建堆<img src="/img/61237/%E5%A0%86%E6%8E%92%E5%BA%8F2.png" alt="堆排序2"></p><p>交换，下潜调整</p><p><img src="/img/61237/%E5%A0%86%E6%8E%92%E5%BA%8F3.png" alt="堆排序3"></p><p><img src="/img/61237/%E5%A0%86%E6%8E%92%E5%BA%8F4.png" alt="堆排序4"></p><p><img src="/img/61237/%E5%A0%86%E6%8E%92%E5%BA%8F5.png" alt="堆排序5"></p><p><img src="/img/61237/%E5%A0%86%E6%8E%92%E5%BA%8F6.png" alt="堆排序6"></p><p><img src="/img/61237/%E5%A0%86%E6%8E%92%E5%BA%8F7.png" alt="堆排序7"></p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">        heapify(a, a.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> a.length - <span class="number">1</span>; right &gt; <span class="number">0</span>; right--) &#123;</span><br><span class="line">            swap(a, <span class="number">0</span>, right);</span><br><span class="line">            down(a, <span class="number">0</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建堆 O(n)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="comment">// 非叶子节点不断下潜</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            down(array, i, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下潜</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">down</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> parent, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> parent;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; size &amp;&amp; array[left] &gt; array[max]) &#123;</span><br><span class="line">                max = left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; size &amp;&amp; array[right] &gt; array[max]) &#123;</span><br><span class="line">                max = right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (max == parent) &#123; <span class="comment">// 没找到更大的孩子</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(array, max, parent);</span><br><span class="line">            parent = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🍁计数排序"><a href="#🍁计数排序" class="headerlink" title="🍁计数排序"></a>🍁计数排序</h2><h3 id="步骤-6"><a href="#步骤-6" class="headerlink" title="步骤"></a>步骤</h3><ol><li>花O(n)的时间扫描一下整个序列 A，获取最小值 min 和最大值 max</li><li>开辟一块新的空间创建新的数组 B，长度为 ( max - min + 1)</li><li>数组 B 中 index 的元素记录的值是 A 中某元素出现的次数</li><li>最后输出目标整数序列，具体的逻辑是遍历数组 B，输出相应元素以及对应的个数</li></ol><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; max) &#123;</span><br><span class="line">            max = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; min) &#123;</span><br><span class="line">            min = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] counting = <span class="keyword">new</span> <span class="title class_">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : a) &#123;</span><br><span class="line">        counting[i - min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; counting.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (counting[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            a[k] = i + min;</span><br><span class="line">            counting[i]--;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🍁桶排序"><a href="#🍁桶排序" class="headerlink" title="🍁桶排序"></a>🍁桶排序</h2><h3 id="步骤-7"><a href="#步骤-7" class="headerlink" title="步骤"></a>步骤</h3><ol><li>设置固定数量的空桶。</li><li>把数据放到对应的桶中。</li><li>对每个不为空的桶中数据进行排序。</li><li>拼接不为空的桶中数据，得到结果。</li></ol><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BucketSortGeneric</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ages = &#123;<span class="number">20</span>, <span class="number">10</span>, <span class="number">28</span>, <span class="number">66</span>, <span class="number">25</span>, <span class="number">31</span>, <span class="number">67</span>, <span class="number">30</span>, <span class="number">70</span>&#125;; <span class="comment">// 假设人类年龄 1~99</span></span><br><span class="line">        System.out.println(Arrays.toString(ages));</span><br><span class="line">        sort(ages, <span class="number">20</span>);</span><br><span class="line">        System.out.println(Arrays.toString(ages));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> range)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; max) &#123;</span><br><span class="line">                max = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; min) &#123;</span><br><span class="line">                min = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 准备桶</span></span><br><span class="line">        DynamicArray[] buckets = <span class="keyword">new</span> <span class="title class_">DynamicArray</span>[(max - min) / range + <span class="number">1</span>];</span><br><span class="line">        System.out.println(buckets.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">            buckets[i] = <span class="keyword">new</span> <span class="title class_">DynamicArray</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 放入年龄数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> age : a) &#123;</span><br><span class="line">            buckets[(age - min) / range].addLast(age);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (DynamicArray bucket : buckets) &#123;</span><br><span class="line">            <span class="comment">// 3. 排序桶内元素</span></span><br><span class="line">            <span class="type">int</span>[] array = bucket.array();</span><br><span class="line">            InsertionSort.sort(array);</span><br><span class="line">            System.out.println(Arrays.toString(array));</span><br><span class="line">            <span class="comment">// 4. 把每个桶排序好的内容，依次放入原始数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v : array) &#123;</span><br><span class="line">                a[k++] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🍁基数排序"><a href="#🍁基数排序" class="headerlink" title="🍁基数排序"></a>🍁基数排序</h2><h3 id="步骤-8"><a href="#步骤-8" class="headerlink" title="步骤"></a>步骤</h3><ol><li>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零</li><li>从最低位开始，依次进行一次排序</li><li>从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列</li></ol><h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadixSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(String[] a, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt;[] buckets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">            buckets[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> length - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String s : a) &#123;</span><br><span class="line">                buckets[s.charAt(i)].add(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (ArrayList&lt;String&gt; bucket : buckets) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String s : bucket) &#123;</span><br><span class="line">                    a[k++] = s;</span><br><span class="line">                &#125;</span><br><span class="line">                bucket.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*String[] phoneNumbers = new String[10];</span></span><br><span class="line"><span class="comment">        phoneNumbers[0] = &quot;13812345678&quot;;</span></span><br><span class="line"><span class="comment">        phoneNumbers[1] = &quot;13912345678&quot;;</span></span><br><span class="line"><span class="comment">        phoneNumbers[2] = &quot;13612345678&quot;;</span></span><br><span class="line"><span class="comment">        phoneNumbers[3] = &quot;13712345678&quot;;</span></span><br><span class="line"><span class="comment">        phoneNumbers[4] = &quot;13512345678&quot;;</span></span><br><span class="line"><span class="comment">        phoneNumbers[5] = &quot;13412345678&quot;;</span></span><br><span class="line"><span class="comment">        phoneNumbers[6] = &quot;15012345678&quot;;</span></span><br><span class="line"><span class="comment">        phoneNumbers[7] = &quot;15112345678&quot;;</span></span><br><span class="line"><span class="comment">        phoneNumbers[8] = &quot;15212345678&quot;;</span></span><br><span class="line"><span class="comment">        phoneNumbers[9] = &quot;15712345678&quot;;*/</span></span><br><span class="line"></span><br><span class="line">        String[] phoneNumbers = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line">        phoneNumbers[<span class="number">0</span>] = <span class="string">&quot;138&quot;</span>;</span><br><span class="line">        phoneNumbers[<span class="number">1</span>] = <span class="string">&quot;139&quot;</span>;</span><br><span class="line">        phoneNumbers[<span class="number">2</span>] = <span class="string">&quot;136&quot;</span>;</span><br><span class="line">        phoneNumbers[<span class="number">3</span>] = <span class="string">&quot;137&quot;</span>;</span><br><span class="line">        phoneNumbers[<span class="number">4</span>] = <span class="string">&quot;135&quot;</span>;</span><br><span class="line">        phoneNumbers[<span class="number">5</span>] = <span class="string">&quot;134&quot;</span>;</span><br><span class="line">        phoneNumbers[<span class="number">6</span>] = <span class="string">&quot;150&quot;</span>;</span><br><span class="line">        phoneNumbers[<span class="number">7</span>] = <span class="string">&quot;151&quot;</span>;</span><br><span class="line">        phoneNumbers[<span class="number">8</span>] = <span class="string">&quot;152&quot;</span>;</span><br><span class="line">        phoneNumbers[<span class="number">9</span>] = <span class="string">&quot;157&quot;</span>;</span><br><span class="line">        RadixSort.radixSort(phoneNumbers, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (String phoneNumber : phoneNumbers) &#123;</span><br><span class="line">            System.out.println(phoneNumber);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/vn3KiV-ez79FmbZ36SX9lg">十大经典排序算法动画与解析，看我就够了！（配代码完全版） (qq.com)</a></p><p><a href="https://www.bilibili.com/video/BV1rv4y1H7o6?p=48&vd_source=4e325d8f935e8f302a35ee035332e67b">基础算法-202-排序算法-冒泡排序_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引进阶</title>
      <link href="/posts/13143/"/>
      <url>/posts/13143/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁最左前缀法则"><a href="#🍁最左前缀法则" class="headerlink" title="🍁最左前缀法则"></a>🍁最左前缀法则</h2><blockquote><p>如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询<strong>从索引的最左列开始， 并且不跳过索引中的列</strong>。如果跳跃某一列，索引将会**部分失效(后面的字段索引失效)**。</p></blockquote><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>tb_user表有一个联合索引，这个联合索引涉及到三个字段，顺序分别为：profession， age，status</p><p><img src="/img/13143/MySQL%E7%B4%A2%E5%BC%95%E8%BF%9B%E9%98%B61.png" alt="image-20230830224849301"></p><p>最左前缀法则指的是，查询时，最左边的列，也就是profession必须存在，否则索引全部失效。  而且中间不能跳过某一列，否则该列后面的字段索引将失效。</p><p>生效示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">31</span>;</span><br></pre></td></tr></table></figure><p>失效示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>当执行以下SQL语句，索引<strong>生效</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">and</span>  status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>；</span><br></pre></td></tr></table></figure><p>🚩最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是<strong>第一个字段</strong>)必须存在，与编写SQL时，<strong>条件编写的先后顺序无关</strong></p><h2 id="🍁索引失效情况"><a href="#🍁索引失效情况" class="headerlink" title="🍁索引失效情况"></a>🍁索引失效情况</h2><h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3><blockquote><p>联合索引中，出现范围查询<code>(&gt;,&lt;)</code>，范围查询<strong>右侧的列索引</strong>失效</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">&gt;</span> <span class="number">30</span> <span class="keyword">and</span> status </span><br><span class="line"><span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="/img/13143/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%881.png" alt="image-20230830225756823"></p><p>当范围查询使用&gt; 或 &lt; 时，走联合索引了，但是索引的长度为49（不够联合索引的长度），就说明范围查询右边的status字段是没有走索引的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">&gt;=</span> <span class="number">30</span> <span class="keyword">and</span> </span><br><span class="line">status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="/img/13143/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%882.png" alt="image-20230830225937192"></p><p>范围查询使用&gt;&#x3D; 或 &lt;&#x3D; 时，走联合索引了，但是索引的长度为54（正常），就说明所有的字段都是走索引的</p><p><strong>总结：尽可能的使用类似于 &gt;&#x3D; 或 &lt;&#x3D; 这类的范围查询，而避免使用 &gt; 或 &lt;</strong></p><h3 id="索引列运算"><a href="#索引列运算" class="headerlink" title="索引列运算"></a>索引列运算</h3><blockquote><p>在索引列上进行运算操作， 索引将失效</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain  <span class="keyword">select</span>  <span class="operator">*</span>  <span class="keyword">from</span>  tb_user  <span class="keyword">where</span>  <span class="built_in">substring</span>(phone,<span class="number">10</span>,<span class="number">2</span>) <span class="operator">=</span> <span class="string">&#x27;15&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="/img/13143/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%883.png" alt="image-20230902161053946"></p><p>根据phone字段进行函数运算操作之后，索引失效</p><h3 id="字符串不加引号"><a href="#字符串不加引号" class="headerlink" title="字符串不加引号"></a>字符串不加引号</h3><blockquote><p>字符串类型字段使用时，不加引号，索引将失效</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone <span class="operator">=</span> <span class="string">&#x27;17799990015&#x27;</span>;</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone <span class="operator">=</span> <span class="number">17799990015</span>;</span><br></pre></td></tr></table></figure><p><img src="/img/13143/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%884.png" alt="image-20230902161301773"></p><h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><blockquote><p>尾部模糊匹配，索引不会失效。<strong>头部模糊匹配</strong>，索引失效</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">explain  <span class="keyword">select</span>  <span class="operator">*</span>  <span class="keyword">from</span>  tb_user  <span class="keyword">where</span>  profession <span class="keyword">like</span> <span class="string">&#x27;软件%&#x27;</span>;</span><br><span class="line">explain  <span class="keyword">select</span>  <span class="operator">*</span>  <span class="keyword">from</span>  tb_user  <span class="keyword">where</span>  profession <span class="keyword">like</span> <span class="string">&#x27;%工程&#x27;</span>;</span><br><span class="line">explain  <span class="keyword">select</span>  <span class="operator">*</span>  <span class="keyword">from</span>  tb_user  <span class="keyword">where</span>  profession <span class="keyword">like</span> <span class="string">&#x27;%工%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="/img/13143/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%885.png" alt="image-20230902161446391"></p><p>在like模糊查询中，在关键字后面加%，索引可以生效。而如果在关键字<strong>前面加了%<strong>，索引</strong>将会失效</strong></p><h3 id="or连接条件"><a href="#or连接条件" class="headerlink" title="or连接条件"></a>or连接条件</h3><blockquote><p>用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引<strong>都不会</strong>被用到</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">10</span> <span class="keyword">or</span> age <span class="operator">=</span> <span class="number">23</span>;</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone <span class="operator">=</span> <span class="string">&#x27;17799990017&#x27;</span> <span class="keyword">or</span> age <span class="operator">=</span> <span class="number">23</span>;</span><br></pre></td></tr></table></figure><p><img src="/img/13143/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%886.png" alt="image-20230902161651202"></p><p>由于age没有索引，所以即使id、phone有索引，索引也会失效</p><h3 id="数据分布影响"><a href="#数据分布影响" class="headerlink" title="数据分布影响"></a>数据分布影响</h3><blockquote><p>如果MySQL评估使用索引比全表更慢，则不使用索引</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone <span class="operator">&gt;=</span> <span class="string">&#x27;17799990005&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone <span class="operator">&gt;=</span> <span class="string">&#x27;17799990015&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="/img/13143/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%887.png" alt="image-20230902161847037"></p><p>MySQL在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃索引，走全表扫描</p><h2 id="🍁SQL提示"><a href="#🍁SQL提示" class="headerlink" title="🍁SQL提示"></a>🍁SQL提示</h2><blockquote><p>SQL提示是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优 化操作的目的</p><p>在查询的时候，自己来指定使用哪个索引</p></blockquote><h3 id="use-index"><a href="#use-index" class="headerlink" title="use index"></a>use index</h3><blockquote><p>建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进行评估）</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user use index(idx_user_pro) <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工</span></span><br><span class="line"><span class="string">程&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="ignore-index"><a href="#ignore-index" class="headerlink" title="ignore index"></a>ignore index</h3><blockquote><p>忽略指定的索引</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user ignore index(idx_user_pro) <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工</span></span><br><span class="line"><span class="string">程&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="force-index"><a href="#force-index" class="headerlink" title="force index"></a>force index</h3><blockquote><p> 强制使用索引</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user force index(idx_user_pro) <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工</span></span><br><span class="line"><span class="string">程&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="🍁覆盖索引"><a href="#🍁覆盖索引" class="headerlink" title="🍁覆盖索引"></a>🍁覆盖索引</h2><blockquote><p>覆盖索引是指 查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到</p></blockquote><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><h4 id="1-表结构及索引示意图"><a href="#1-表结构及索引示意图" class="headerlink" title="1.表结构及索引示意图"></a>1.表结构及索引示意图</h4><p><img src="/img/13143/%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%951.png" alt="image-20230902162909592"></p><p>说明：id是主键，是一个聚集索引。 name字段建立了普通索引，是一个二级索引（辅助索引）</p><h4 id="2-执行：select-from-tb-user-where-id-x3D-2"><a href="#2-执行：select-from-tb-user-where-id-x3D-2" class="headerlink" title="2.执行：select * from tb_user where id &#x3D; 2;"></a>2.执行：select * from tb_user where id &#x3D; 2;</h4><p><img src="/img/13143/%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%952.png" alt="image-20230902163019030"></p><p>根据id查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。</p><h4 id="3-执行：select-id-name-from-tb-user-where-name-x3D-‘Arm’"><a href="#3-执行：select-id-name-from-tb-user-where-name-x3D-‘Arm’" class="headerlink" title="3.执行：select id,name from tb_user where name &#x3D; ‘Arm’;"></a>3.执行：select id,name from tb_user where name &#x3D; ‘Arm’;</h4><p><img src="/img/13143/%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%953.png" alt="image-20230902163120038"></p><p>虽然是根据name字段查询，查询二级索引，但是由于查询返回在字段为 id，name，在name的二级索引中，这两个值都是可以直接获取到的，因为<strong>覆盖索引</strong>，所以不需要回表查询，性能高</p><h4 id="4-执行：select-id-name-gender-from-tb-user-where-name-x3D-‘Arm’"><a href="#4-执行：select-id-name-gender-from-tb-user-where-name-x3D-‘Arm’" class="headerlink" title="4.执行：select id,name,gender from tb_user where name &#x3D; ‘Arm’;"></a>4.执行：select id,name,gender from tb_user where name &#x3D; ‘Arm’;</h4><p><img src="/img/13143/%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%954.png" alt="image-20230902163234966"></p><p>由于在name的二级索引中，不包含gender，所以，需要两次索引扫描，也就是需要<strong>回表查询</strong>，性能相对较差</p><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>一张表, 有四个字段(id, username, password, status), 对以下SQL语句进行优化:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,username,password <span class="keyword">from</span> tb_user <span class="keyword">where</span> username <span class="operator">=</span> <span class="string">&#x27;itcast&#x27;</span>;</span><br></pre></td></tr></table></figure><p>解析：</p><p>针对于 username, password建立联合索引, sql为:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_user_name_pass <span class="keyword">on</span> tb_user(username,password); </span><br></pre></td></tr></table></figure><p>这样避免上述的SQL语句，在查询的过程中，出现回表查询</p><p>🚩<strong>根据覆盖索引的原则，应少用select * …;</strong></p><h2 id="🍁前缀索引"><a href="#🍁前缀索引" class="headerlink" title="🍁前缀索引"></a>🍁前缀索引</h2><blockquote><p>当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将字符串的<strong>一部分前缀建立索引</strong>，这样可以大大节约索引空间，从而提高索引效率</p></blockquote><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index  idx_xxxx <span class="keyword">on</span> table_name(<span class="keyword">column</span>(n)) ;</span><br></pre></td></tr></table></figure><p>示例：为tb_user表的email字段，建立长度为5的前缀索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_email_5 <span class="keyword">on</span> tb_user(email(<span class="number">5</span>));</span><br></pre></td></tr></table></figure><h3 id="前缀长度"><a href="#前缀长度" class="headerlink" title="前缀长度"></a>前缀长度</h3><p>可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值， 索引选择性越高则查询效率越高， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  <span class="built_in">count</span>(<span class="keyword">distinct</span> email) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>)   <span class="keyword">from</span>  tb_user ;</span><br><span class="line"><span class="keyword">select</span>  <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="built_in">substring</span>(email,<span class="number">1</span>,<span class="number">5</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>)  <span class="keyword">from</span>  tb_user ;</span><br></pre></td></tr></table></figure><h3 id="前缀索引的查询流程"><a href="#前缀索引的查询流程" class="headerlink" title="前缀索引的查询流程"></a>前缀索引的查询流程</h3><p><img src="/img/13143/%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95.png" alt="image-20230902164841767"></p><h2 id="🍁单列索引与联合索引"><a href="#🍁单列索引与联合索引" class="headerlink" title="🍁单列索引与联合索引"></a>🍁单列索引与联合索引</h2><blockquote><p>单列索引：即一个索引只包含单个列</p><p>联合索引：即一个索引包含了多个列</p></blockquote><p>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引， 而非单列索引。</p><p><img src="/img/13143/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95.png" alt="image-20230902165135541"></p><h2 id="🍁索引设计原则"><a href="#🍁索引设计原则" class="headerlink" title="🍁索引设计原则"></a>🍁索引设计原则</h2><ol><li>针对于数据量较大，且<strong>查询比较频繁</strong>的表建立索引。</li><li>针对于常作为<strong>查询条件（where）、排序（order by）、分组（group by）操作的字段</strong>建立索引。</li><li>尽量选择<strong>区分度高的列</strong>作为索引，尽量建立<strong>唯一索引</strong>，区分度越高，使用索引的效率越高。</li><li>如果是字符串类型的字段，字段的<strong>长度较长</strong>，可以针对于字段的特点，建立<strong>前缀索引</strong>。</li><li><strong>尽量使用联合索引，减少单列索引</strong>，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</li><li>要<strong>控制索引的数量</strong>，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</li><li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。</li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引</title>
      <link href="/posts/33592/"/>
      <url>/posts/33592/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁B-Tree、B-Tree和Hash索引"><a href="#🍁B-Tree、B-Tree和Hash索引" class="headerlink" title="🍁B-Tree、B+Tree和Hash索引"></a>🍁B-Tree、B+Tree和Hash索引</h2><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><h4 id="（1）介绍"><a href="#（1）介绍" class="headerlink" title="（1）介绍"></a>（1）介绍</h4><blockquote><p>B树是一种多叉路平衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉树</p></blockquote><p>以一颗最大度数（<strong>max-degree</strong>）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个<strong>key</strong>，5 个<strong>指针</strong>：</p><p><img src="/img/33592/MySQL%E7%B4%A2%E5%BC%951.png" alt="image-20230828230318153"></p><blockquote><p>树的度数指的是一个节点的<strong>子节点个数</strong></p></blockquote><h4 id="（2）示例"><a href="#（2）示例" class="headerlink" title="（2）示例"></a>（2）示例</h4><p>插入一组数据查看B-Tree的变化</p><p>1.插入4个数：</p><p><img src="/img/33592/B-Tree1.png" alt="image-20230828231128465"></p><p>2.再插入1个数，超过最大度数，中间节点向上分裂：</p><p><img src="/img/33592/B-Tree2.png" alt="image-20230828231356430"></p><p>3.再插入一些数：</p><p><img src="/img/33592/B-Tree3.png" alt="image-20230828231450353"></p><p>4.再插入1000，右边中间节点向上分裂：</p><p><img src="/img/33592/B-Tree4.png" alt="image-20230828231614961"></p><p>5.再插入一些数：</p><p><img src="/img/33592/B-Tree5.png" alt="image-20230828231731241"></p><p>6.插入1个数245，两次向上分裂：</p><p><img src="/img/33592/B-Tree6.png" alt="image-20230828231855604"></p><h4 id="（3）总结"><a href="#（3）总结" class="headerlink" title="（3）总结"></a>（3）总结</h4><ul><li>n阶的B树，每一个节点最多存储<strong>n-1个key</strong>，对应<strong>n个指针</strong>。</li><li>一旦节点存储的key数量到达n，就会裂变，<strong>中间元素向上分裂</strong>。</li><li>在B树中，<strong>非叶子节点和叶子节点</strong>都会存放数据。</li></ul><h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h3><h4 id="（1）介绍-1"><a href="#（1）介绍-1" class="headerlink" title="（1）介绍"></a>（1）介绍</h4><blockquote><p>B+Tree是B-Tree的变种，分为非叶子节点存索引，叶子节点存数据</p></blockquote><p>以一颗最大度数（max-degree）为4（4阶）的b+tree为例：</p><p><img src="/img/33592/B+Tree1.png" alt="image-20230828232345768"></p><p>绿色框是索引部分，仅仅起到<strong>索引数据</strong>的作用，不存储数据。</p><p>红色框是数据存储部分，在其叶子节点中要<strong>存储</strong>具体的数据</p><h4 id="（2）示例-1"><a href="#（2）示例-1" class="headerlink" title="（2）示例"></a>（2）示例</h4><p><img src="/img/33592/B+Tree2.png" alt="image-20230828232546423"></p><h4 id="（3）总结-1"><a href="#（3）总结-1" class="headerlink" title="（3）总结"></a>（3）总结</h4><ul><li>所有的数据都会出现在<strong>叶子节点</strong>。 </li><li>叶子节点形成一个<strong>单向链表</strong>。</li><li><strong>非叶子节点</strong>仅仅起到<strong>索引数据</strong>作用，具体的<strong>数据都是在叶子节点存放</strong>的。</li></ul><h4 id="（4）MySQL优化"><a href="#（4）MySQL优化" class="headerlink" title="（4）MySQL优化"></a>（4）MySQL优化</h4><p><img src="/img/33592/B+Tree3.png" alt="image-20230828232716047"></p><p>在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有<strong>双向指针</strong>的B+Tree，提高区间访问的性能，利于排序</p><h3 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h3><h4 id="（1）介绍-2"><a href="#（1）介绍-2" class="headerlink" title="（1）介绍"></a>（1）介绍</h4><blockquote><p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在 hash表中</p></blockquote><p><img src="/img/33592/Hash%E7%B4%A2%E5%BC%95.png" alt="image-20230829160928710"></p><p>如果两个(或多个)键值，映射到一个相同的槽位上，就产生了<strong>hash冲突</strong>（也称为hash碰撞），通过<strong>链表</strong>来解决</p><h4 id="（2）特点"><a href="#（2）特点" class="headerlink" title="（2）特点"></a>（2）特点</h4><ul><li>Hash索引只能用于对等比较(&#x3D;，in)，<strong>不支持范围查询</strong>（between，&gt;，&lt; ，…）</li><li>无法利用<strong>索引</strong>完成排序操作</li><li>查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索引</li></ul><h4 id="（3）存储引擎"><a href="#（3）存储引擎" class="headerlink" title="（3）存储引擎"></a>（3）存储引擎</h4><p>在MySQL中，支持hash索引的是<strong>Memory存储引擎</strong>。 而InnoDB中具有自适应hash功能，hash索引是 InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的</p><h3 id="选择B-Tree的原因"><a href="#选择B-Tree的原因" class="headerlink" title="选择B+Tree的原因"></a>选择B+Tree的原因</h3><p>相对于二叉树，层级更少，搜索效率高； </p><p>对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低； </p><p>相对Hash索引，B+tree支持范围匹配及排序操作；</p><h2 id="🍁索引分类"><a href="#🍁索引分类" class="headerlink" title="🍁索引分类"></a>🍁索引分类</h2><h3 id="MySQL数据库分类"><a href="#MySQL数据库分类" class="headerlink" title="MySQL数据库分类"></a>MySQL数据库分类</h3><table><thead><tr><th>分类</th><th>介绍</th><th>数量</th><th>关键字</th></tr></thead><tbody><tr><td>主键索引</td><td>针对于表中主键创建的索引</td><td>默认自动创建，只有一个</td><td>PRIMARY</td></tr><tr><td>唯一索引</td><td>避免同一个表中某数据列中的值重复</td><td>多个</td><td>UNIQUE</td></tr><tr><td>常规索引</td><td>快速定位特定数据</td><td>多个</td><td></td></tr><tr><td>全文索引</td><td>全文索引查找的是文本中的关键词，而不是比 较索引中的值</td><td>多个</td><td>FULLTEXT</td></tr></tbody></table><h3 id="InnoDB存储引擎分类"><a href="#InnoDB存储引擎分类" class="headerlink" title="InnoDB存储引擎分类"></a>InnoDB存储引擎分类</h3><h4 id="（1）分类"><a href="#（1）分类" class="headerlink" title="（1）分类"></a>（1）分类</h4><table><thead><tr><th>分类</th><th>介绍</th><th>数量</th></tr></thead><tbody><tr><td>聚集索引(Clustered Index)</td><td>将数据存储与索引放到了一块，索引结构的叶子 节点保存了行数据</td><td>必须有,而且只 有一个</td></tr><tr><td>二级索引(Secondary Index)</td><td>将数据与索引分开存储，索引结构的叶子节点关 联的是对应的主键</td><td>多个</td></tr></tbody></table><h4 id="（2）聚集索引选取规则"><a href="#（2）聚集索引选取规则" class="headerlink" title="（2）聚集索引选取规则"></a>（2）聚集索引选取规则</h4><ul><li>如果存在主键，<strong>主键</strong>索引就是聚集索引。</li><li>如果不存在主键，将使用<strong>第一个唯一</strong>（UNIQUE）索引作为聚集索引。</li><li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个<strong>rowid</strong>作为隐藏的聚集索引</li></ul><h4 id="（3）具体结构"><a href="#（3）具体结构" class="headerlink" title="（3）具体结构"></a>（3）具体结构</h4><img src="/img/33592/聚集二级索引1.png" alt="image-20230829171222052" style="zoom:80%;" /><ul><li>聚集索引的叶子节点下挂的是这<strong>一行的数据</strong> 。 </li><li>二级索引的叶子节点下挂的是该字段值<strong>对应的主键值</strong>。</li></ul><h4 id="（4）查找示例"><a href="#（4）查找示例" class="headerlink" title="（4）查找示例"></a>（4）查找示例</h4><img src="/img/33592/聚集二级索引2.png" alt="image-20230829171413948" style="zoom:80%;" /><ol><li>根据name字段进行查询，所以先根据name&#x3D;’Arm’到name字段的二级索引中进行匹配查找。但是在二级索引中只能查找到 Arm 对应的主键值 10。</li><li>由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最终找到10对应的行row。 </li><li>最终拿到这一行的数据，直接返回即可。</li></ol><blockquote><p>回表查询： 这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取 数据的方式，就称之为回表查询。</p></blockquote><h4 id="（5）总结"><a href="#（5）总结" class="headerlink" title="（5）总结"></a>（5）总结</h4><p>走主键索引的效率高于走二级索引</p><p>InnoDB主键索引的B+tree高度：树的高度为3，则可以存储 2200w 左右的记录</p><h2 id="🍁索引语法"><a href="#🍁索引语法" class="headerlink" title="🍁索引语法"></a>🍁索引语法</h2><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  [ <span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT ]  INDEX  index_name  <span class="keyword">ON</span>  table_name  ( </span><br><span class="line">index_col_name,... ) ;</span><br></pre></td></tr></table></figure><h3 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span>  INDEX  <span class="keyword">FROM</span>  table_name ;</span><br></pre></td></tr></table></figure><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span>  INDEX  index_name  <span class="keyword">ON</span>  table_name ;</span><br></pre></td></tr></table></figure><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>1.phone手机号字段的值，是非空，且唯一的，为该字段创建唯一索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX idx_user_phone <span class="keyword">ON</span> tb_user(phone);</span><br></pre></td></tr></table></figure><p>2.为profession、age、status创建联合索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_user_pro_age_sta <span class="keyword">ON</span> tb_user(profession,age,status);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL存储引擎</title>
      <link href="/posts/14571/"/>
      <url>/posts/14571/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁简介"><a href="#🍁简介" class="headerlink" title="🍁简介"></a>🍁简介</h2><blockquote><p>存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式 。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型</p></blockquote><p>建表时指定存储引擎</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE  表名(</span><br><span class="line">    字段1  字段1类型   [ COMMENT  字段1注释 ] ,</span><br><span class="line">     ......</span><br><span class="line">    字段n  字段n类型   [COMMENT  字段n注释 ] </span><br><span class="line">) ENGINE = INNODB   [ COMMENT  表注释 ] ;</span><br></pre></td></tr></table></figure><h2 id="🍁主要分类"><a href="#🍁主要分类" class="headerlink" title="🍁主要分类"></a>🍁主要分类</h2><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><blockquote><p>兼顾高可靠性和高性能的通用存储引擎， MySQL 5.5 之后，InnoDB是默认的存储引擎</p></blockquote><h4 id="1-特点"><a href="#1-特点" class="headerlink" title="1.特点"></a>1.特点</h4><ul><li>DML操作遵循ACID模型，支持事务； </li><li>行级锁，提高并发访问性能； </li><li>支持外键FOREIGN KEY约束，保证数据的完整性和正确性；</li></ul><h4 id="2-文件"><a href="#2-文件" class="headerlink" title="2.文件"></a>2.文件</h4><p>xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm-早期的 、sdi-新版的）、数据和索引。</p><h4 id="3-逻辑存储结构"><a href="#3-逻辑存储结构" class="headerlink" title="3.逻辑存储结构"></a>3.逻辑存储结构</h4><p><img src="/img/14571/mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.png" alt="image-20230827103143080"></p><p>表空间: InnoDB存储引擎逻辑结构的<strong>最高层</strong>，ibd文件其实就是表空间文件，在表空间中可以<br>包含多个Segment段。<br>段 : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管<br>理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。<br>区 : 区是表空间的单元结构，每个区的大小为<strong>1M</strong>。 默认情况下， InnoDB存储引擎页大小为<br>16K， 即一个区中一共有<strong>64个连续的页</strong>。<br>页 : 页是组成区的<strong>最小单元</strong>，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默<br>认为 <strong>16KB</strong>。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。<br>行 : InnoDB 存储引擎是面向行的，也就是说<strong>数据是按行进行存放</strong>的，在每一行中除了定义表时<br>所指定的字段以外，还包含两个隐藏字段(后面会详细介绍)。</p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><blockquote><p>MyISAM是MySQL早期的默认存储引擎</p></blockquote><h4 id="1-特点-1"><a href="#1-特点-1" class="headerlink" title="1.特点"></a>1.特点</h4><ul><li>不支持事务，不支持外键</li><li>支持表锁，不支持行锁</li><li>访问速度快</li></ul><h4 id="2-文件-1"><a href="#2-文件-1" class="headerlink" title="2.文件"></a>2.文件</h4><ul><li>xxx.sdi：存储表结构信息</li><li>xxx.MYD: 存储数据</li><li>xxx.MYI: 存储索引</li></ul><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><blockquote><p>Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为 临时表或缓存使用</p></blockquote><h4 id="1-特点-2"><a href="#1-特点-2" class="headerlink" title="1.特点"></a>1.特点</h4><ul><li>内存存放</li><li>hash索引（默认）</li></ul><h4 id="2-文件-2"><a href="#2-文件-2" class="headerlink" title="2.文件"></a>2.文件</h4><p>xxx.sdi：存储表结构信息</p><h2 id="🍁区别"><a href="#🍁区别" class="headerlink" title="🍁区别"></a>🍁区别</h2><img src="/img/14571/mysql存储引擎2.png" alt="image-20230827104044780" style="zoom: 67%;" /><p><strong>（面试）InnoDB引擎与MyISAM引擎的区别 ?</strong></p><ul><li>InnoDB引擎支持事务, 而MyISAM不支持。</li><li>InnoDB引擎支持行锁和表锁, 而MyISAM仅支持表锁, 不支持行锁。</li><li>InnoDB引擎支持外键, 而MyISAM是不支持的。</li></ul><p>（<strong>外键事务行级锁</strong>）</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础</title>
      <link href="/posts/39026/"/>
      <url>/posts/39026/</url>
      
        <content type="html"><![CDATA[<p>主要总结MySQL基础部分的易错点和易忽略点</p><h2 id="🍁数据类型"><a href="#🍁数据类型" class="headerlink" title="🍁数据类型"></a>🍁数据类型</h2><p>MySQL中的数据类型主要分为三类：数值类型、字符串类型、日期时间类型</p><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p><strong>DECIMAL</strong></p><blockquote><p>依赖于M(精度)和D(标度) 的值</p></blockquote><p>如decimal(5,2)，5-2&#x3D;3，其中小数部分为2，对应1个字节，整数部分为3，对应2个字节</p><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p><strong>CHAR&#x2F;VARCHAR</strong></p><blockquote><p>char是定长字符串，指定长度多长，就占用多少个字符，和字段值的长度无关 。而varchar是变长字符串，指定的长度为最大占用长度</p></blockquote><h3 id="日期时间类型"><a href="#日期时间类型" class="headerlink" title="日期时间类型"></a>日期时间类型</h3><table><thead><tr><th align="center">类型</th><th align="center">范围</th><th align="center">格式</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">DATE</td><td align="center">1000-01-01 至 9999-12-31</td><td align="center">YYYY-MM-DD</td><td align="center">日期值</td></tr><tr><td align="center">TIME</td><td align="center">-838:59:59 至 838:59:59</td><td align="center">HH:MM:SS</td><td align="center">时间值</td></tr><tr><td align="center">DATETIME</td><td align="center">1000-01-01 00:00:00 至 <br />9999-12-31 23:59:59</td><td align="center">YYYY-MM-DD HH:MM:SS</td><td align="center">混合日期和时间</td></tr></tbody></table><h2 id="🍁SQL"><a href="#🍁SQL" class="headerlink" title="🍁SQL"></a>🍁SQL</h2><h3 id="日期时间类型的操作"><a href="#日期时间类型的操作" class="headerlink" title="日期时间类型的操作"></a>日期时间类型的操作</h3><p>插入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;张无忌&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;123456789012345670&#x27;</span>,<span class="string">&#x27;2005-01</span></span><br><span class="line"><span class="string">01&#x27;</span>);</span><br></pre></td></tr></table></figure><p>更新</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> employee <span class="keyword">set</span> entrydate <span class="operator">=</span> <span class="string">&#x27;2008-01-01&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><h4 id="BETWEEN-…-AND-…"><a href="#BETWEEN-…-AND-…" class="headerlink" title="BETWEEN … AND …"></a>BETWEEN … AND …</h4><p>在某个范围之内(含<strong>最小、最大</strong>值)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 查询年龄在<span class="number">15</span>岁(包含) 到 <span class="number">20</span>岁(包含)之间的员工信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="keyword">between</span> <span class="number">15</span> <span class="keyword">and</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure><h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><p>1.语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  字段列表  <span class="keyword">FROM</span>   表名  [ <span class="keyword">WHERE</span>   条件 ]  <span class="keyword">GROUP</span>   <span class="keyword">BY</span>  分组字段名  [ <span class="keyword">HAVING</span>  分组</span><br><span class="line">后过滤条件 ];</span><br></pre></td></tr></table></figure><p>2.where与having区别</p><ul><li>执行时机不同：where是<strong>分组之前</strong>进行过滤，不满足where条件，不参与分组；而having是<strong>分组之后</strong>对结果进行过滤</li><li>判断条件不同：where<strong>不能对聚合函数进行判断</strong>，而having可以</li></ul><p>3.聚合函数</p><ul><li>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义</li><li>执行顺序: where &gt; 聚合函数 &gt; having </li><li>支持多字段分组, 具体语法为 : group by columnA,columnB</li></ul><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><p>1.语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  字段列表  <span class="keyword">FROM</span>   表名  LIMIT  起始索引, 查询记录数 ;</span><br></pre></td></tr></table></figure><p>2.注意事项<br>起始索引从0开始，起始索引 &#x3D; <em><em>（查询页码 - 1）</em> 每页显示记录数</em>*<br>如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10</p><p>3.示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 查询第<span class="number">2</span>页员工数据, 每页展示<span class="number">10</span>条记录,注意起始索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp limit <span class="number">10</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>4.查询排名前几</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>查询性别为男，且年龄在<span class="number">20</span><span class="number">-40</span> 岁(含)以内的前<span class="number">5</span>个员工信息，对查询的结果按年龄升序排序，</span><br><span class="line">年龄相同按入职时间升序排序。</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> gender <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span> <span class="keyword">and</span> age <span class="keyword">between</span> <span class="number">20</span> <span class="keyword">and</span> <span class="number">40</span> <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span> , </span><br><span class="line">entrydate <span class="keyword">asc</span> limit <span class="number">5</span> ;</span><br></pre></td></tr></table></figure><h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><p><img src="/img/39026/mysql1.png" alt="image-20230824231550177"></p><h2 id="🍁约束"><a href="#🍁约束" class="headerlink" title="🍁约束"></a>🍁约束</h2><h3 id="约束类型"><a href="#约束类型" class="headerlink" title="约束类型"></a>约束类型</h3><img src="/img/39026/mysql2.png" alt="image-20230826170040097" style="zoom:80%;" /><p>建表演示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_user(</span><br><span class="line">id <span class="type">int</span> AUTO_INCREMENT PRIMAEY KEY COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">age <span class="type">int</span> <span class="keyword">check</span>(age <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> age <span class="operator">&lt;=</span> <span class="number">120</span>) COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">status <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;1&#x27;</span> COMMENT <span class="string">&#x27;状态&#x27;</span>,</span><br><span class="line">gender <span class="type">char</span>(<span class="number">1</span>) COMMENT <span class="string">&#x27;性别&#x27;</span>,</span><br><span class="line">dept_id <span class="type">int</span> COMMENT <span class="string">&#x27;部门&#x27;</span>,</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY(dept_id) <span class="keyword">REFERENCES</span> dept(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="添加外键"><a href="#添加外键" class="headerlink" title="添加外键"></a>添加外键</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">字段名    数据类型,</span><br><span class="line"> ...</span><br><span class="line"> [<span class="keyword">CONSTRAINT</span>]  [外键名称] <span class="keyword">FOREIGN</span>  KEY (外键字段名)   <span class="keyword">REFERENCES</span>   主表 (主表列名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span>   <span class="keyword">TABLE</span>  表名   <span class="keyword">ADD</span>  <span class="keyword">CONSTRAINT</span>   外键名称   <span class="keyword">FOREIGN</span>   KEY (外键字段名)  </span><br><span class="line"><span class="keyword">REFERENCES</span>  主表 (主表列名) ;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 示例</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">add</span> <span class="keyword">constraint</span> fk_emp_dept_id <span class="keyword">foreign</span> key (dept_id) <span class="keyword">references</span> </span><br><span class="line">dept(id)  <span class="keyword">on</span> <span class="keyword">update</span> cascade <span class="keyword">on</span> <span class="keyword">delete</span> cascade;</span><br></pre></td></tr></table></figure><h2 id="🍁事务"><a href="#🍁事务" class="headerlink" title="🍁事务"></a>🍁事务</h2><h3 id="事务的四大特性ACID"><a href="#事务的四大特性ACID" class="headerlink" title="事务的四大特性ACID"></a>事务的四大特性ACID</h3><p>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。 </p><p>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。 </p><p>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。 </p><p>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</p><h3 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h3><h4 id="1-脏读"><a href="#1-脏读" class="headerlink" title="1.脏读"></a>1.脏读</h4><blockquote><p>一个事务读到另外一个事务还没有提交的数据。</p></blockquote><p><img src="/img/39026/%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%981.png" alt="image-20230826174624091"></p><p>B读取到了A未提交的数据</p><h4 id="2-不可重复读"><a href="#2-不可重复读" class="headerlink" title="2.不可重复读"></a>2.不可重复读</h4><blockquote><p>一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</p></blockquote><p><img src="/img/39026/%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%982.png" alt="image-20230826174749208"></p><p>事务A两次读取同一条记录，但是读取到的数据却是不一样的</p><h4 id="3-幻读"><a href="#3-幻读" class="headerlink" title="3.幻读"></a>3.幻读</h4><blockquote><p>一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据 已经存在，好像出现了 “幻影”。</p></blockquote><p><img src="/img/39026/%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%983.png" alt="image-20230826174853048"></p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><table><thead><tr><th align="center">隔离级别</th><th align="center">存在脏读</th><th align="center">存在不可重复读</th><th align="center">存在幻读</th></tr></thead><tbody><tr><td align="center">Read uncommitted</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">Read committed</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">Repeatable Read(默认)</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">Serializable</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BST示例</title>
      <link href="/posts/43338/"/>
      <url>/posts/43338/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁验证二叉搜索树"><a href="#🍁验证二叉搜索树" class="headerlink" title="🍁验证二叉搜索树"></a>🍁验证二叉搜索树</h2><blockquote><p>给定一棵树，验证是否为BST</p></blockquote><h3 id="中序非递归"><a href="#中序非递归" class="headerlink" title="中序非递归"></a>中序非递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历的代码框架</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">long</span> <span class="variable">prev</span> <span class="operator">=</span> Long.MIN_VALUE; <span class="comment">// 防止Integer.MIN_VALUE失效</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (prev &gt;= pop.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = pop.val;</span><br><span class="line">            p = pop.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序递归"><a href="#中序递归" class="headerlink" title="中序递归"></a>中序递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> doValid(<span class="keyword">new</span> <span class="title class_">AtomicLong</span>(Long.MIN_VALUE),root);</span><br><span class="line">    <span class="comment">// Long或long为局部变量且不可变</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">doValid</span><span class="params">(AtomicLong prev, TreeNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123; <span class="comment">//出口</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">a</span> <span class="operator">=</span> doValid(prev, node.left); <span class="comment">// 左</span></span><br><span class="line">    <span class="keyword">if</span> (prev.get() &gt;= node.val) &#123; <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    prev.set(node.val);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> doValid(prev, node.right); <span class="comment">// 右</span></span><br><span class="line">    <span class="keyword">return</span> a &amp;&amp; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="上下限递归"><a href="#上下限递归" class="headerlink" title="上下限递归"></a>上下限递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设每个节点必须在一个范围内：(min, max)，不包含边界，若节点值超过这个范围，则返回 false</span></span><br><span class="line"><span class="comment">// 对于 node.left 范围肯定是 (min, node.val)</span></span><br><span class="line"><span class="comment">// 对于 node.right 范围肯定是 (node.val, max)</span></span><br><span class="line"><span class="comment">// 一开始不知道 min，max 则取 java 中长整数的最小、最大值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> doValid(node, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">doValid</span><span class="params">(TreeNode node, <span class="type">long</span> min, <span class="type">long</span> max)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.val &lt;= min || node.val &gt;= max) &#123; <span class="comment">// 节点值必须在范围内</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> doValid(node.left, min, node.val) &amp;&amp; doValid(node.right, node.val, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🍁求范围和"><a href="#🍁求范围和" class="headerlink" title="🍁求范围和"></a>🍁求范围和</h2><blockquote><p>求BST中给定范围内的节点值之和</p></blockquote><h3 id="中序递归-1"><a href="#中序递归-1" class="headerlink" title="中序递归"></a>中序递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeSumBST</span><span class="params">(TreeNode node, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> rangeSumBST(node.left,low,high);</span><br><span class="line">    <span class="type">int</span> b=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(node.val&gt;=low &amp;&amp; node.val&lt;=high)&#123;</span><br><span class="line">        b = node.val;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> a + b + rangeSumBST(node.right, low, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序非递归-1"><a href="#中序非递归-1" class="headerlink" title="中序非递归"></a>中序非递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeSumBST</span><span class="params">(TreeNode node, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> node;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>()&lt;&gt;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">null</span> &amp;&amp; !stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(p!=<span class="literal">null</span>)&#123;</span><br><span class="line">            stack.add(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(pop.val &lt; high)&#123;</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pop.val &gt;= low)&#123;</span><br><span class="line">                sum += pop.val;</span><br><span class="line">            &#125;</span><br><span class="line">            p = pop.right;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="上下限递归-1"><a href="#上下限递归-1" class="headerlink" title="上下限递归"></a>上下限递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node.val &lt; low 只需考虑它右子树的累加结果</span></span><br><span class="line"><span class="comment">// node.val &gt; high 只需考虑它左子树的累加结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeSumBST</span><span class="params">(TreeNode node, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.val &lt; low) &#123;</span><br><span class="line">        <span class="keyword">return</span> rangeSumBST(node.right, low, high);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (node.val &gt; high) &#123;</span><br><span class="line">        <span class="keyword">return</span> rangeSumBST(node.left, low, high);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.val + </span><br><span class="line">        rangeSumBST(node.left, low, high) + </span><br><span class="line">        rangeSumBST(node.right, low, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🍁根据前序遍历结果构造二叉搜索树"><a href="#🍁根据前序遍历结果构造二叉搜索树" class="headerlink" title="🍁根据前序遍历结果构造二叉搜索树"></a>🍁根据前序遍历结果构造二叉搜索树</h2><blockquote><p>由前序遍历结果可以唯一构造一棵BST</p></blockquote><h3 id="直接插入"><a href="#直接插入" class="headerlink" title="直接插入"></a>直接插入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">bstFromPreorder</span><span class="params">(<span class="type">int</span>[] preorder)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> insert(<span class="literal">null</span>, preorder[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; preorder.length; i++) &#123;</span><br><span class="line">        insert(root, preorder[i]); <span class="comment">// 遍历插入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">insert</span><span class="params">(TreeNode node, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123; <span class="comment">// 节点为空时插入</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(val &lt; node.val) &#123;</span><br><span class="line">        node.left = insert(node.left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(node.val &lt; val)&#123;</span><br><span class="line">        node.right = insert(node.right, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="上限法"><a href="#上限法" class="headerlink" title="上限法"></a>上限法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依次处理 prevorder 中每个值, 返回创建好的节点或 null 作为上个节点的孩子</span></span><br><span class="line"><span class="comment">// 1. 如果超过上限, 返回 null</span></span><br><span class="line"><span class="comment">// 2. 如果没超过上限, 创建节点, 并将其左右孩子设置完整后返回</span></span><br><span class="line"><span class="comment">// i++ 需要放在设置左右孩子之前，意思是从剩下的元素中挑选左右孩子</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">bstFromPreorder</span><span class="params">(<span class="type">int</span>[] preorder)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> insert(preorder, Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">insert</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == preorder.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> preorder[i];</span><br><span class="line">    System.out.println(val + String.format(<span class="string">&quot;[%d]&quot;</span>, max));</span><br><span class="line">    <span class="keyword">if</span> (val &gt; max) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">    i++;</span><br><span class="line">    node.left = insert(preorder, node.val); </span><br><span class="line">    node.right = insert(preorder, max);     </span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🍁二叉搜索树的最近公共祖先"><a href="#🍁二叉搜索树的最近公共祖先" class="headerlink" title="🍁二叉搜索树的最近公共祖先"></a>🍁二叉搜索树的最近公共祖先</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要点：若 p，q 在 ancestor 的两侧，则 ancestor 就是它们的最近公共祖先</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">ancestor</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (ancestor.val &gt; p.val &amp;&amp; ancestor.val &gt; q.val || </span><br><span class="line">           ancestor.val &lt; p.val &amp;&amp; ancestor.val &lt; q.val) &#123; <span class="comment">// p,q都小于或大于当前节点（在一侧）</span></span><br><span class="line">        <span class="keyword">if</span> (ancestor.val &gt; p.val) &#123;</span><br><span class="line">            ancestor = ancestor.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ancestor = ancestor.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ancestor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/posts/41107/"/>
      <url>/posts/41107/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁二叉树非递归遍历实现"><a href="#🍁二叉树非递归遍历实现" class="headerlink" title="🍁二叉树非递归遍历实现"></a>🍁二叉树非递归遍历实现</h2><h3 id="统一写法"><a href="#统一写法" class="headerlink" title="统一写法"></a>统一写法</h3><img src="/img/41107/Sorted_binary_tree_ALL_RGB.svg.png" alt="Sorted_binary_tree_ALL_RGB.svg" style="zoom:80%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> root; <span class="comment">// 代表当前节点</span></span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">pop</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 最近一次弹栈的元素</span></span><br><span class="line"><span class="keyword">while</span> (curr != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">        colorPrintln(<span class="string">&quot;前: &quot;</span> + curr.val, <span class="number">31</span>);</span><br><span class="line">        stack.push(curr); <span class="comment">// 压入栈，为了记住回来的路</span></span><br><span class="line">        curr = curr.left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">peek</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">        <span class="comment">// 右子树可以不处理, 对中序来说, 要在右子树处理之前打印</span></span><br><span class="line">        <span class="keyword">if</span> (peek.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            colorPrintln(<span class="string">&quot;中: &quot;</span> + peek.val, <span class="number">36</span>);</span><br><span class="line">            pop = stack.pop();</span><br><span class="line">            colorPrintln(<span class="string">&quot;后: &quot;</span> + pop.val, <span class="number">34</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右子树处理完成, 对中序来说, 无需打印</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (peek.right == pop) &#123;</span><br><span class="line">            pop = stack.pop();</span><br><span class="line">            colorPrintln(<span class="string">&quot;后: &quot;</span> + pop.val, <span class="number">34</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右子树待处理, 对中序来说, 要在右子树处理之前打印</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            colorPrintln(<span class="string">&quot;中: &quot;</span> + peek.val, <span class="number">36</span>);</span><br><span class="line">            curr = peek.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">colorPrintln</span><span class="params">(String origin, <span class="type">int</span> color)</span> &#123;</span><br><span class="line">    System.out.printf(<span class="string">&quot;\033[%dm%s\033[0m%n&quot;</span>, color, origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LinkedListStack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedListStack</span>&lt;&gt;();</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!stack.isEmpty() || curr != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">        stack.push(curr);</span><br><span class="line">        System.out.println(curr); <span class="comment">// 前序在此处理</span></span><br><span class="line">        curr = curr.left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        curr = pop.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LinkedListStack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedListStack</span>&lt;&gt;();</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!stack.isEmpty() || curr != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">        stack.push(curr);</span><br><span class="line">        curr = curr.left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        System.out.println(pop); <span class="comment">// 中序在此处理</span></span><br><span class="line">        curr = pop.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">LinkedListStack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedListStack</span>&lt;&gt;();</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">pop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!stack.isEmpty() || curr != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">        stack.push(curr);</span><br><span class="line">        curr = curr.left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">peek</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">        <span class="keyword">if</span> (peek.right == <span class="literal">null</span> || peek.right == pop) &#123;</span><br><span class="line">            pop = stack.pop();</span><br><span class="line">            System.out.println(pop);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curr = peek.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="示例题目：二叉树最大深度"><a href="#示例题目：二叉树最大深度" class="headerlink" title="示例题目：二叉树最大深度"></a>示例题目：二叉树最大深度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">    1. 得到左子树深度, 得到右子树深度, 二者最大者加一, 就是本节点深度</span></span><br><span class="line"><span class="comment">    2. 因为需要先得到左右子树深度, 很显然是后序遍历典型应用</span></span><br><span class="line"><span class="comment">    3. 关于深度的定义：从根出发, 离根最远的节点总边数,</span></span><br><span class="line"><span class="comment">        注意: 力扣里的深度定义要多一</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        深度2         深度3         深度1</span></span><br><span class="line"><span class="comment">        1            1            1</span></span><br><span class="line"><span class="comment">       / \          / \</span></span><br><span class="line"><span class="comment">      2   3        2   3</span></span><br><span class="line"><span class="comment">                        \</span></span><br><span class="line"><span class="comment">                         4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 非力扣题目改为返回 -1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">d1</span> <span class="operator">=</span> maxDepth(node.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">d2</span> <span class="operator">=</span> maxDepth(node.right);</span><br><span class="line">    <span class="keyword">return</span> Integer.max(d1, d2) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">    1. 使用非递归后序遍历, 栈的最大高度即为最大深度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(curr);</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> stack.size();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; max) &#123;</span><br><span class="line">                max = size;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">peek</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">            <span class="keyword">if</span>(peek.right == <span class="literal">null</span> || peek.right == pop) &#123;</span><br><span class="line">                pop = stack.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr = peek.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🍁二叉搜索树"><a href="#🍁二叉搜索树" class="headerlink" title="🍁二叉搜索树"></a>🍁二叉搜索树</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>二叉搜索树（也称二叉排序树）是符合下面特征的二叉树：</p><ol><li>树节点增加 key 属性，用来比较谁大谁小，key 不可以重复</li><li>对于任意一个树节点，它的 key 比左子树的 <strong>key 都大</strong>，同时也比右子树的 <strong>key 都小</strong></li></ol></blockquote><img src="/img/41107/BST1.png" alt="BST1" style="zoom:80%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BSTNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> key; <span class="comment">// 若希望任意类型作为 key, 则后续可以将其设计为 Comparable 接口</span></span><br><span class="line">    Object value;</span><br><span class="line">    BSTNode left;</span><br><span class="line">    BSTNode right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTNode</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTNode</span><span class="params">(<span class="type">int</span> key, Object value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTNode</span><span class="params">(<span class="type">int</span> key, Object value, BSTNode left, BSTNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> doGet(root, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">doGet</span><span class="params">(BSTNode node, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 没找到</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">        <span class="keyword">return</span> doGet(node.left, key); <span class="comment">// 向左找</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.key &lt; key) &#123;</span><br><span class="line">        <span class="keyword">return</span> doGet(node.right, key); <span class="comment">// 向右找</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node.value; <span class="comment">// 找到了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归实现</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.key &lt; key) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="找最小"><a href="#找最小" class="headerlink" title="找最小"></a>找最小</h3><blockquote><p>树的最左侧即为最小值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> doMin(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">doMin</span><span class="params">(BSTNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左边已走到头</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> doMin(node.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归实现</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="comment">// 左边未走到头</span></span><br><span class="line">    <span class="keyword">while</span> (p.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        p = p.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="找最大"><a href="#找最大" class="headerlink" title="找最大"></a>找最大</h3><blockquote><p>树的最右侧即为最大值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">max</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> doMax(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">doMax</span><span class="params">(BSTNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右边已走到头</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> doMin(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归实现</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">max</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="comment">// 右边未走到头</span></span><br><span class="line">    <span class="keyword">while</span> (p.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        p = p.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新增节点"><a href="#新增节点" class="headerlink" title="新增节点"></a>新增节点</h3><blockquote><ul><li>若找到 key，更新找到节点的值</li><li>若没找到 key，创建并返回新节点</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, Object value)</span> &#123;</span><br><span class="line">    root = doPut(root, key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> BSTNode <span class="title function_">doPut</span><span class="params">(BSTNode node, <span class="type">int</span> key, Object value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BSTNode</span>(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">        node.left = doPut(node.left, key, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.key &lt; key) &#123;</span><br><span class="line">        node.right = doPut(node.right, key, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回的新节点，作为上次递归时 node 的左孩子或右孩子</span></span><br><span class="line"><span class="comment">// 缺点是，会有很多不必要的赋值操作</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, Object value)</span> &#123;</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 记住父节点</span></span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        parent = node;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.key &lt; key) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 1. key 存在则更新</span></span><br><span class="line">            node.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. key 不存在则新增</span></span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="literal">null</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">BSTNode</span>(key, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; parent.key) &#123;</span><br><span class="line">        parent.left = <span class="keyword">new</span> <span class="title class_">BSTNode</span>(key, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent.right = <span class="keyword">new</span> <span class="title class_">BSTNode</span>(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🚩前驱后继"><a href="#🚩前驱后继" class="headerlink" title="🚩前驱后继"></a>🚩前驱后继</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><blockquote><p>一个节点的前驱（前任）节点是指比它小的节点中，<strong>最大的</strong>那个</p><p>一个节点的后继（后任）节点是指比它大的节点中，<strong>最小的</strong>那个</p></blockquote><img src="/img/41107/BST2.png" alt="BST2" style="zoom:80%;" /><p>例如：</p><p>1 没有前驱，后继是 2</p><p>2 前驱是 1，后继是 3</p><p>3 前驱是 2，后继是 4</p><hr><p>高效<strong>找前驱</strong>分成 2 种情况：</p><p>节点有左子树，此时前驱节点就是左子树的最大值，图中属于这种情况的有</p><ul><li>2 的前驱是1</li><li>4 的前驱是 3</li><li>6 的前驱是 5</li><li>7 的前驱是 6</li></ul><p>节点没有左子树，若离它最近的祖先<strong>自从左而来</strong>，此祖先即为前驱，如</p><ul><li>3 的祖先 2 自左而来，前驱 2</li><li>5 的祖先 4 自左而来，前驱 4</li><li>8 的祖先 7 自左而来，前驱 7</li><li>1 没有这样的祖先，前驱 null</li></ul><p>高效<strong>找后继</strong>分成 2 种情况：</p><p>节点有右子树，此时后继节点即为右子树的最小值，如</p><ul><li>2 的后继 3</li><li>3 的后继 4</li><li>5 的后继 6</li><li>7 的后继 8</li></ul><p>节点没有右子树，若离它最近的祖先自从右而来，此祖先即为后继，如</p><ul><li>1 的祖先 2 自右而来，后继 2</li><li>4 的祖先 5 自右而来，后继 5</li><li>6 的祖先 7 自右而来，后继 7</li><li>8 没有这样的祖先，后继 null</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">predecessor</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">ancestorFromLeft</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; p.key) &#123;</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.key &lt; key) &#123;</span><br><span class="line">            ancestorFromLeft = p; <span class="comment">// 记录自从左而来的祖先</span></span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 情况1 - 有左孩子</span></span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> max(p.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 情况2 - 有祖先自左而来</span></span><br><span class="line">    <span class="keyword">return</span> ancestorFromLeft != <span class="literal">null</span> ? ancestorFromLeft.value : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">successor</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">ancestorFromRight</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; p.key) &#123;</span><br><span class="line">            ancestorFromRight = p;</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.key &lt; key) &#123;</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 情况1 - 有右孩子</span></span><br><span class="line">    <span class="keyword">if</span> (p.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> min(p.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 情况2 - 有祖先自右而来</span></span><br><span class="line">    <span class="keyword">return</span> ancestorFromRight != <span class="literal">null</span> ? ancestorFromRight.value : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="找小于目标的所有节点"><a href="#找小于目标的所有节点" class="headerlink" title="找小于目标的所有节点"></a>找小于目标的所有节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历的基本框架</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">less</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    ArrayList&lt;Object&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">    LinkedList&lt;BSTNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">BSTNode</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (pop.key &lt; key) &#123; <span class="comment">// 满足条件加入</span></span><br><span class="line">                result.add(pop.value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不满足可以直接退出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = pop.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="找大于目标的所有节点"><a href="#找大于目标的所有节点" class="headerlink" title="找大于目标的所有节点"></a>找大于目标的所有节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跟小于反之</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">greater</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    ArrayList&lt;Object&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">    LinkedList&lt;BSTNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">BSTNode</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (pop.key &gt; key) &#123;</span><br><span class="line">                result.add(pop.value);</span><br><span class="line">            &#125;</span><br><span class="line">            p = pop.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述查找较大值需要先遍历完较小值，可改造成<strong>反向中序遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">greater</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    ArrayList&lt;Object&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">    LinkedList&lt;BSTNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = p.right; <span class="comment">// 记录右边路线</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">BSTNode</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (pop.key &gt; key) &#123;</span><br><span class="line">                result.add(pop.value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = pop.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="找某个范围之间的所有节点"><a href="#找某个范围之间的所有节点" class="headerlink" title="找某个范围之间的所有节点"></a>找某个范围之间的所有节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和找小于类似</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">between</span><span class="params">(<span class="type">int</span> key1, <span class="type">int</span> key2)</span> &#123;</span><br><span class="line">    ArrayList&lt;Object&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">    LinkedList&lt;BSTNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">BSTNode</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (pop.key &gt;= key1 &amp;&amp; pop.key &lt;= key2) &#123; <span class="comment">// 多加一个判断条件</span></span><br><span class="line">                result.add(pop.value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pop.key &gt; key2) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = pop.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>优点：</p><ol><li>如果每个节点的左子树和右子树的大小差距不超过1，可以保证搜索操作的时间复杂度是 **O(log n)**，效率高。</li><li>插入、删除结点等操作也比较容易实现，效率也比较高。</li><li>对于<strong>有序数据</strong>的查询和处理，二叉查找树非常适用，可以使用中序遍历得到有序序列。</li></ol><p>缺点：</p><ol><li>如果输入的数据是有序或者近似有序的，就会出现极度不平衡的情况，可能导致搜索效率下降，时间复杂度退化成O(n)。</li><li>对于频繁地插入、删除操作，需要维护平衡二叉查找树，例如红黑树、AVL 树等，否则搜索效率也会下降。</li><li>对于存在大量重复数据的情况，需要做相应的处理，否则会导致树的深度增加，搜索效率下降。</li><li>对于结点过多的情况，由于树的空间开销较大，可能导致内存消耗过大，不适合对内存要求高的场景。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap</title>
      <link href="/posts/23369/"/>
      <url>/posts/23369/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁PUT与扩容机制"><a href="#🍁PUT与扩容机制" class="headerlink" title="🍁PUT与扩容机制"></a>🍁PUT与扩容机制</h2><img src="/img/23369/hashmap1.png" alt="hashmap1" style="zoom:80%;" /><h3 id="put-流程"><a href="#put-流程" class="headerlink" title="put 流程"></a>put 流程</h3><ol><li><p>HashMap 是懒惰创建数组的，<strong>首次使用才创建数组</strong></p></li><li><p>计算索引（桶下标）</p></li><li><p>如果桶下标还没人占用，创建Node占位返回</p></li><li><p>如果桶下标已经有人占用 </p></li><li><p>已经是 TreeNode，走红黑树的添加或更新逻辑</p></li><li><p>是普通 Node，走链表的添加或更新逻辑；如果链表长度超过树化阈值（数组总容量64，<strong>链表长度8</strong>），走树化逻辑</p></li></ol><p>​7.返回前检查容量是否超过阈值（<strong>总长度*扩容因子0.75</strong>），一旦超过进行扩容（<strong>数组*2</strong>）</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作</span></span><br><span class="line"><span class="comment">// 第五个参数 evict 这里不关心</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度</span></span><br><span class="line">    <span class="comment">// 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 数组该位置有数据</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是&quot;相等&quot;，如果是，取出这个节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果该节点是代表红黑树的节点，调用红黑树的插值方法，不展开</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 到这里，说明数组该位置上是一个链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 插入到链表的最后面(Java7 是插入到链表的最前面)</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 8 个</span></span><br><span class="line">                    <span class="comment">// 会触发下面的 treeifyBin，也就是将链表转换为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果在该链表中找到了&quot;相等&quot;的 key(== 或 equals)</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 此时 break，那么 e 为链表中[与要插入的新值的 key &quot;相等&quot;]的 node</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// e!=null 说明存在旧值的key与要插入的key&quot;相等&quot;</span></span><br><span class="line">        <span class="comment">// 对于我们分析的put操作，下面这个 if 其实就是进行 &quot;值覆盖&quot;，然后返回旧值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-与-1-8-的区别"><a href="#1-7-与-1-8-的区别" class="headerlink" title="1.7 与 1.8 的区别"></a><strong>1.7 与 1.8 的区别</strong></h3><ol><li>链表插入节点时，1.7 是<strong>头插法</strong>，1.8 是<strong>尾插法</strong> </li><li>1.7 是大于等于阈值<strong>且没有空位</strong>时才扩容，而 1.8 是大于阈值就扩容 </li><li>1.8 在扩容计算 Node 索引时，会优化</li></ol><h3 id="扩容（加载）因子为何默认是-0-75f"><a href="#扩容（加载）因子为何默认是-0-75f" class="headerlink" title="扩容（加载）因子为何默认是 0.75f"></a><strong>扩容（加载）因子为何默认是 0.75f</strong></h3><ol><li><strong>在空间占用与查询时间之间取得较好的权衡</strong></li><li>大于这个值，空间节省了，但链表就会比较长影响性能</li><li>小于这个值，冲突减少了，但扩容就会更频繁，空间占用也更多</li></ol><h2 id="🍁树化与退化"><a href="#🍁树化与退化" class="headerlink" title="🍁树化与退化"></a>🍁树化与退化</h2><h3 id="树化意义"><a href="#树化意义" class="headerlink" title="树化意义"></a><strong>树化意义</strong></h3><ul><li>红黑树用以避免Dos攻击，防止链表过长导致性能下降，<strong>树化应当是偶然情况</strong>，是保底策略</li><li>hash 表的查找、更新的时间复杂度是 **O(1)**，而红黑树的查找，更新的时间复杂度是 <strong>O(log2⁡n )<strong>，TreeNode （红黑树的情况）</strong>占用空间也比普通 Node 的大</strong>，如非必要，尽量还是使用链表</li><li>hash 值如果足够随机，则在 hash 表内按泊松分布，在<strong>负载因子 0.75</strong> 的情况下，长度超过 8 的链表出现概率是 0.00000006，<strong>树化阈值选择 8</strong> 就是为了让树化几率足够小（负载因子：当哈希表中元素数量超过 <strong>总长度*负载因子</strong> 进行扩容，<strong>扩容数组长度为原来的2倍</strong>）</li></ul><h3 id="树化规则"><a href="#树化规则" class="headerlink" title="树化规则"></a><strong>树化规则</strong></h3><ul><li>当链表长度超过<strong>树化阈值 8</strong> 时，先尝试扩容来减少链表长度，如果数组容量已经**&gt;&#x3D;64**，才会进行树化</li></ul><h3 id="退化规则"><a href="#退化规则" class="headerlink" title="退化规则"></a><strong>退化规则</strong></h3><ul><li>情况1：在扩容时或者拆分树时，树元素个数 <strong>&lt;&#x3D; 6</strong> 则会退化链表</li><li>情况2：remove 树节点时，若 root、root.left、root.right、root.left.left 有一个为 null ，也会退化为链表</li></ul><h2 id="🍁索引计算"><a href="#🍁索引计算" class="headerlink" title="🍁索引计算"></a>🍁索引计算</h2><h3 id="索引计算方法"><a href="#索引计算方法" class="headerlink" title="索引计算方法"></a><strong>索引计算方法</strong></h3><ol><li>首先，计算对象的 hashCode</li><li>再进行调用 HashMap 的 hash() 方法进行<strong>二次哈希</strong></li></ol><p>​二次 hash() 是为了综合高位数据，让哈希分布更为均匀</p><p>   3.最后 <strong>&amp; (capacity – 1)</strong> 得到索引</p><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><h4 id="Object-hashCode"><a href="#Object-hashCode" class="headerlink" title="Object.hashCode()"></a>Object.hashCode()</h4><ul><li>Object 的 hashCode 方法默认是生成随机数作为 hash 值（会缓存在对象头当中）</li><li>缺点是包含相同<strong>值</strong>的不同对象，他们的 hashCode 不一样，不能够用 hash 值来反映对象的<strong>值</strong>特征，因此诸多子类都会重写 hashCode 方法</li></ul><h4 id="String-hashCode"><a href="#String-hashCode" class="headerlink" title="String.hashCode()"></a>String.hashCode()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;bac&quot;</span>;                     </span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);         </span><br><span class="line"></span><br><span class="line">    System.out.println(s1.hashCode());</span><br><span class="line">    System.out.println(s2.hashCode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原则：值相同的字符串生成相同的 hash 码, 尽量让值不同的字符串生成不同的 hash 码</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对于 abc  a * 100 + b * 10 + c</span></span><br><span class="line"><span class="comment">    对于 bac  b * 100 + a * 10 + c</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s1.charAt(i);</span><br><span class="line">        System.out.println((<span class="type">int</span>) c);</span><br><span class="line">        <span class="comment">// (a*10 + b)*10 + c  ==&gt;  a*100 + b*10 + c  2^5</span></span><br><span class="line">        hash = (hash &lt;&lt; <span class="number">5</span>) - hash + c;</span><br><span class="line">        <span class="comment">// 经验表明如果每次乘的是较大质数，可以有更好地降低 hash 冲突，因此改【乘 10】为【乘 31】</span></span><br><span class="line"><span class="comment">// 【乘 31】可以等价为【乘 32 - hash】，进一步可以转为更高效地【左移5位 - hash】</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组容量为何是-2-的-n-次幂"><a href="#数组容量为何是-2-的-n-次幂" class="headerlink" title="数组容量为何是 2 的 n 次幂"></a><strong>数组容量为何是 2 的 n 次幂</strong></h3><ol><li>计算索引时效率更高：如果是 2 的 n 次幂可以<strong>使用位与运算代替取模</strong></li><li>扩容时重新计算索引效率更高： hash &amp; oldCap &#x3D;&#x3D; 0 的元素留在原来位置 ，否则新位置 &#x3D; 旧位置 + oldCap</li></ol><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h3><ul><li>二次 hash 是为了配合 <strong>容量是 2 的 n 次幂</strong> 这一设计前提，如果 hash 表的容量不是 2 的 n 次幂，则不必二次 hash</li><li><strong>容量是 2 的 n 次幂</strong> 这一设计计算索引效率更好，但 hash 的分散性就不好，需要二次 hash 来作为补偿，没有采用这一设计的典型例子是 HashTable</li></ul><h2 id="🍁key的设计要求"><a href="#🍁key的设计要求" class="headerlink" title="🍁key的设计要求"></a>🍁key的设计要求</h2><ol><li>HashMap 的 key <strong>可以为 null</strong>，但 Map 的其他实现则不然</li><li>作为 key 的对象，必须实现 hashCode 和 equals，并且 key 的内容<strong>不能修改</strong>（不可变）；如果 key 可变，例如修改了 对象的age属性，会导致再次查询时查询不到</li><li>key 的 hashCode 应该有良好的散列性</li></ol><h2 id="🍁HashMap实现示例"><a href="#🍁HashMap实现示例" class="headerlink" title="🍁HashMap实现示例"></a>🍁HashMap实现示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashTable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line">        <span class="type">int</span> hash; <span class="comment">// 哈希码</span></span><br><span class="line">        Object key; <span class="comment">// 键</span></span><br><span class="line">        Object value; <span class="comment">// 值</span></span><br><span class="line">        Entry next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Entry</span><span class="params">(<span class="type">int</span> hash, Object key, Object value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.hash = hash;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] table = <span class="keyword">new</span> <span class="title class_">Entry</span>[<span class="number">16</span>]; <span class="comment">// 初始容量16(2的n次幂)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 元素个数</span></span><br><span class="line">    <span class="type">float</span> <span class="variable">loadFactor</span> <span class="operator">=</span> <span class="number">0.75f</span>; <span class="comment">// 12 阈值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">threshold</span> <span class="operator">=</span> (<span class="type">int</span>) (loadFactor * table.length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 求模运算替换为位运算</span></span><br><span class="line"><span class="comment">        - 前提：数组长度是 2 的 n 次方</span></span><br><span class="line"><span class="comment">        - hash % 数组长度 等价于 hash &amp; (数组长度-1)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 hash 码获取 value</span></span><br><span class="line">    Object <span class="title function_">get</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> hash &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (table[idx] == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">p</span> <span class="operator">=</span> table[idx];</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123; <span class="comment">// 遍历链表</span></span><br><span class="line">            <span class="keyword">if</span> (p.key.equals(key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> p.value;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向 hash 表存入新 key value，如果 key 重复，则更新 value</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> hash, Object key, Object value)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> hash &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (table[idx] == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 1. idx 处有空位, 直接新增</span></span><br><span class="line">            table[idx] = <span class="keyword">new</span> <span class="title class_">Entry</span>(hash, key, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2. idx 处无空位, 沿链表查找 有重复key更新，否则新增</span></span><br><span class="line">            <span class="type">Entry</span> <span class="variable">p</span> <span class="operator">=</span> table[idx];</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.key.equals(key)) &#123;</span><br><span class="line">                    p.value = value; <span class="comment">// 更新</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p.next = <span class="keyword">new</span> <span class="title class_">Entry</span>(hash, key, value); <span class="comment">// 新增</span></span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; threshold) &#123;</span><br><span class="line">            resize();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 数组扩容2倍</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span> &#123;</span><br><span class="line">        Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[table.length &lt;&lt; <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; table.length; i++) &#123;</span><br><span class="line">            <span class="type">Entry</span> <span class="variable">p</span> <span class="operator">=</span> table[i]; <span class="comment">// 拿到每个链表头</span></span><br><span class="line">            <span class="keyword">if</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                拆分链表，移动到新数组，拆分规律（前提：数组长度为2的n次幂）</span></span><br><span class="line"><span class="comment">                * 一个链表最多拆成两个</span></span><br><span class="line"><span class="comment">                * hash &amp; table.length == 0 的一组</span></span><br><span class="line"><span class="comment">                * hash &amp; table.length != 0 的一组</span></span><br><span class="line"><span class="comment">                                          p</span></span><br><span class="line"><span class="comment">                0-&gt;8-&gt;16-&gt;24-&gt;32-&gt;40-&gt;48-&gt;null</span></span><br><span class="line"><span class="comment">                            a</span></span><br><span class="line"><span class="comment">                0-&gt;16-&gt;32-&gt;48-&gt;null</span></span><br><span class="line"><span class="comment">                        b</span></span><br><span class="line"><span class="comment">                8-&gt;24-&gt;40-&gt;null</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">                <span class="type">Entry</span> <span class="variable">a</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="type">Entry</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="type">Entry</span> <span class="variable">aHead</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="type">Entry</span> <span class="variable">bHead</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((p.hash &amp; table.length) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (a != <span class="literal">null</span>) &#123;</span><br><span class="line">                            a.next = p;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            aHead = p;</span><br><span class="line">                        &#125;</span><br><span class="line">                        a = p; <span class="comment">// 分配到a</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (b != <span class="literal">null</span>) &#123;</span><br><span class="line">                            b.next = p;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            bHead = p;</span><br><span class="line">                        &#125;</span><br><span class="line">                        b = p; <span class="comment">// 分配到b</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 规律： a 链表保持索引位置不变，b 链表索引位置+table.length</span></span><br><span class="line">                <span class="keyword">if</span> (a != <span class="literal">null</span>) &#123;</span><br><span class="line">                    a.next = <span class="literal">null</span>;</span><br><span class="line">                    newTable[i] = aHead;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (b != <span class="literal">null</span>) &#123;</span><br><span class="line">                    b.next = <span class="literal">null</span>;</span><br><span class="line">                    newTable[i + table.length] = bHead;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        table = newTable;</span><br><span class="line">        threshold = (<span class="type">int</span>) (loadFactor * table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 hash 码删除，返回删除的 value</span></span><br><span class="line">    Object <span class="title function_">remove</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> hash &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (table[idx] == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">p</span> <span class="operator">=</span> table[idx];</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.key.equals(key)) &#123;</span><br><span class="line">                <span class="comment">// 找到了, 删除</span></span><br><span class="line">                <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123; <span class="comment">// 链表头</span></span><br><span class="line">                    table[idx] = p.next;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 非链表头</span></span><br><span class="line">                    prev.next = p.next;</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">return</span> p.value;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🍁关键数"><a href="#🍁关键数" class="headerlink" title="🍁关键数"></a>🍁关键数</h2><p>扩容因子：<strong>0.75</strong></p><p>树化阈值：数组&gt;&#x3D;<strong>64</strong>,链表&gt;&#x3D;<strong>8</strong></p><p>数组扩容倍数：<strong>2</strong></p><p>数组长度最佳：<strong>2的n次幂</strong></p><h2 id="🍁HashMap操作"><a href="#🍁HashMap操作" class="headerlink" title="🍁HashMap操作"></a>🍁HashMap操作</h2><h3 id="遍历HashMap"><a href="#遍历HashMap" class="headerlink" title="遍历HashMap"></a>遍历HashMap</h3><h4 id="1-ForEach循环"><a href="#1-ForEach循环" class="headerlink" title="1.ForEach循环"></a>1.ForEach循环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterating entries using a For Each loop</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Key = &quot;</span> + entry.getKey() + <span class="string">&quot;, Value = &quot;</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-ForEach迭代键值对"><a href="#2-ForEach迭代键值对" class="headerlink" title="2.ForEach迭代键值对"></a>2.ForEach迭代键值对</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代键</span></span><br><span class="line">    <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Key = &quot;</span> + key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代值</span></span><br><span class="line">    <span class="keyword">for</span> (Integer value : map.values()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Value = &quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-带泛型的迭代器"><a href="#3-带泛型的迭代器" class="headerlink" title="3.带泛型的迭代器"></a>3.带泛型的迭代器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (entries.hasNext()) &#123;</span><br><span class="line">        Map.Entry&lt;Integer, Integer&gt; entry = entries.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;Key = &quot;</span> + entry.getKey() + <span class="string">&quot;, Value = &quot;</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-不带泛型的迭代器"><a href="#4-不带泛型的迭代器" class="headerlink" title="4.不带泛型的迭代器"></a>4.不带泛型的迭代器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    Iterator&lt;Map.Entry&gt; entries = map.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (entries.hasNext()) &#123;</span><br><span class="line">        Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) entries.next();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> (Integer) entry.getKey();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> (Integer) entry.getValue();</span><br><span class="line">        System.out.println(<span class="string">&quot;Key = &quot;</span> + key + <span class="string">&quot;, Value = &quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-Java8-Lambda表达式"><a href="#5-Java8-Lambda表达式" class="headerlink" title="5.Java8 Lambda表达式"></a>5.Java8 Lambda表达式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line">    map.forEach((k, v) -&gt; System.out.println(<span class="string">&quot;key: &quot;</span> + k + <span class="string">&quot; value:&quot;</span> + v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排序HashMap"><a href="#排序HashMap" class="headerlink" title="排序HashMap"></a>排序HashMap</h3><h4 id="1-使用TreeMap"><a href="#1-使用TreeMap" class="headerlink" title="1.使用TreeMap"></a>1.使用TreeMap</h4><blockquote><p>实现TreeMap的默认逻辑是有序的，插入到TreeMap的数据会按照Key排序</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;String, Integer&gt; sorted = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(map);</span><br><span class="line">System.out.println(sorted);</span><br></pre></td></tr></table></figure><h4 id="2-使用TreeSet"><a href="#2-使用TreeSet" class="headerlink" title="2.使用TreeSet"></a>2.使用TreeSet</h4><blockquote><p>去重功能</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SortedSet&lt;Integer&gt;  valueSorted = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(map.values());</span><br><span class="line">或者</span><br><span class="line">SortedSet&lt;String&gt; keySorted = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(map.keySet());</span><br></pre></td></tr></table></figure><h4 id="3-使用ArrayList"><a href="#3-使用ArrayList" class="headerlink" title="3.使用ArrayList"></a>3.使用ArrayList</h4><blockquote><p>ArrayList只能按照Key或者Value排序，仅排序key或者value</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; sorted = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.keySet());</span><br><span class="line">Collections.sort(sorted);</span><br><span class="line"> </span><br><span class="line">List&lt;String&gt; sorted = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.values());</span><br><span class="line">Collections.sort(sorted);</span><br></pre></td></tr></table></figure><h4 id="4-使用Lambdas和Streams"><a href="#4-使用Lambdas和Streams" class="headerlink" title="4.使用Lambdas和Streams"></a>4.使用Lambdas和Streams</h4><h5 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">     </span><br><span class="line">    Student(Integer id, String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[id=&quot;</span>+id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HashMap&lt;Integer, Student&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">map.put(<span class="number">1003</span>, <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1003</span>, <span class="string">&quot;Sam&quot;</span>));</span><br><span class="line">map.put(<span class="number">1005</span>, <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1005</span>, <span class="string">&quot;Joseph&quot;</span>));</span><br><span class="line">map.put(<span class="number">1001</span>, <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1001</span>, <span class="string">&quot;Kate&quot;</span>));</span><br><span class="line">map.put(<span class="number">1002</span>, <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1002</span>, <span class="string">&quot;Miranda&quot;</span>));</span><br><span class="line">map.put(<span class="number">1004</span>, <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1004</span>, <span class="string">&quot;Peter&quot;</span>));</span><br></pre></td></tr></table></figure><h5 id="根据key排序"><a href="#根据key排序" class="headerlink" title="根据key排序"></a>根据key排序</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Student&gt; sortedMap = map.entrySet()</span><br><span class="line">                                  .stream()</span><br><span class="line">                                  .sorted(Map.Entry.comparingByKey())</span><br><span class="line">                                  .collect(Collectors</span><br><span class="line">                                    .toMap(Map.Entry::getKey,</span><br><span class="line">                                           Map.Entry::getValue,</span><br><span class="line">                                           (e1, e2) -&gt; e1,</span><br><span class="line">                                           LinkedHashMap::<span class="keyword">new</span>))</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123;<span class="number">1001</span>=[id=<span class="number">1001</span>, name=Kate], <span class="number">1002</span>=[id=<span class="number">1002</span>, name=Miranda], <span class="number">1003</span>=[id=<span class="number">1003</span>, name=Sam], <span class="number">1004</span>=[id=<span class="number">1004</span>, name=Peter], <span class="number">1005</span>=[id=<span class="number">1005</span>, name=Joseph]&#125;</span><br></pre></td></tr></table></figure><h5 id="根据value排序"><a href="#根据value排序" class="headerlink" title="根据value排序"></a>根据value排序</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Student&gt; sortedMap = map.entrySet()</span><br><span class="line">              .stream()</span><br><span class="line">              .sorted(Map.Entry.comparingByValue())</span><br><span class="line">               .collect(Collectors</span><br><span class="line">                          .toMap(Map.Entry::getKey,</span><br><span class="line">                                 Map.Entry::getValue,</span><br><span class="line">                                 (e1, e2) -&gt; e1,</span><br><span class="line">                                 LinkedHashMap::<span class="keyword">new</span>));</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123;<span class="number">1005</span>=[id=<span class="number">1005</span>, name=Joseph], <span class="number">1001</span>=[id=<span class="number">1001</span>, name=Kate], <span class="number">1002</span>=[id=<span class="number">1002</span>, name=Miranda], <span class="number">1004</span>=[id=<span class="number">1004</span>, name=Peter], <span class="number">1003</span>=[id=<span class="number">1003</span>, name=Sam]&#125;</span><br></pre></td></tr></table></figure><p>此时对象需要实现比较器接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Student(Integer id, String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[id=&quot;</span>+id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name.compareTo(o.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="逆序"><a href="#逆序" class="headerlink" title="逆序"></a>逆序</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Student&gt; sortedMap = map.entrySet()</span><br><span class="line">              .stream()</span><br><span class="line">              .sorted(Collections.reverseOrder(Map.Entry.comparingByKey()))</span><br><span class="line">               .collect(Collectors</span><br><span class="line">                          .toMap(Map.Entry::getKey,</span><br><span class="line">                                 Map.Entry::getValue,</span><br><span class="line">                                 (e1, e2) -&gt; e1,</span><br><span class="line">                                 LinkedHashMap::<span class="keyword">new</span>));</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123;<span class="number">1005</span>=[id=<span class="number">1005</span>, name=Joseph], <span class="number">1004</span>=[id=<span class="number">1004</span>, name=Peter], <span class="number">1003</span>=[id=<span class="number">1003</span>, name=Sam], <span class="number">1002</span>=[id=<span class="number">1002</span>, name=Miranda], <span class="number">1001</span>=[id=<span class="number">1001</span>, name=Kate]&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>List</title>
      <link href="/posts/51030/"/>
      <url>/posts/51030/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁ArrayList"><a href="#🍁ArrayList" class="headerlink" title="🍁ArrayList"></a>🍁ArrayList</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>ArrayList是基于动态数组实现，可以<strong>随机</strong>访问</p><h3 id="易混方法"><a href="#易混方法" class="headerlink" title="易混方法"></a>易混方法</h3><h4 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h4><blockquote><p>返回数组中的元素个数，注意区别数组的length和String的length()</p></blockquote><p>常用于迭代元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; sites = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">sites.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">sites.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">sites.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">sites.add(<span class="string">&quot;Weibo&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sites.size(); i++) &#123;</span><br><span class="line">System.out.println(sites.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>Collections 类提供的 sort() 方法可以对字符或数字列表进行排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; sites = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">sites.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">sites.add(<span class="string">&quot;Wiki&quot;</span>);</span><br><span class="line">sites.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">sites.add(<span class="string">&quot;Weibo&quot;</span>);</span><br><span class="line">sites.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">Collections.sort(sites);  <span class="comment">// 字母排序</span></span><br><span class="line"><span class="keyword">for</span> (String i : sites) &#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Google</span><br><span class="line">Runoob</span><br><span class="line">Taobao</span><br><span class="line">Weibo</span><br><span class="line">Wiki</span><br></pre></td></tr></table></figure><h3 id="🚩扩容机制"><a href="#🚩扩容机制" class="headerlink" title="🚩扩容机制"></a>🚩扩容机制</h3><ol><li>ArrayList() 会使用<strong>长度为零</strong>的数组 </li><li>ArrayList(int initialCapacity) 会使用指定容量的数组 </li><li>public ArrayList(Collection&lt;? extends E&gt; c) 会使用 c 的大小作为数组容量 </li><li><strong>add(Object o)首次扩容为10，再次扩容为上次容量的1.5倍</strong></li><li>addAll(Collection c)没有元素时，扩容为Math.max(10,实际元素个数)，有元素时为Math.max(原容量1.5倍,实际元素个数)</li></ol><h2 id="🍁LinkedList"><a href="#🍁LinkedList" class="headerlink" title="🍁LinkedList"></a>🍁LinkedList</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>基于<strong>双向链表</strong>实现，只能<strong>顺序访问</strong>，可以快速地在链表中间插入和删除元素。LinkedList 还可以用作<strong>栈、队列和双向队列</strong>.</p><h3 id="易混方法-1"><a href="#易混方法-1" class="headerlink" title="易混方法"></a>易混方法</h3><h4 id="getFirst-getLast"><a href="#getFirst-getLast" class="headerlink" title="getFirst(), getLast()"></a>getFirst(), getLast()</h4><p>获取第一个元素和获取最后一个元素</p><h4 id="removeFirst-removeLast-remove-e-remove-index"><a href="#removeFirst-removeLast-remove-e-remove-index" class="headerlink" title="removeFirst(), removeLast(), remove(e), remove(index)"></a>removeFirst(), removeLast(), remove(e), remove(index)</h4><p>删除系列方法</p><h3 id="🚩区别ArrayList"><a href="#🚩区别ArrayList" class="headerlink" title="🚩区别ArrayList"></a>🚩区别ArrayList</h3><table><thead><tr><th></th><th align="center">ArrayList</th><th align="center">LinkedList</th></tr></thead><tbody><tr><td>结构</td><td align="center">动态数组</td><td align="center">双向链表</td></tr><tr><td>访问</td><td align="center">随机访问</td><td align="center">顺序访问</td></tr><tr><td>插入删除</td><td align="center">一般性能低</td><td align="center">一般性能高</td></tr><tr><td>内存占用</td><td align="center">低</td><td align="center">高</td></tr><tr><td>适用情况</td><td align="center">频繁访问列表中的某一个元素，只需要在列表末尾进行添加和删除元素操作</td><td align="center">需要通过循环迭代来访问列表中的某些元素，需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作</td></tr></tbody></table><h2 id="🍁链表扩展"><a href="#🍁链表扩展" class="headerlink" title="🍁链表扩展"></a>🍁链表扩展</h2><h3 id="单向链表（带哨兵）实现"><a href="#单向链表（带哨兵）实现" class="headerlink" title="单向链表（带哨兵）实现"></a>单向链表（带哨兵）实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedListSentinel</span> &#123;</span><br><span class="line">    <span class="comment">// 哨兵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Integer.MIN_VALUE, <span class="literal">null</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据索引获取节点</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">findNode</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="built_in">this</span>.head; curr != <span class="literal">null</span>; curr = curr.next, i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == index) &#123;</span><br><span class="line">                <span class="keyword">return</span> curr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取最后一个节点</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">findLast</span><span class="params">()</span> &#123;</span><br><span class="line">        Node curr;</span><br><span class="line">        <span class="keyword">for</span> (curr = <span class="built_in">this</span>.head; curr.next != <span class="literal">null</span>; ) &#123;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加入到最后</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">last</span> <span class="operator">=</span> findLast();</span><br><span class="line">        last.next = <span class="keyword">new</span> <span class="title class_">Node</span>(value, <span class="literal">null</span>); <span class="comment">// 最后一个节点指向新节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入到索引</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">// index 传入 0 时，返回的是哨兵</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> findNode(index - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span>) &#123;</span><br><span class="line">            prev.next = <span class="keyword">new</span> <span class="title class_">Node</span>(value, prev.next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> illegalIndex(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据索引删除</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">// index 传入 0 时，返回的是哨兵</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> findNode(index - <span class="number">1</span>);</span><br><span class="line">        Node curr;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span> &amp;&amp; (curr = prev.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            prev.next = curr.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> illegalIndex(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加入到头部</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.head.next = <span class="keyword">new</span> <span class="title class_">Node</span>(value, <span class="built_in">this</span>.head.next);</span><br><span class="line">        <span class="comment">// 也可以视为 insert 的特例, 即 insert(0, value);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双向链表（带哨兵）实现"><a href="#双向链表（带哨兵）实现" class="headerlink" title="双向链表（带哨兵）实现"></a>双向链表（带哨兵）实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoublyLinkedListSentinel</span> <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;Integer&gt; &#123;</span><br><span class="line"><span class="comment">// 默认带有一个头节点和一个尾节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node tail;</span><br><span class="line"><span class="comment">// 构造方法：头尾互相指向</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoublyLinkedListSentinel</span><span class="params">()</span> &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, <span class="number">666</span>, <span class="literal">null</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, <span class="number">888</span>, <span class="literal">null</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 根据索引查找节点</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">findNode</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> head; p != tail; p = p.next, i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == index) &#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 加到头部</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        insert(<span class="number">0</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 删除头部</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 加到尾部（尾节点之前）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">added</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(prev, value, tail);</span><br><span class="line">        prev.next = added;</span><br><span class="line">        tail.prev = added;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 删除尾部</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">removed</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        <span class="keyword">if</span> (removed == head) &#123;</span><br><span class="line">            <span class="keyword">throw</span> illegalIndex(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> removed.prev;</span><br><span class="line">        prev.next = tail;</span><br><span class="line">        tail.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 插入到指定位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> findNode(index - <span class="number">1</span>); <span class="comment">// 查找到前节点</span></span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> illegalIndex(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> prev.next;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">inserted</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(prev, value, next);</span><br><span class="line">        prev.next = inserted;</span><br><span class="line">        next.prev = inserted;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 删除指定索引节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> findNode(index - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> illegalIndex(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">removed</span> <span class="operator">=</span> prev.next;</span><br><span class="line">        <span class="keyword">if</span> (removed == tail) &#123;</span><br><span class="line">            <span class="keyword">throw</span> illegalIndex(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> removed.next;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IllegalArgumentException <span class="title function_">illegalIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                String.format(<span class="string">&quot;index [%d] 不合法%n&quot;</span>, index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写迭代器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> head.next;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> p != tail;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> p.value;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 内部节点类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        Node prev; <span class="comment">// 前指针</span></span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        Node next; <span class="comment">// 后指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Node prev, <span class="type">int</span> value, Node next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.prev = prev;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单向环形链表（带哨兵）实现队列"><a href="#单向环形链表（带哨兵）实现队列" class="headerlink" title="单向环形链表（带哨兵）实现队列"></a>单向环形链表（带哨兵）实现队列</h3><p>初始时：</p><img src="/img/51030/listByLink1.png" alt="链表实现队列1" style="zoom:80%;" /><p>插入示例：</p><img src="/img/51030/listByLink2.png" alt="链表实现队列2" style="zoom:80%;" /><img src="/img/51030/listByLink3.png" alt="链表实现队列3" style="zoom:80%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListQueue</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Queue</span>&lt;E&gt;, Iterable&lt;E&gt; &#123;</span><br><span class="line"><span class="comment">// 内部节点类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E value;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(E value, Node&lt;E&gt; next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>, <span class="literal">null</span>); <span class="comment">// 头指针指向哨兵</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; tail = head; <span class="comment">// 尾指针指向最后一个</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> Integer.MAX_VALUE; <span class="comment">// 容量</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        tail.next = head; <span class="comment">// 初始尾循环指向头</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedListQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedListQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 队列尾部加入节点（入队）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;E&gt; added = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(value, head);</span><br><span class="line">        tail.next = added;</span><br><span class="line">        tail = added; <span class="comment">// 尾指针始终指向最后一个</span></span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 队列头部删除节点（出队）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;E&gt; first = head.next;</span><br><span class="line">        head.next = first.next;</span><br><span class="line">        <span class="keyword">if</span> (first == tail) &#123;</span><br><span class="line">            tail = head;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> first.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回队头</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next.value;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 判空</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head == tail;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 判满</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size == capacity;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 重写迭代</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;E&gt;() &#123;</span><br><span class="line">            Node&lt;E&gt; p = head.next; <span class="comment">// 初始在真实的第一个节点</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> p != head;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">E</span> <span class="variable">value</span> <span class="operator">=</span> p.value;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表（带哨兵）实现栈"><a href="#链表（带哨兵）实现栈" class="headerlink" title="链表（带哨兵）实现栈"></a>链表（带哨兵）实现栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListStack</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Stack</span>&lt;E&gt;, Iterable&lt;E&gt; &#123;</span><br><span class="line"><span class="comment">// 出入栈仅在链表头操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;E&gt; head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>, <span class="literal">null</span>); <span class="comment">// 哨兵</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedListStack</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 入栈，插入链表头</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">push</span><span class="params">(E value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(value, head.next);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 出栈，删除链表头</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;E&gt; first = head.next;</span><br><span class="line">        head.next = first.next;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> first.value;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 返回链表头的值</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head.next == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size == capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;E&gt;() &#123;</span><br><span class="line">            Node&lt;E&gt; p = head.next;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> p != <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">E</span> <span class="variable">value</span> <span class="operator">=</span> p.value;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 内部节点类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E value;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(E value, Node&lt;E&gt; next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="环形链表（带哨兵）实现双端队列"><a href="#环形链表（带哨兵）实现双端队列" class="headerlink" title="环形链表（带哨兵）实现双端队列"></a>环形链表（带哨兵）实现双端队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关键点：找到待操作节点在链表中的前后节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListDeque</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Deque</span>&lt;E&gt;, Iterable&lt;E&gt; &#123;</span><br><span class="line"><span class="comment">// 加入头部（哨兵的后一个节点）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offerFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        Node&lt;E&gt; a = sentinel; <span class="comment">// 前</span></span><br><span class="line">        Node&lt;E&gt; b = sentinel.next; <span class="comment">// 后</span></span><br><span class="line">        Node&lt;E&gt; offered = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(a, e, b);</span><br><span class="line">        a.next = offered;</span><br><span class="line">        b.prev = offered;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 加入尾部（哨兵的前一个节点）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offerLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        Node&lt;E&gt; a = sentinel.prev; <span class="comment">// 前</span></span><br><span class="line">        Node&lt;E&gt; b = sentinel; <span class="comment">// 后</span></span><br><span class="line">        Node&lt;E&gt; offered = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(a, e, b);</span><br><span class="line">        a.next = offered;</span><br><span class="line">        b.prev = offered;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 删除头</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pollFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;E&gt; a = sentinel; <span class="comment">// 前</span></span><br><span class="line">        Node&lt;E&gt; polled = sentinel.next;</span><br><span class="line">        Node&lt;E&gt; b = polled.next; <span class="comment">// 后</span></span><br><span class="line">        a.next = b;</span><br><span class="line">        b.prev = a;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> polled.value;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 删除尾</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pollLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;E&gt; polled = sentinel.prev;</span><br><span class="line">        Node&lt;E&gt; a = polled.prev; <span class="comment">// 前</span></span><br><span class="line">        Node&lt;E&gt; b = sentinel; <span class="comment">// 后</span></span><br><span class="line">        a.next = b;</span><br><span class="line">        b.prev = a;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> polled.value;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 返回头（哨兵的后一个）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peekFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sentinel.next.value;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 返回尾（哨兵的前一个）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peekLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sentinel.prev.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size == capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;E&gt;() &#123;</span><br><span class="line">            Node&lt;E&gt; p = sentinel.next;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> p != sentinel;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">E</span> <span class="variable">value</span> <span class="operator">=</span> p.value;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 内部节点类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line">        E value;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Node&lt;E&gt; prev, E value, Node&lt;E&gt; next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.prev = prev;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; sentinel = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedListDeque</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        sentinel.next = sentinel;</span><br><span class="line">        sentinel.prev = sentinel;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GC回收策略与GC器</title>
      <link href="/posts/46450/"/>
      <url>/posts/46450/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁回收策略"><a href="#🍁回收策略" class="headerlink" title="🍁回收策略"></a>🍁回收策略</h2><p>根据 GC 的规模可以分成 <strong>Minor GC</strong>，<strong>Major GC</strong>，<strong>Mixed GC</strong>，<strong>Full GC</strong></p><p>Minor GC（Young GC）:只是新生代的垃圾收集，暂停时间短</p><p>Major GC（Old GC）:只是老年代的垃圾收集，只有 CMS收集器 会有</p><p>Mixed GC：新生代 + 老年代部分区域的垃圾回收，<strong>G1收集器</strong>特有</p><p>Full GC：新生代 + 老年代<strong>完整</strong>垃圾回收，暂停时间长，<strong>应尽力避免</strong></p><h2 id="🍁垃圾收集器"><a href="#🍁垃圾收集器" class="headerlink" title="🍁垃圾收集器"></a>🍁垃圾收集器</h2><h3 id="Parallel-GC"><a href="#Parallel-GC" class="headerlink" title="Parallel GC"></a>Parallel GC</h3><ul><li>eden 内存不足发生 Minor GC，采用标记复制算法，需要暂停用户线程 </li><li>old 内存不足发生 Full GC，采用标记整理算法，需要暂停用户线程 </li><li><strong>注重吞吐量</strong></li></ul><h3 id="ConcurrentMarkSweep-GC"><a href="#ConcurrentMarkSweep-GC" class="headerlink" title="ConcurrentMarkSweep GC"></a>ConcurrentMarkSweep GC</h3><ul><li><p>它是工作在 old 老年代，支持<strong>并发标记</strong>的一款回收器，采用<strong>并发清除</strong>算法 </p></li><li><ul><li>并发标记时不需暂停用户线程</li><li>重新标记时仍需暂停用户线程</li></ul></li><li><p>如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC </p></li><li><p><strong>注重响应时间</strong></p></li></ul><h3 id="🚩G1-GC"><a href="#🚩G1-GC" class="headerlink" title="🚩G1 GC"></a>🚩G1 GC</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul><li><strong>响应时间与吞吐量兼顾</strong></li><li>划分成多个区域，每个区域都可以充当 eden，survivor，old， humongous，其中 humongous 专为大对象准备</li><li>分成三个阶段：新生代回收、并发标记、混合收集</li><li>如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC</li></ul><h4 id="回收阶段：新生代回收"><a href="#回收阶段：新生代回收" class="headerlink" title="回收阶段：新生代回收"></a>回收阶段：新生代回收</h4><p>1.初始时，所有区域都处于空闲状态</p><img src="/img/46450/G1-1.png" alt="G1-1" style="zoom: 67%;" /><p>2.创建了一些对象，挑出一些空闲区域作为伊甸园区存储这些对象</p><img src="/img/46450/G1-2.png" alt="G1-2" style="zoom: 67%;" /><p>3.当伊甸园需要垃圾回收时，挑出一个空闲区域作为幸存区，用<strong>复制算法</strong>复制存活对象，需要<strong>暂停用户线程</strong></p><img src="/img/46450/G1-3.png" alt="G1-3" style="zoom:67%;" /><p>4.复制完成，将之前的伊甸园内存释放</p><img src="/img/46450/G1-4.png" alt="G1-4" style="zoom:67%;" /><p>5.随着时间流逝，伊甸园的内存又有不足</p><img src="/img/46450/G1-5.png" alt="G1-5" style="zoom:67%;" /><p>6.将伊甸园以及之前幸存区中的存活对象，采用<strong>复制算法</strong>，复制到新的幸存区，其中较老对象晋升至<strong>老年代</strong></p><img src="/img/46450/G1-6.png" alt="G1-6" style="zoom:67%;" /><p>7.释放伊甸园以及之前幸存区的内存</p><img src="/img/46450/G1-7.png" alt="G1-7" style="zoom:67%;" /><h4 id="回收阶段：并发标记与混合收集"><a href="#回收阶段：并发标记与混合收集" class="headerlink" title="回收阶段：并发标记与混合收集"></a>回收阶段：并发标记与混合收集</h4><p>1.当老年代占用内存超过阈值后，触发并发标记，这时<strong>无需暂停用户线程</strong></p><img src="/img/46450/G1-8.png" alt="G1-8" style="zoom:67%;" /><p>2.并发标记之后，会有重新标记阶段解决漏标问题，此时需要<strong>暂停用户线程</strong>。这些都完成后就知道老年代有哪些存活对象，随后进入混合收集阶段。此时不会对所有老年代区域进行回收，而是根据<strong>暂停时间目标优先回收价值高</strong>（存活对象少）的区域（这也是 Gabage First 名称的由来）。</p><img src="/img/46450/G1-9.png" alt="G1-9" style="zoom:67%;" /><p>3.混合收集阶段中，参与复制的有 eden、survivor、old，下图显示了伊甸园和幸存区的存活对象复制</p><img src="/img/46450/G1-10.png" alt="G1-10" style="zoom:67%;" /><p>4.老年代和幸存区晋升的存活对象的复制</p><img src="/img/46450/G1-11.png" alt="G1-11" style="zoom:67%;" /><p>5.复制完成，内存得到释放。进入下一轮的新生代回收、并发标记、混合收集</p><img src="/img/46450/G1-12.png" alt="G1-12" style="zoom:67%;" />]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GC回收算法</title>
      <link href="/posts/64310/"/>
      <url>/posts/64310/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁标记清除法"><a href="#🍁标记清除法" class="headerlink" title="🍁标记清除法"></a>🍁标记清除法</h2><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ol><li>找到 GC Root 对象，即那些<strong>一定不会被回收的对象</strong>，如正执行方法内局部变量引用的对象、静态变量引用的对象</li><li>标记阶段：沿着 GC Root 对象的引用链找，直接或间接引用到的对象加上标记</li><li>清除阶段：释放<strong>未加标记</strong>的对象占用的内存</li></ol><img src="/img/64310/GC1.png" alt="GC1" style="zoom:80%;" /><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul><li>标记速度与存活对象成线性关系</li><li>清除速度与内存大小成线性关系</li><li>缺点是会产生<strong>内存碎片</strong></li></ul><h2 id="🍁标记整理法"><a href="#🍁标记整理法" class="headerlink" title="🍁标记整理法"></a>🍁标记整理法</h2><h4 id="步骤：-1"><a href="#步骤：-1" class="headerlink" title="步骤："></a>步骤：</h4><ol><li>前面的标记阶段、清理阶段与标记清除法类似</li><li>多了一步<strong>整理</strong>的动作，将存活对象向一端移动，可以<strong>避免内存碎片</strong>产生</li></ol><img src="/img/64310/GC2.png" alt="GC2" style="zoom:80%;" /><h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h4><ul><li>标记速度与存活对象成线性关系 </li><li>清除与整理速度与内存大小成线性关系 </li><li>缺点是性能上<strong>较慢</strong></li></ul><h2 id="🍁标记复制法"><a href="#🍁标记复制法" class="headerlink" title="🍁标记复制法"></a>🍁标记复制法</h2><h4 id="步骤：-2"><a href="#步骤：-2" class="headerlink" title="步骤："></a>步骤：</h4><ol><li>将整个内存分成两个大小相等的区域，from 和 to，其中 <strong>to 总是处于空闲</strong>，<strong>from 存储新创建的对象</strong></li><li>标记阶段与前面的算法类似</li><li>在找出存活对象后，会将它们从 from 复制到 to 区域，复制的过程中自然完成了碎片整理</li><li>复制完成后，<strong>交换</strong> from 和 to 的位置即可</li></ol><img src="/img/64310/GC3.png" alt="GC3" style="zoom:80%;" /><h4 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h4><ul><li>标记与复制速度与存活对象成线性关系</li><li>缺点是会占用成倍的空间</li></ul><h2 id="🍁分代回收思想"><a href="#🍁分代回收思想" class="headerlink" title="🍁分代回收思想"></a>🍁分代回收思想</h2><blockquote><p>根据对象存活周期将内存划分为几块，不同块采用适当的收集算法</p><ul><li>新生代使用: 标记复制法</li><li>老年代使用: 标记清除法 或者 标记整理法</li></ul></blockquote><p>1.伊甸园eden，最初对象都分配到这里，与幸存区 survivor（分成 from 和 to）合称新生代</p><img src="/img/64310/分代1.png" alt="分代1" style="zoom:80%;" /><p>2.当伊甸园内存不足，标记伊甸园与 from（现阶段没有）的存活对象（这里为6）</p><img src="/img/64310/分代2.png" alt="分代2" style="zoom:80%;" /><p>3.将存活对象采用复制算法复制到 to 中，复制完毕后，伊甸园和 from 内存都得到释放</p><img src="/img/64310/分代3.png" alt="分代3" style="zoom:80%;" /><p>4.将 from 和 to 交换位置</p><img src="/img/64310/分代4.png" alt="分代4" style="zoom:80%;" /><p>5.经过一段时间后伊甸园的内存又出现不足</p><img src="/img/64310/分代5.png" alt="分代5" style="zoom:80%;" /><p>6.标记伊甸园与 from中的存活对象</p><img src="/img/64310/分代6.png" alt="分代6" style="zoom:80%;" /><p>7.将存活对象采用复制算法复制到 to 中</p><img src="/img/64310/分代7.png" alt="分代7" style="zoom:80%;" /><p>8.复制完毕后，伊甸园和 from 内存都得到释放</p><img src="/img/64310/分代8.png" alt="分代8" style="zoom:80%;" /><p>9.将 from 和 to 交换位置（保证to区为空）</p><img src="/img/64310/分代9.png" alt="分代9" style="zoom:80%;" /><p>10.老年代 old，当幸存区对象熬过几次回收（最多<strong>15</strong>次），晋升到老年代（幸存区内存不足或大对象会导致提前晋升）</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java引用类型</title>
      <link href="/posts/40363/"/>
      <url>/posts/40363/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁强引用"><a href="#🍁强引用" class="headerlink" title="🍁强引用"></a>🍁强引用</h2><blockquote><p>普通变量赋值即为强引用，如 A a &#x3D; new A();</p></blockquote><p>通过 GC Root 的引用链，如果强引用不到该对象，该对象才能被回收</p><img src="/img/40363/GC引用1.png" alt="GC引用1" style="zoom: 80%;" /><p>🎈<strong>GC Root</strong></p><ul><li>虚拟机栈中引用的对象</li><li>本地方法栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中的常量引用的对象</li></ul><h2 id="🍁软引用（SoftReference）"><a href="#🍁软引用（SoftReference）" class="headerlink" title="🍁软引用（SoftReference）"></a>🍁软引用（SoftReference）</h2><blockquote><p>使用 SoftReference 类来创建软引用，SoftReference a &#x3D; new SoftReference(new A());</p></blockquote><ul><li>如果仅有软引用该对象时，<strong>首次</strong>垃圾回收不会回收该对象，如果<strong>内存仍不足</strong>，再次回收时才会释放对象 </li><li>软引用自身需要配合<strong>引用队列</strong>来释放 </li><li>典型例子是反射数据</li></ul><img src="/img/40363/GC引用2.png" alt="GC引用2" style="zoom:80%;" /><h2 id="🍁弱引用（WeakReference）"><a href="#🍁弱引用（WeakReference）" class="headerlink" title="🍁弱引用（WeakReference）"></a>🍁弱引用（<strong>WeakReference</strong>）</h2><blockquote><p>使用 WeakReference 类来实现弱引用，WeakReference a &#x3D; new WeakReference(new A());</p></blockquote><ul><li>如果仅有弱引用引用该对象时，<strong>只要发生</strong>垃圾回收，<strong>就会释放</strong>该对象，也就是说它只能存活到下一次垃圾回收发生之前</li><li>弱引用自身需要配合<strong>引用队列</strong>来释放</li><li>典型例子是 ThreadLocalMap 中的 <strong>Entry</strong> 对象</li></ul><img src="/img/40363/GC引用3.png" alt="GC引用3" style="zoom:80%;" /><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestWeakReference</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyWeakMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyWeakMap</span>();</span><br><span class="line">        map.put(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>), <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;c&quot;</span>), <span class="string">&quot;3&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;d&quot;</span>), <span class="string">&quot;4&quot;</span>);</span><br><span class="line">        System.out.println(map);<span class="comment">// 输出:[a:1,b:2,c:3,d:4]</span></span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;c&quot;</span>));</span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;d&quot;</span>));</span><br><span class="line">        System.out.println(map);<span class="comment">// 输出:[null:1,null:2,null:3,null:4]</span></span><br><span class="line">        map.clean();</span><br><span class="line">        System.out.println(map); <span class="comment">// 输出:[b:2]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 模拟 ThreadLocalMap 的内存泄漏问题以及一种解决方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyWeakMap</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;String&gt; &#123;</span><br><span class="line">            String value;</span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">Entry</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>(key, queue); <span class="comment">// key为弱引用</span></span><br><span class="line">                <span class="built_in">this</span>.value = value; <span class="comment">// value为强引用</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;</span><br><span class="line">            Object ref;</span><br><span class="line">            <span class="keyword">while</span> ((ref = queue.poll()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(ref);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; table.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(table[i] == ref) &#123;</span><br><span class="line">                        table[i] = <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Entry[] table = <span class="keyword">new</span> <span class="title class_">Entry</span>[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> index, String key, String value)</span> &#123;</span><br><span class="line">            table[index] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Entry entry : table) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">k</span> <span class="operator">=</span> entry.get();</span><br><span class="line">                    <span class="keyword">if</span> (k != <span class="literal">null</span> &amp;&amp; k.equals(key)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> entry.value;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            sb.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Entry entry : table) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">k</span> <span class="operator">=</span> entry.get();</span><br><span class="line">                    sb.append(k).append(<span class="string">&quot;:&quot;</span>).append(entry.value).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sb.length() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🍁虚引用（PhantomReference）"><a href="#🍁虚引用（PhantomReference）" class="headerlink" title="🍁虚引用（PhantomReference）"></a>🍁虚引用（<strong>PhantomReference</strong>）</h2><blockquote><p>使用PhantomReference类实现虚引用，PhantomReference a &#x3D; new PhantomReference(new A(), referenceQueue);</p></blockquote><ul><li>必须<strong>配合引用队列</strong>一起使用，当虚引用所引用的对象被回收时，由 Reference Handler 线程将虚引用对象入队，这样就可以知道哪些对象被回收，从而对它们关联的资源做进一步处理</li><li>无法通过虚引用取得一个对象</li><li>为一个对象设置虚引用关联的唯一目的就是能在这个对象被<strong>回收时收到一个系统通知</strong></li><li>典型例子是 Cleaner 释放 DirectByteBuffer 关联的直接内存</li></ul><img src="/img/40363/GC引用4.png" alt="GC引用4" style="zoom:80%;" /><hr><p> <strong>总结</strong>：强-无法收，弱-碰就收，软-二次收，虚-通知收</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GC判断无用对象</title>
      <link href="/posts/26437/"/>
      <url>/posts/26437/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁概述"><a href="#🍁概述" class="headerlink" title="🍁概述"></a>🍁概述</h2><blockquote><p>垃圾回收（Garbage Collection），目的在于实现无用对象内存自动释放，减少内存碎片、加快分配速度</p></blockquote><ul><li>回收区域是<strong>堆内存</strong>，不包括虚拟机栈</li><li>判断无用对象，使用<strong>可达性分析算法</strong>，<strong>三色标记法</strong>标记存活对象，回收未标记对象</li><li>GC 具体的实现称为<strong>垃圾回收器</strong></li><li>GC 大都采用了<strong>分代回收思想</strong></li></ul><h2 id="🍁判断无用对象"><a href="#🍁判断无用对象" class="headerlink" title="🍁判断无用对象"></a>🍁判断无用对象</h2><h3 id="1-可达性分析算法"><a href="#1-可达性分析算法" class="headerlink" title="1.可达性分析算法"></a>1.可达性分析算法</h3><blockquote><p>通过 <strong>GC Roots</strong> 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收</p></blockquote><p>GC Roots 一般包含以下内容：</p><ul><li>虚拟机栈中引用的对象</li><li>本地方法栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中的常量引用的对象</li></ul><img src="/img/26437/GC1.png" alt="GC1"  /><h3 id="2-并发标记算法（三色标记法）"><a href="#2-并发标记算法（三色标记法）" class="headerlink" title="2.并发标记算法（三色标记法）"></a>2.并发标记算法（三色标记法）</h3><h4 id="基础描述"><a href="#基础描述" class="headerlink" title="基础描述"></a>基础描述</h4><p>用三种颜色记录对象的标记状态</p><ul><li>黑色 – 已标记</li><li>灰色 – 标记中</li><li>白色 – 还未标记</li></ul><p><strong>示例</strong>：</p><p>1.起始的三个对象还未处理完成，用灰色表示</p><img src="/img/26437/GC2.png" alt="GC2" style="zoom:67%;" /><p>2.该对象的引用已经处理完成，用黑色表示，黑色引用的对象变为灰色</p><img src="/img/26437/GC3.png" alt="GC3" style="zoom:67%;" /><p>3.沿着引用链都标记一遍</p><img src="/img/26437/GC4.png" alt="GC4" style="zoom:67%;" /><p>4.最后未标记的白色对象，即为<strong>垃圾</strong></p><img src="/img/26437/GC5.png" alt="GC5" style="zoom:67%;" /><h4 id="并发漏标问题"><a href="#并发漏标问题" class="headerlink" title="并发漏标问题"></a>并发漏标问题</h4><p>比较先进的垃圾回收器都支持<strong>并发</strong>标记，即在标记过程中，用户线程仍然能工作。但这样带来一个新的问题，如果用户线程修改了对象引用，那么就存在<strong>漏标问题</strong>。</p><p><strong>示例</strong>：</p><p>1.如图所示标记工作尚未完成</p><img src="/img/26437/GC6.png" alt="GC6" style="zoom:67%;" /><p>2.用户线程同时在工作，断开了第一层 3、4 两个对象之间的引用，这时对于正在处理 3 号对象的垃圾回收线程来讲，它会将 4 号对象当做是白色垃圾</p><img src="/img/26437/GC7.png" alt="GC7" style="zoom:67%;" /><p>3.但如果其他用户线程又建立了 2、4 两个对象的引用，这时因为 2 号对象是黑色已处理对象了，因此垃圾回收线程不会察觉到这个引用关系的变化，从而产生了漏标</p><img src="/img/26437/GC8.png" alt="GC8" style="zoom:67%;" /><p>4.如果用户线程让黑色对象引用了一个新增对象，一样会存在漏标问题</p><img src="/img/26437/GC9.png" alt="GC9" style="zoom:67%;" /><p><strong>解决方案</strong>：</p><p>1.Incremental Update（增量更新法，CMS 垃圾回收器采用）</p><p>​思路是拦截每次赋值动作，只要赋值发生，被赋值的对象就会被记录下来，在重新标记阶段再确认一遍</p><p>2.Snapshot At The Beginning（SATB 原始快照法，G1 垃圾回收器采用）</p><p>​思路也是拦截每次赋值动作，不过记录的对象不同，也需要在重新标记阶段对这些对象二次处理</p><p>​新加对象会被记录，被删除引用关系的对象也被记录</p><h3 id="3-方法区回收"><a href="#3-方法区回收" class="headerlink" title="3.方法区回收"></a>3.方法区回收</h3><blockquote><p>方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，因此在方法区上进行回收性价比不高</p></blockquote><p>主要是对常量池的回收和对类的卸载。</p><p>类的卸载条件很多，需要满足以下三个条件（不一定回收）：</p><ul><li>该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例</li><li>加载该类的 ClassLoader 已经被回收</li><li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法</li></ul><h3 id="4-finalize"><a href="#4-finalize" class="headerlink" title="4.finalize()"></a>4.finalize()</h3><blockquote><p>finalize() 用来做关闭外部资源等工作。该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。</p></blockquote><p>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会调用 finalize() 方法。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存结构</title>
      <link href="/posts/27692/"/>
      <url>/posts/27692/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁概述"><a href="#🍁概述" class="headerlink" title="🍁概述"></a>🍁概述</h2><blockquote><p>JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。</p></blockquote><p>整体布局如下所示：</p><img src="/img/27692/JVM1.png" alt="JVM1" style="zoom:67%;" /><p>JVM内存结构中有5个比较重要的区域：程序计数器、虚拟机栈、本地方法栈、堆和方法区</p><h2 id="🍁程序计数器"><a href="#🍁程序计数器" class="headerlink" title="🍁程序计数器"></a>🍁程序计数器</h2><blockquote><p>程序计数寄存器（<strong>Program Counter Register</strong>），是当前线程所执行的字节码的<strong>行号指示器</strong>。是<strong>线程私有</strong>的。</p></blockquote><p>程序计数器用来存储指向下一条指令的地址，即<strong>将要执行</strong>的指令代码。由执行引擎读取下一条指令。</p><img src="/img/27692/JVM2.jpg" alt="JVM2" style="zoom:67%;" /><h2 id="🍁虚拟机栈"><a href="#🍁虚拟机栈" class="headerlink" title="🍁虚拟机栈"></a>🍁虚拟机栈</h2><blockquote><p>主管 Java <strong>程序</strong>的运行，它保存方法的<strong>局部变量</strong>、<strong>部分结果</strong>，并参与方法的调用和返回</p></blockquote><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a><strong>特点：</strong></h4><ul><li>JVM 直接对虚拟机栈的操作只有两个：每个方法执行，伴随着<strong>入栈</strong>（进栈&#x2F;压栈），方法执行结束<strong>出栈</strong></li><li><strong>栈不存在垃圾回收问题</strong></li></ul><h4 id="异常："><a href="#异常：" class="headerlink" title="异常："></a><strong>异常：</strong></h4><p><strong>Java虚拟机栈的大小是动态的或者是固定不变的</strong></p><p>采用固定大小的 Java 虚拟机栈，那每个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个 <strong>StackOverflowError</strong> 异常</p><p>采用动态扩展的Java 虚拟机栈，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个<strong>OutOfMemoryError</strong>异常</p><h4 id="调优："><a href="#调优：" class="headerlink" title="调优："></a>调优：</h4><p>通过参数<code>-Xss</code>来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度</p><h3 id="2-栈帧"><a href="#2-栈帧" class="headerlink" title="2.栈帧"></a>2.栈帧</h3><blockquote><p>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧（Stack Frame）</strong>的格式存在</p></blockquote><ul><li>在这个线程上正在执行的每个方法都各自有对应的一个栈帧</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</li></ul><h3 id="3-运行原理"><a href="#3-运行原理" class="headerlink" title="3.运行原理"></a>3.运行原理</h3><p>JVM 直接对 Java 栈的操作只有两个，对栈帧的<strong>压栈</strong>和<strong>出栈</strong>，遵循“先进后出”原则</p><p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（<strong>栈顶栈帧</strong>）是有效的，这个栈帧被称为<strong>当前栈帧</strong>（Current Frame），与当前栈帧对应的方法就是<strong>当前方法</strong>（Current Method），定义这个方法的类就是<strong>当前类</strong>（Current Class）</p><p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</p><p>如果在该方法中调用了其他方法，对应的<strong>新的栈帧</strong>会被创建出来，放在栈的顶端，称为新的当前栈帧</p><p>不同线程中所包含的<strong>栈帧是不允许存在相互引用</strong>的，即不可能在一个栈帧中引用另外一个线程的栈帧</p><p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</p><p>Java 方法有两种返回函数的方式，一种是正常的函数返回，使用 return 指令，另一种是抛出异常，不管用哪种方式，都会导致栈帧被弹出</p><img src="/img/27692/JVM3.jpg" alt="JVM3" style="zoom:67%;" /><h3 id="4-栈帧内部结构"><a href="#4-栈帧内部结构" class="headerlink" title="4.栈帧内部结构"></a>4.栈帧内部结构</h3><p><strong>栈帧</strong>（Stack Frame）中存储着局部变量表（Local Variables）、操作数栈（Operand Stack）(或表达式栈)、动态链接（Dynamic Linking）、方法返回地址（Return Address）、附加信息。</p><img src="/img/27692/JVM4.jpg" alt="JVM4" style="zoom:67%;" /><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>主要用于存储方法参数和定义在方法体内的局部变量</p><h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</p><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>指向运行时常量池的方法引用</p><h4 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h4><p>用来存放调用该方法的 PC 寄存器的值。</p><p>一个方法的结束，有两种方式：</p><ul><li>正常执行完成</li><li>出现未处理的异常，非正常退出</li></ul><h2 id="🍁本地方法栈"><a href="#🍁本地方法栈" class="headerlink" title="🍁本地方法栈"></a>🍁本地方法栈</h2><h3 id="1-本地方法"><a href="#1-本地方法" class="headerlink" title="1.本地方法"></a>1.本地方法</h3><blockquote><p>一个 Native Method 就是一个 Java 调用非 Java 代码的接口</p></blockquote><p>比如Java应用与Java环境外交互、与操作系统交互</p><h3 id="2-本地方法栈（Native-Method-Stack）"><a href="#2-本地方法栈（Native-Method-Stack）" class="headerlink" title="2.本地方法栈（Native Method Stack）"></a>2.本地方法栈（Native Method Stack）</h3><blockquote><p>Java 虚拟机栈用于管理 Java 方法的调用，而本地方法栈用于管理<strong>本地方法</strong>的调用，也是<strong>线程私有</strong>的</p></blockquote><h2 id="🍁堆"><a href="#🍁堆" class="headerlink" title="🍁堆"></a>🍁堆</h2><blockquote><p><strong>栈是运行时的单位，而堆是存储的单位</strong>。</p><p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪。</p></blockquote><h3 id="1-内存划分"><a href="#1-内存划分" class="headerlink" title="1.内存划分"></a>1.内存划分</h3><blockquote><p>Java 堆是 Java 虚拟机管理的内存中最大的一块，被所有线程共享。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数据都在这里分配内存</p></blockquote><h4 id="年轻代-Young-Generation"><a href="#年轻代-Young-Generation" class="headerlink" title="年轻代 (Young Generation)"></a><strong>年轻代 (Young Generation)</strong></h4><p>年轻代是所有新对象创建的地方。当填充年轻代时，执行垃圾收集。这种垃圾收集称为 <strong>Minor GC</strong>。年轻一代被分为三个部分——伊甸园（<strong>Eden Memory</strong>）和两个幸存区（<strong>Survivor Memory</strong>，被称为from&#x2F;to或s0&#x2F;s1），默认比例是<code>8:1:1</code></p><ul><li>大多数新创建的对象都位于 Eden 内存空间中</li><li>当 Eden 空间被对象填充时，执行<strong>Minor GC</strong>，并将所有幸存者对象移动到一个幸存者空间中</li><li>Minor GC 检查幸存者对象，并将它们移动到另一个幸存者空间。所以每次，<strong>一个幸存者空间总是空的</strong></li><li>经过多次 GC 循环后存活下来的对象被移动到老年代。通常，这是通过设置年轻一代对象的年龄阈值来实现的，然后他们才有资格提升到老一代</li></ul><h4 id="老年代-Old-Generation"><a href="#老年代-Old-Generation" class="headerlink" title="老年代(Old Generation)"></a><strong>老年代(Old Generation)</strong></h4><p>旧的一代内存包含那些经过许多轮小型 GC 后仍然存活的对象。通常，垃圾收集是在老年代内存满时执行的。老年代垃圾收集称为主GC（<strong>Major GC</strong>），通常需要更长的时间。</p><p><strong>大对象直接进入老年代</strong>（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在 Eden 区和两个Survivor 区之间发生大量的内存拷贝</p><h3 id="2-对象在堆中的生命周期"><a href="#2-对象在堆中的生命周期" class="headerlink" title="2.对象在堆中的生命周期"></a>2.对象在堆中的生命周期</h3><p>在 JVM 内存模型的堆中，堆被划分为新生代和老年代 </p><ul><li>新生代又被进一步划分为 <strong>Eden区</strong> 和 <strong>Survivor区</strong>，Survivor 区由 <strong>From Survivor</strong> 和 <strong>To Survivor</strong> 组成</li></ul><p>当创建一个对象时，对象会被优先分配到新生代的 Eden 区 </p><ul><li>此时 JVM 会给对象定义一个<strong>对象年轻计数器</strong>（<code>-XX:MaxTenuringThreshold</code>）</li></ul><p>当 Eden 空间不足时，JVM 将执行新生代的垃圾回收（Minor GC） </p><ul><li>JVM 会把存活的对象转移到 Survivor 中，并且对象年龄 +1</li><li>对象在 Survivor 中同样也会经历 Minor GC，每经历一次 Minor GC，对象年龄都会+1</li></ul><p>如果分配的对象超过了<code>-XX:PetenureSizeThreshold</code>，对象会直接被分配到老年代</p><h3 id="3-对象的分配过程"><a href="#3-对象的分配过程" class="headerlink" title="3.对象的分配过程"></a>3.对象的分配过程</h3><ol><li>new 的对象(年轻代)先放在伊甸园区，此区有大小限制</li><li>当伊甸园的空间<strong>填满</strong>时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中的<strong>不再被其他对象所引用的对象</strong>进行销毁。再加载新的对象放到伊甸园区</li><li>然后将伊甸园中的剩余对象移动到幸存者 0 区</li><li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者 0 区，如果没有回收，就会放到幸存者 1 区</li><li>如果再次经历垃圾回收，此时会重新放回幸存者 0 区，接着再去幸存者 1 区</li><li>默认 <strong>15</strong> 次回收标记才会去老年代</li><li>当老年代内存不足时，再次触发 Major GC，进行老年代的内存清理</li><li>若老年代执行了 Major GC 之后发现依然无法进行对象的保存，就会产生 OOM 异常</li></ol><h2 id="🍁方法区"><a href="#🍁方法区" class="headerlink" title="🍁方法区"></a>🍁方法区</h2><blockquote><p>方法区用于存储<strong>类</strong>信息、<strong>常量池</strong>、静态变量、即时编译器编译后的代码缓存等</p></blockquote><h3 id="1-永久代和元空间"><a href="#1-永久代和元空间" class="headerlink" title="1.永久代和元空间"></a>1.永久代和元空间</h3><p><strong>永久代</strong>（PermGen）是 Hotspot 虚拟机特有的概念， Java8 的时候又被<strong>元空间</strong>取代了，永久代和元空间都可以理解为方法区的<strong>落地实现</strong></p><ul><li>永久代是 Hotspot 虚拟机对 JVM 规范的实现（1.8 之前）</li><li>元空间是 Hotspot 虚拟机对 JVM 规范的另一种实现（1.8 以后），使用本地内存作为这些信息的存储空间</li></ul><h3 id="2-栈、堆、方法区交互"><a href="#2-栈、堆、方法区交互" class="headerlink" title="2.栈、堆、方法区交互"></a>2.栈、堆、方法区交互</h3><img src="/img/27692/JVM5.png" alt="JVM5" style="zoom:67%;" />]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring事务失效</title>
      <link href="/posts/6750/"/>
      <url>/posts/6750/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁Spring事务失效概述"><a href="#🍁Spring事务失效概述" class="headerlink" title="🍁Spring事务失效概述"></a>🍁Spring事务失效概述</h2><p>在Spring中要开启事务管理，一般在配置类上使用<code>@EnableTransactionManagement</code>注解，在需要事务管理的方法上加<code>@Transactional</code>注解，但有时注解也会失效。以下就是常见的Spring事务失效的场景</p><p>前置说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前置配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(exposeProxy = true)</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;day04.tx.app.service&quot;)</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;day04.tx.app.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConfigurationProperties(&quot;jdbc&quot;)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceInitializer <span class="title function_">dataSourceInitializer</span><span class="params">(DataSource dataSource, DatabasePopulator populator)</span> &#123;</span><br><span class="line">        <span class="type">DataSourceInitializer</span> <span class="variable">dataSourceInitializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceInitializer</span>();</span><br><span class="line">        dataSourceInitializer.setDataSource(dataSource);</span><br><span class="line">        dataSourceInitializer.setDatabasePopulator(populator);</span><br><span class="line">        <span class="keyword">return</span> dataSourceInitializer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DatabasePopulator <span class="title function_">databasePopulator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResourceDatabasePopulator</span>(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;account.sql&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">factoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        factoryBean.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> factoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PlatformTransactionManager <span class="title function_">transactionManager</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// @Bean</span></span><br><span class="line">    <span class="comment">// //只要 beanFactory 的 allowBeanDefinitionOverriding==true, 即使系统的 @Bean 定义没有 @ConditionalOnMissingBean 条件，也会被我们的同名 @Bean 覆盖掉</span></span><br><span class="line">    <span class="comment">// public TransactionAttributeSource transactionAttributeSource() &#123;</span></span><br><span class="line">    <span class="comment">//     return new AnnotationTransactionAttributeSource(false);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestService1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());</span><br><span class="line">        ConfigurationPropertiesBindingPostProcessor.register(context.getDefaultListableBeanFactory());</span><br><span class="line">        context.registerBean(AppConfig.class);</span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        <span class="type">Service1</span> <span class="variable">bean</span> <span class="operator">=</span> context.getBean(Service1.class);</span><br><span class="line">        bean.transfer(<span class="number">1</span>, <span class="number">2</span>, <span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🍁1-抛出检查异常"><a href="#🍁1-抛出检查异常" class="headerlink" title="🍁1.抛出检查异常"></a>🍁1.抛出检查异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抛出检查异常</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span> <span class="comment">// 解法：加入rollbackFor配置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">        <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;aaa&quot;</span>); <span class="comment">//读取文件异常</span></span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因：Spring 默认只会<strong>回滚非检查异常</strong><br>解法：配置 rollbackFor 属性<br>    @Transactional(rollbackFor &#x3D; Exception.class)</p><h2 id="🍁2-业务方法内自己处理（try-catch）异常"><a href="#🍁2-业务方法内自己处理（try-catch）异常" class="headerlink" title="🍁2.业务方法内自己处理（try-catch）异常"></a>🍁2.业务方法内自己处理（try-catch）异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务方法自己处理异常</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service2</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">            <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">                accountMapper.update(to, amount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">// throw new RuntimeException(e); // 解法一</span></span><br><span class="line">            <span class="comment">// TransactionInterceptor.currentTransactionStatus().setRollbackOnly(); //解法二</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因：事务通知只有捉到了目标抛出的异常，才能进行后续的回滚处理，如果目标<strong>自己处理掉异常，事务通知无法知悉</strong><br>解法1：异常原样抛出<br>    在 catch 块添加 throw new RuntimeException(e);<br>解法2：手动设置 TransactionStatus.setRollbackOnly()<br>    在 catch 块添加 TransactionInterceptor.currentTransactionStatus().setRollbackOnly();</p><h2 id="🍁3-AOP切面顺序"><a href="#🍁3-AOP切面顺序" class="headerlink" title="🍁3.AOP切面顺序"></a>🍁3.AOP切面顺序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数+切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestService3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());</span><br><span class="line">        ConfigurationPropertiesBindingPostProcessor.register(context.getDefaultListableBeanFactory());</span><br><span class="line">        context.registerBean(MyAspect.class);</span><br><span class="line">        context.registerBean(AppConfig.class);</span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        <span class="type">Service3</span> <span class="variable">bean</span> <span class="operator">=</span> context.getBean(Service3.class);</span><br><span class="line">        bean.transfer(<span class="number">1</span>, <span class="number">2</span>, <span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Aspect</span></span><br><span class="line">    <span class="meta">@Order(Ordered.LOWEST_PRECEDENCE - 1)</span> <span class="comment">// 解法三：调整切面顺序</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">        <span class="meta">@Around(&quot;execution(* transfer(..))&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            LoggerUtils.get().debug(<span class="string">&quot;log:&#123;&#125;&quot;</span>, pjp.getTarget());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> pjp.proceed();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务方法</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service3</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">        <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因：事务切面优先级最低，但如果自定义的切面优先级和其一样，则还是自定义切面在内层，这时若自定义切面没有正确抛出异常（异常向上抛出，事务需要捕获）<br>解法1、2：同情况2 中的解法:1、2<br>解法3：</p><p>​调整切面顺序，在 MyAspect 上添加 @Order(Ordered.LOWEST_PRECEDENCE - 1) （不推荐）</p><h2 id="🍁4-非-public-方法"><a href="#🍁4-非-public-方法" class="headerlink" title="🍁4.非 public 方法"></a>🍁4.非 public 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service4</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="comment">// 演示：这里非public方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">        <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因：Spring 为方法创建代理、添加事务通知、前提条件都是<strong>该方法是 public</strong> 的<br>解法1：改为 public 方法<br>解法2：添加 bean 配置到配置类如下（不推荐）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加配置类</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> TransactionAttributeSource <span class="title function_">transactionAttributeSource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnnotationTransactionAttributeSource</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🍁5-父子容器导致"><a href="#🍁5-父子容器导致" class="headerlink" title="🍁5.父子容器导致"></a>🍁5.父子容器导致</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Service类</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service5</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">        <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Controller类</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> Service5 service;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        service.transfer(from, to, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主函数-父子容器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestService5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(parent.getDefaultListableBeanFactory());</span><br><span class="line">        ConfigurationPropertiesBindingPostProcessor.register(parent.getDefaultListableBeanFactory());</span><br><span class="line">        parent.registerBean(AppConfig.class);</span><br><span class="line">        parent.refresh();</span><br><span class="line"></span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">child</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(child.getDefaultListableBeanFactory());</span><br><span class="line">        child.setParent(parent);</span><br><span class="line">        child.registerBean(WebConfig.class);</span><br><span class="line">        child.refresh();</span><br><span class="line"></span><br><span class="line">        <span class="type">AccountController</span> <span class="variable">bean</span> <span class="operator">=</span> child.getBean(AccountController.class);</span><br><span class="line">        bean.transfer(<span class="number">1</span>, <span class="number">2</span>, <span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Web配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;day04.tx.app.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在配置了父子容器，WebConfig 对应子容器，AppConfig 对应父容器，发现事务失效</p><p>原因：子容器扫描范围过大，把未加事务配置的 service 扫描进来<br>解法1：各扫描各的<br>解法2：不要用父子容器，所有 bean 放在同一容器（比较传统的做法）</p><h2 id="🍁6-调用本类方法导致传播行为失效"><a href="#🍁6-调用本类方法导致传播行为失效" class="headerlink" title="🍁6.调用本类方法导致传播行为失效"></a>🍁6.调用本类方法导致传播行为失效</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service6</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        LoggerUtils.get().debug(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        bar(); <span class="comment">// 调用本类方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        LoggerUtils.get().debug(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因：<strong>本类方法调用不经过代理</strong>，因此无法增强<br>解法1：依赖注入自己（代理）来调用<br>解法2：通过 AopContext 拿到代理对象，来调用<br>解法3：通过 CTW，LTW 实现功能增强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service6</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Service6 proxy; <span class="comment">// 解法1：本质上是一种循环依赖</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        LoggerUtils.get().debug(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">System.out.println(proxy.getClass());</span><br><span class="line">proxy.bar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        LoggerUtils.get().debug(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要在 AppConfig 上添加 @EnableAspectJAutoProxy(exposeProxy = true)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service6</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        LoggerUtils.get().debug(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        ((Service6) AopContext.currentProxy()).bar(); <span class="comment">// 解法2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        LoggerUtils.get().debug(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🍁7-Transactional-没有保证原子行为"><a href="#🍁7-Transactional-没有保证原子行为" class="headerlink" title="🍁7.@Transactional 没有保证原子行为"></a>🍁7.@Transactional 没有保证原子行为</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service7</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(Service7.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">        logger.debug(<span class="string">&quot;更新前查询余额为: &#123;&#125;&quot;</span>, fromBalance);</span><br><span class="line">        <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBalance</span><span class="params">(<span class="type">int</span> accountNo)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountMapper.findBalanceBy(accountNo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码问题：假设 from 余额为 1000，两个线程都来转账 1000，可能会出现扣减为<strong>负数</strong>的情况</p><p>原因：事务的原子性仅涵盖 insert、update、delete、select … for update 语句，<strong>select 方法</strong>并不阻塞</p><img src="/img/6750/transactional1.png" alt="transactional1" style="zoom:67%;" /><p>如上：红色线程和蓝色线程的查询都发生在扣减之前，都以为自己有足够的余额做扣减</p><p>一种解法（无效）：尝试加synchronized锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service7</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(Service7.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">        logger.debug(<span class="string">&quot;更新前查询余额为: &#123;&#125;&quot;</span>, fromBalance);</span><br><span class="line">        <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBalance</span><span class="params">(<span class="type">int</span> accountNo)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountMapper.findBalanceBy(accountNo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无效原因：synchronized 保证的仅是<strong>目标方法的原子性</strong>，环绕目标方法的还有 <strong>commit</strong> 等操作，它们并未处于 sync 块内</p><img src="/img/6750/transactional2.png" alt="transactional2" style="zoom:67%;" /><p>如上图：蓝色线程的查询只要在红色线程提交之前执行，那么依然会查询到有 1000 足够余额来转账</p><hr><p>解法1：synchronized 范围扩大至代理方法调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());</span><br><span class="line">    ConfigurationPropertiesBindingPostProcessor.register(context.getDefaultListableBeanFactory());</span><br><span class="line">    context.registerBean(AppConfig.class);</span><br><span class="line">    context.refresh();</span><br><span class="line"></span><br><span class="line">    <span class="type">Service7</span> <span class="variable">bean</span> <span class="operator">=</span> context.getBean(Service7.class);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MyThread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">//synchronized 范围扩大</span></span><br><span class="line">            bean.transfer(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>, <span class="string">&quot;boldMagenta&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MyThread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            bean.transfer(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>, <span class="string">&quot;boldBlue&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    latch.await();</span><br><span class="line">    System.out.println(bean.findBalance(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法2：使用 select … for update 替换 select（数据库层面）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select balance from account where accountNo=#&#123;accountNo&#125; for update&quot;)</span> <span class="comment">// 替换</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findBalanceBy</span><span class="params">(<span class="type">int</span> accountNo)</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringMVC </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring设计模式</title>
      <link href="/posts/52990/"/>
      <url>/posts/52990/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁Singleton"><a href="#🍁Singleton" class="headerlink" title="🍁Singleton"></a>🍁Singleton</h2><blockquote><p><em>Ensure a class only has one instance, and provide a global point of access to it</em></p></blockquote><p>Spring 中的 singleton bean 并非实现了单例模式，singleton bean 只能保证<strong>每个容器内，相同 id 的 bean 单实例</strong></p><p>Spring中的体现：</p><ul><li>org.springframework.transaction.TransactionDefinition#withDefaults</li><li>org.springframework.aop.TruePointcut#INSTANCE</li><li>org.springframework.aop.interceptor.ExposeInvocationInterceptor#ADVISOR</li><li>org.springframework.core.annotation.AnnotationAwareOrderComparator#INSTANCE</li><li>org.springframework.core.OrderComparator#INSTANCE</li></ul><h2 id="🍁Builder"><a href="#🍁Builder" class="headerlink" title="🍁Builder"></a>🍁Builder</h2><blockquote><p><em>Separate the construction of a complex object from its representation so that the same construction process can create different representations</em></p></blockquote><p>主要亮点有三处：</p><ul><li>较为灵活的构建产品对象 </li><li>在不执行最后 build 方法前，产品对象都不可用 </li><li>构建过程采用链式调用</li></ul><p>Spring 中的体现：</p><ul><li>org.springframework.beans.factory.support.BeanDefinitionBuilder </li><li>org.springframework.web.util.UriComponentsBuilder </li><li>org.springframework.http.ResponseEntity.HeadersBuilder </li><li>org.springframework.http.ResponseEntity.BodyBuilder</li></ul><h2 id="🍁Factory-Method"><a href="#🍁Factory-Method" class="headerlink" title="🍁Factory Method"></a>🍁Factory Method</h2><blockquote><p><em>Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses</em></p></blockquote><p>Spring 中的体现：</p><ul><li>Spring 中的 ApplicationContext 与 BeanFactory 中的 getBean 都可以视为工厂方法（隐藏了 bean （产品）的创建过程和具体实现）</li><li>org.springframework.beans.factory.FactoryBean </li><li>@Bean 标注的静态方法及实例方法  </li><li>ObjectFactory 及 ObjectProvider，推迟 bean 创建，解决循环依赖及单例注入多例等问题</li></ul><h2 id="🍁Adapter"><a href="#🍁Adapter" class="headerlink" title="🍁Adapter"></a>🍁Adapter</h2><blockquote><p><em>Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces</em></p></blockquote><p>Spring 中的体现：</p><ul><li><p>org.springframework.web.servlet.HandlerAdapter – 因为控制器实现有各种各样，比如有</p></li><li><ul><li><p><strong>@RequestMapping</strong> 标注的控制器实现</p></li><li><p>传统的基于 Controller 接口（非 @Controller注解）的实现</p></li><li><p>较新的基于 RouterFunction 接口的实现</p><p>它们的处理方法都不一样，为了统一调用，必须适配为 HandlerAdapter 接口</p></li></ul></li><li><p>org.springframework.beans.factory.support.DisposableBeanAdapter – 因为销毁方法多种多样，因此都要适配为 DisposableBean 来统一调用销毁方法</p></li></ul><h2 id="🍁Composite"><a href="#🍁Composite" class="headerlink" title="🍁Composite"></a>🍁Composite</h2><blockquote><p><em>Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly</em></p></blockquote><p>composite 对象的作用是，将<strong>分散的调用集中起来，统一调用入口</strong>，它的特征是，与具体干活的实现实现同一个接口，当调用 composite 对象的接口方法时，其实是<strong>委托具体干活的实现</strong>来完成</p><p>Spring 中的体现：</p><ul><li>org.springframework.web.method.support.HandlerMethodArgumentResolverComposite</li><li>org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite</li><li>org.springframework.web.servlet.handler.HandlerExceptionResolverComposite</li><li>org.springframework.web.servlet.view.ViewResolverComposite</li></ul><h2 id="🍁Decorator"><a href="#🍁Decorator" class="headerlink" title="🍁Decorator"></a>🍁Decorator</h2><blockquote><p><em>Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality</em></p></blockquote><p>Spring 中的体现：<br>    org.springframework.web.util.ContentCachingRequestWrapper</p><h2 id="🍁Proxy"><a href="#🍁Proxy" class="headerlink" title="🍁Proxy"></a>🍁Proxy</h2><blockquote><p><em>Provide a surrogate or placeholder for another object to control access to it</em></p></blockquote><p>装饰器模式注重的是<strong>功能增强</strong>，避免子类继承方式进行功能扩展，而代理模式<strong>更注重控制目标的访问（环绕通知等）</strong></p><p>Spring 中的体现（AOP）：</p><ul><li>org.springframework.aop.framework.JdkDynamicAopProxy</li><li>org.springframework.aop.framework.ObjenesisCglibAopProxy</li></ul><h2 id="🍁Chain-of-Responsibility"><a href="#🍁Chain-of-Responsibility" class="headerlink" title="🍁Chain of Responsibility"></a>🍁Chain of Responsibility</h2><blockquote><p><em>Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it</em></p></blockquote><p>Spring 中的体现（拦截器）：<br>    org.springframework.web.servlet.<strong>HandlerInterceptor</strong></p><h2 id="🍁Observer"><a href="#🍁Observer" class="headerlink" title="🍁Observer"></a>🍁Observer</h2><blockquote><p><em>Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically</em></p></blockquote><p>Spring 中的体现：</p><ul><li>org.springframework.context.<strong>ApplicationListener</strong></li><li>org.springframework.context.event.ApplicationEventMulticaster</li><li>org.springframework.context.ApplicationEvent</li></ul><h2 id="🍁Strategy"><a href="#🍁Strategy" class="headerlink" title="🍁Strategy"></a>🍁Strategy</h2><blockquote><p><em>Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it</em></p></blockquote><p>Spring 中的体现：</p><ul><li>org.springframework.beans.factory.support.InstantiationStrategy</li><li>org.springframework.core.annotation.MergedAnnotations.SearchStrategy</li><li>org.springframework.boot.autoconfigure.condition.SearchStrategy</li></ul><h2 id="🍁Template-Method"><a href="#🍁Template-Method" class="headerlink" title="🍁Template Method"></a>🍁Template Method</h2><blockquote><p><em>Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure</em></p></blockquote><p>Spring 中的体现：</p><ul><li>大部分以 Template 命名的类，如 JdbcTemplate，TransactionTemplate</li><li>很多以 Abstract 命名的类，如 AbstractApplicationContext</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringMVC </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring注解</title>
      <link href="/posts/5399/"/>
      <url>/posts/5399/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁Spring常见注解"><a href="#🍁Spring常见注解" class="headerlink" title="🍁Spring常见注解"></a>🍁Spring常见注解</h2><h3 id="组件扫描与配置类"><a href="#组件扫描与配置类" class="headerlink" title="组件扫描与配置类"></a>组件扫描与配置类</h3><p>@Component : 标识组件,没有明确的角色</p><p>@Service : 在业务逻辑层(service层)使用</p><p>@Repository : 在数据访问层(dao层)使用</p><p>@Controller : 在控制层(controller)使用</p><hr><p>@ComponentScan : 自动扫描包名下所有使用 @Component @Service  @Repository @Controller 的类,并注册为Bean</p><p>@Conditional : 组件扫描时进行<strong>条件装配</strong></p><hr><p>@Configuration : 声明当前类是个<strong>配置类</strong>，相当于一个Spring配置的xml文件</p><ul><li>配置类其实相当于一个工厂, 标注 @Bean 注解的方法相当于<strong>工厂方法</strong> </li><li>@Bean  不支持<strong>方法重载</strong>, 如果有多个重载方法, 仅有一个能入选为工厂方法 </li><li>@Configuration  默认会为标注的类生成代理, 其目的是保证 @Bean  方法相互调用时, 仍然能保证其单例特性 </li><li>@Configuration  中如果含有 BeanFactory 后处理器, 则实例工厂方法会导致 MyConfig 提前创建, 造成其依赖注入失败，解决方法是改用静态工厂方法或直接为 @Bean  的方法参数依赖注入, 针对 Mapper 扫描可以改用注解方式</li></ul><p>@Bean : 注解在方法上,声明当前方法的返回值为一个Bean</p><p>@Import</p><p><strong>四种用法</strong></p><ul><li>引入单个 bean</li><li>引入一个配置类</li><li>通过 Selector 引入多个类</li><li>通过 beanDefinition 注册器</li></ul><p><strong>解析规则</strong> </p><ul><li>同一配置类中, @Import  先解析  @Bean  后解析<br>同名定义, 默认后面解析的会覆盖前面解析的</li><li>不允许覆盖的情况下, 让 MyConfig(主配置类) 的配置优先:采用 DeferredImportSelector，因为它最后工作, 可以简单认为先解析 @Bean, 再 @Import</li></ul><hr><p>@Lazy</p><ul><li>加在类上，表示此类延迟实例化、初始化</li><li>加在方法参数上，此参数会以代理方式注入</li></ul><p>@PropertySource : 读取Properties文件，将键值信息加入到Environment</p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a><strong>依赖注入</strong></h3><p>@Autowired : 加在成员变量或方法上完成依赖注入</p><p>@Qualifier : 多个Bean的类型相同，根据<strong>名字</strong>进一步区分</p><p>@Value : 值注入</p><h3 id="事务注解"><a href="#事务注解" class="headerlink" title="事务注解"></a><strong>事务注解</strong></h3><p>@EnableTransactionManagement，会额外加载 4 个 bean</p><ul><li>BeanFactoryTransactionAttributeSourceAdvisor 事务切面类</li><li>TransactionAttributeSource 用来解析事务属性</li><li>TransactionInterceptor 事务拦截器</li><li>TransactionalEventListenerFactory 事务监听器工厂</li></ul><p>@Transactional : 方法或类上开启事务管理</p><h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a><strong>核心</strong></h3><p>@Order : 控制Bean的执行顺序</p><h3 id="切面"><a href="#切面" class="headerlink" title="切面"></a><strong>切面</strong></h3><p>@EnableAspectJAutoProxy : 开启Spring 对这个切面(Aspect)的支持</p><ul><li>会加载 AnnotationAwareAspectJAutoProxyCreator，它是一个 bean 后处理器，用来创建代理</li><li>如果没有配置 @EnableAspectJAutoProxy，又需要用到代理（如事务）则会使用 InfrastructureAdvisorAutoProxyCreator 这个 bean 后处理器</li></ul><h2 id="🍁SpringMVC常见注解"><a href="#🍁SpringMVC常见注解" class="headerlink" title="🍁SpringMVC常见注解"></a>🍁SpringMVC常见注解</h2><h3 id="mvc-mapping"><a href="#mvc-mapping" class="headerlink" title="mvc mapping"></a><strong>mvc mapping</strong></h3><p>@RequestMapping : <strong>匹配请求</strong>，加载类上统一请求的前缀，可以派生多个注解如 @GetMapping 等</p><h3 id="mvc-rest"><a href="#mvc-rest" class="headerlink" title="mvc rest"></a><strong>mvc rest</strong></h3><p>@RequestBody : 处理请求体中的<strong>JSON数据</strong>，将JSON数据转为Java对象</p><p>@ResponseBody : 与RequestBody相反，Java对象转为JSON数据，处理响应体，组合 @Controller &#x3D;&gt; @RestController</p><p>@ResponseStatus : 控制响应的状态码</p><h3 id="mvc-统一处理"><a href="#mvc-统一处理" class="headerlink" title="mvc 统一处理"></a><strong>mvc 统一处理</strong></h3><p>@ControllerAdvice : 组合 @ResponseBody &#x3D;&gt; @RestControllerAdvice</p><p>@ExceptionHandler : 处理异常</p><h3 id="mvc-参数"><a href="#mvc-参数" class="headerlink" title="mvc 参数"></a><strong>mvc 参数</strong></h3><p>@PathVariable : 获取请求路径中的参数值</p><h2 id="🍁SpringBoot常见注解"><a href="#🍁SpringBoot常见注解" class="headerlink" title="🍁SpringBoot常见注解"></a>🍁SpringBoot常见注解</h2><h3 id="boot-auto"><a href="#boot-auto" class="headerlink" title="boot auto"></a>boot auto</h3><p>@SpringBootApplication : 开启<strong>自动配置</strong>，以下两个注解+@ComponentScan</p><ul><li>@EnableAutoConfiguration</li><li>@SpringBootConfiguration</li></ul><h3 id="boot-condition"><a href="#boot-condition" class="headerlink" title="boot condition"></a>boot condition</h3><p>@ConditionalOnClass : classpath 下存在某个 class 时，条件才成立</p><p>@ConditionalOnMissingBean : beanFactory 内不存在某个 bean 时，条件才成立</p><p>@ConditionalOnProperty : 配置文件中存在某个 property（键、值）时，条件才成立</p><h3 id="boot-properties"><a href="#boot-properties" class="headerlink" title="boot properties"></a>boot properties</h3><p>@ConfigurationProperties : 会将当前 bean 的属性与配置文件中的键值进行绑定<br>@EnableConfigurationProperties : 会添加两个较为重要的 bean </p><ul><li>ConfigurationPropertiesBindingPostProcessor，bean 后处理器，在 bean 初始化前调用下面的 binder</li><li>ConfigurationPropertiesBinder，真正执行绑定操作</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringMVC </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot自动配置</title>
      <link href="/posts/3992/"/>
      <url>/posts/3992/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁概述"><a href="#🍁概述" class="headerlink" title="🍁概述"></a>🍁概述</h2><p>SpringBoot的自动配置，从启动类上的<code>@SpringBootApplication</code>注解开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoconfigurationApplication</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">SpringApplication.run(AutoconfigurationApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@SpringBootApplication</code> 是一个组合注解，主要由<code>@SpringBootConfiguration</code> 、 <code>@ComponentScan</code>和<code>@EnableAutoConfiguration</code> 组成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">      @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="🍁-SpringBootConfiguration"><a href="#🍁-SpringBootConfiguration" class="headerlink" title="🍁@SpringBootConfiguration"></a>🍁@SpringBootConfiguration</h2><blockquote><p>这个注解实际上就是一个@Configuration</p></blockquote><p><code>@SpringBootConfiguration</code> 与普通 <code>@Configuration</code>  相比，唯一区别是前者要求整个 app 中<strong>只出现一次</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 也是一个配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">    <span class="meta">@AliasFor(</span></span><br><span class="line"><span class="meta">        annotation = Configuration.class</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🍁-ComponentScan"><a href="#🍁-ComponentScan" class="headerlink" title="🍁@ComponentScan"></a>🍁@ComponentScan</h2><blockquote><p>这个注解的作用是扫描当前包及其子包</p></blockquote><p>有一个比较重要的配置是<strong>excludeFilters</strong>，用来在组件扫描时进行排除，也会排除自动配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestExcludeFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());</span><br><span class="line">        context.registerBean(MyConfig.class);</span><br><span class="line">        context.registerBean(MyFilter.class); </span><br><span class="line">        context.refresh();</span><br><span class="line">        <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">            System.out.println(name); <span class="comment">//只有bean2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@ComponentScan(basePackages = &#123;&quot;day04.boot.sub&quot;&#125;,</span></span><br><span class="line"><span class="meta">            excludeFilters = &#123; @ComponentScan.Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class)&#125;)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配合 @ComponentScan 使用, 对扫描到的元数据进行过滤, 返回 true 表示过滤掉, false 表示保留</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyFilter</span> <span class="keyword">extends</span> <span class="title class_">TypeExcludeFilter</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> metadataReader.getClassMetadata().getClassName();</span><br><span class="line">            LoggerUtils.get().debug(<span class="string">&quot;&#123;&#125;&quot;</span>, className);</span><br><span class="line">            <span class="keyword">if</span> (className.equals(Bean1.class.getName())) &#123; <span class="comment">// Bean1进行过滤</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="🍁-EnableAutoConfiguration"><a href="#🍁-EnableAutoConfiguration" class="headerlink" title="🍁@EnableAutoConfiguration"></a>🍁@EnableAutoConfiguration</h2><blockquote><p>进行自动装配的注解</p></blockquote><p>也主要包括两个注解</p><p>@AutoConfigurationPackage – 用来记住扫描的起始包<br>@Import(AutoConfigurationImportSelector.class) 用来加载 META-INF&#x2F;spring.factories 中的自动配置类</p><p>源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="operator">=</span> <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());</span><br><span class="line"><span class="comment">//        context.getEnvironment().getPropertySources().addLast(new ResourcePropertySource(&quot;application.properties&quot;));</span></span><br><span class="line">        context.registerBean(MyConfig.class);</span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(AutoConfigurationPackages.get(context.getDefaultListableBeanFactory()));</span></span><br><span class="line"><span class="comment">// 打印当前包</span></span><br><span class="line">        <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class, EnableAutoConfiguration.class.getClassLoader()).stream()</span></span><br><span class="line"><span class="comment">//                .filter(name -&gt; !name.equals(OtherConfig.class.getName())).map(name -&gt; &quot;\&quot;&quot; + name + &quot;\&quot;&quot;).collect(Collectors.joining(&quot;,&quot;,&quot;&#123;&quot;,&quot;&#125;&quot;)));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//    @AutoConfigurationPackage  //用来记住扫描的起始包</span></span><br><span class="line">    <span class="meta">@EnableAutoConfiguration(excludeName = &#123;&quot;org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.aop.AopAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRestClientAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.data.neo4j.Neo4jReactiveDataAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.data.neo4j.Neo4jReactiveRepositoriesAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.data.r2dbc.R2dbcDataAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.data.r2dbc.R2dbcRepositoriesAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.elasticsearch.ElasticsearchRestClientAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.availability.ApplicationAvailabilityAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.neo4j.Neo4jAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.netty.NettyAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.r2dbc.R2dbcAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.r2dbc.R2dbcTransactionManagerAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.rsocket.RSocketMessagingAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.rsocket.RSocketRequesterAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.rsocket.RSocketServerAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.rsocket.RSocketStrategiesAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.security.rsocket.RSocketSecurityAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.session.SessionAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.sql.init.SqlInitializationAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration&quot;, &quot;org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration&quot;, &quot;org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration&quot;&#125;)</span></span><br><span class="line"><span class="comment">//    @Import(OtherConfig.class) // 不使用 @Import  直接引入自动配置类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123; <span class="comment">// 主配置</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123; <span class="comment">// 加载主配置中的bean1而不加载从属配置中的</span></span><br><span class="line">            System.out.println(<span class="string">&quot;MyConfig bean1()&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OtherConfig</span> &#123; <span class="comment">// 从属配置(自动配置、默认配置)</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">        <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;OtherConfig bean1()&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> Bean2 <span class="title function_">bean2</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>不使用 @Import  直接引入自动配置类的原因</p><ul><li>这让主配置类和自动配置类变成了<strong>强耦合</strong>，主配置类不应该知道有哪些从属配置</li><li>直接用 @Import(自动配置类.class)，引入的配置解析优先级较高，自动配置类的解析应该在主配置没提供时作为<strong>默认配置</strong></li></ul><p>而采用了 @Import(AutoConfigurationImportSelector.class)</p><ul><li>由 AutoConfigurationImportSelector.class 去读取 META-INF&#x2F;spring.factories 中的自动配置类，实现了弱耦合</li><li>另外 AutoConfigurationImportSelector.class 实现了 DeferredImportSelector 接口，让自动配置的解析晚于主配置的解析</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC执行流程</title>
      <link href="/posts/20834/"/>
      <url>/posts/20834/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁概述"><a href="#🍁概述" class="headerlink" title="🍁概述"></a>🍁概述</h2><blockquote><p>Spring MVC是Spring在Spring Container Core和AOP等技术基础上，遵循Web MVC的规范推出的web开发框架，为了简化Java栈的web开发</p></blockquote><p>SpringMVC的核心执行流程如下：</p><img src="/img/20834/spring-mvc-1.png" alt="spring-mvc-1" style="zoom:67%;" /><ol><li><strong>【发送请求】请求——&gt;DispatcherServlet</strong>，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；</li><li><strong>【映射处理器】DispatcherServlet——&gt;HandlerMapping</strong>， HandlerMapping 将会把请求映射为 <strong>HandlerExecutionChain</strong> 对象（包含一个Handler 处理器（页面控制器）对象、多个HandlerInterceptor 拦截器）对象，通过这种<strong>策略模式</strong>，很容易添加新的映射策略；</li><li><strong>【处理器适配】DispatcherServlet——&gt;HandlerAdapter</strong>，HandlerAdapter 将会把处理器包装为适配器，从而支持多种类型的处理器， 即适配器设计模式的应用，从而很容易支持很多类型的处理器；</li><li><strong>【调用处理器】HandlerAdapter——&gt;处理器功能处理方法的调用</strong>，HandlerAdapter 将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理，并返回一个ModelAndView 对象（包含模型数据、逻辑视图名）；</li><li><strong>【视图解析】ModelAndView 的逻辑视图名——&gt; ViewResolver</strong>，ViewResolver 将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术；</li><li><strong>【视图渲染】View——&gt;渲染</strong>，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构，因此很容易支持其他视图技术；</li><li><strong>【返回响应】返回控制权给DispatcherServlet</strong>，由DispatcherServlet 返回响应给用户，到此一个流程结束。</li></ol><p>其实整个的执行流程也可以划分为三个阶段，<strong>初始化、匹配和调用</strong>三个阶段，下面分别说明</p><h2 id="🍁初始化阶段"><a href="#🍁初始化阶段" class="headerlink" title="🍁初始化阶段"></a>🍁初始化阶段</h2><ol><li>在 Web 容器第一次用到 <strong>DispatcherServlet</strong> 的时候，会创建其对象并执行 init 方法 </li><li><strong>init</strong> 方法内会创建 Spring Web 容器，并调用容器 <strong>refresh</strong> 方法 </li><li>refresh 过程中会创建并初始化 SpringMVC 中的重要组件， 例如 MultipartResolver，HandlerMapping，HandlerAdapter，HandlerExceptionResolver、ViewResolver 等 </li><li>容器初始化后，会将上一步初始化好的重要组件，赋值给 DispatcherServlet 的成员变量，留待后用</li></ol><img src="/img/20834/spring-mvc-2.png" alt="spring-mvc-2" style="zoom:67%;" /><h2 id="🍁匹配阶段"><a href="#🍁匹配阶段" class="headerlink" title="🍁匹配阶段"></a>🍁匹配阶段</h2><ol><li>用户发送的请求统一到达前端控制器 DispatcherServlet </li><li>DispatcherServlet 遍历所有 HandlerMapping ，找到与路径匹配的处理器<br>   ① HandlerMapping 有多个，每个 HandlerMapping 会返回不同的处理器对象，谁先匹配，返回谁的处理器。其中能识别 <strong>@RequestMapping  的优先级最高</strong><br>   ② 对应 @RequestMapping  的处理器是 HandlerMethod，它包含了控制器对象和控制器方法信息<br>   ③ 其中路径与处理器的映射关系在 HandlerMapping 初始化时就会建立好</li></ol><img src="/img/20834/spring-mvc-3.png" alt="spring-mvc-3" style="zoom:67%;" /><ol start="3"><li>将HandlerMethod连同匹配到的<strong>拦截器</strong>，生成<strong>调用链对象</strong>HandlerExecutionChain返回</li></ol><img src="/img/20834/spring-mvc-4.png" alt="img" style="zoom:67%;" /><ol start="4"><li>遍历HandlerAdapter处理器适配器，找到能处理HandlerMethod的<strong>适配器对象</strong>，开始调用</li></ol><img src="/img/20834/spring-mvc-5.png" alt="img" style="zoom:67%;" /><h2 id="🍁调用阶段"><a href="#🍁调用阶段" class="headerlink" title="🍁调用阶段"></a>🍁调用阶段</h2><ol><li>执行拦截器 <strong>preHandle</strong>(按照拦截器的<strong>正向</strong>顺序)</li></ol><img src="/img/20834/spring-mvc-6.png" alt="img" style="zoom:67%;" /><ol start="2"><li>由 HandlerAdapter 调用 HandlerMethod</li></ol><p>​① 调用前处理不同类型的参数</p><p>​② 调用后处理不同类型的返回值</p><img src="/img/20834/spring-mvc-7.png" alt="img" style="zoom:67%;" /><ol start="3"><li>第 2 步没有异常</li></ol><p>​① 返回 ModelAndView</p><p>​② 执行拦截器 <strong>postHandle</strong> 方法(按照拦截器的<strong>反向</strong>顺序)</p><p>​③ 解析视图，得到 View 对象，进行视图渲染</p><img src="/img/20834/spring-mvc-8.png" alt="img" style="zoom:67%;" /><ol start="4"><li>第 2 步有异常，进入 HandlerExceptionResolver 异常处理流程</li></ol><img src="/img/20834/spring-mvc-9.png" alt="img" style="zoom:67%;" /><ol start="5"><li><p>最后都会执行拦截器的 <strong>afterCompletion</strong> 方法 </p></li><li><p>如果控制器方法标注了 <strong>@ResponseBody</strong>  注解，则在第 2 步，就会生成 <strong>json 结果</strong>，并标记 ModelAndView 已处理，这样就不会执行第 3 步的视图渲染</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bean的生命周期</title>
      <link href="/posts/22025/"/>
      <url>/posts/22025/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁概述"><a href="#🍁概述" class="headerlink" title="🍁概述"></a>🍁概述</h2><p>Bean 的生命周期从调用 beanFactory 的 getBean 开始，到这个 bean 被销毁，可以总结为以下七个阶段：</p><ol><li>处理名称，检查缓存</li><li>处理父子容器</li><li>处理 dependsOn</li><li>选择 scope 策略</li><li><strong>创建 bean</strong></li><li>类型转换处理</li><li><strong>销毁 bean</strong></li></ol><p>对应的源代码如下(主要看注释)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数typeCheckOnly：bean实例是否包含一个类型检查</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(</span></span><br><span class="line"><span class="params">String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span></span><br><span class="line"><span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// (1.处理名称)解析bean的真正name，如果bean是工厂类，name前缀会加&amp;，需要去掉</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line">  Object beanInstance;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">  <span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">  <span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// (1.检查缓存)无参单例从缓存中获取</span></span><br><span class="line">    beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果bean实例还在创建中，则直接抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (2.处理父子容器)如果 bean definition 存在于父的bean工厂中，委派给父Bean工厂获取</span></span><br><span class="line">    <span class="type">BeanFactory</span> <span class="variable">parentBeanFactory</span> <span class="operator">=</span> getParentBeanFactory();</span><br><span class="line">    <span class="keyword">if</span> (parentBeanFactory != <span class="literal">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">      <span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">nameToLookup</span> <span class="operator">=</span> originalBeanName(name);</span><br><span class="line">      <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">            nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">        <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">        <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">      <span class="comment">// 将当前bean实例放入alreadyCreated集合里，标识这个bean准备创建了</span></span><br><span class="line">      markBeanAsCreated(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">StartupStep</span> <span class="variable">beanCreation</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationStartup.start(<span class="string">&quot;spring.beans.instantiate&quot;</span>)</span><br><span class="line">        .tag(<span class="string">&quot;beanName&quot;</span>, name);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (requiredType != <span class="literal">null</span>) &#123;</span><br><span class="line">        beanCreation.tag(<span class="string">&quot;beanType&quot;</span>, requiredType::toString);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">RootBeanDefinition</span> <span class="variable">mbd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">      checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// (3.处理dependsOn)确保它的依赖也被初始化了.</span></span><br><span class="line">      String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">      <span class="keyword">if</span> (dependsOn != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">          <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                <span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          registerDependentBean(dep, beanName);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            getBean(dep); <span class="comment">// 初始化它依赖的Bean</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                <span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建Bean实例：单例</span></span><br><span class="line">      <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 真正创建bean的方法</span></span><br><span class="line">            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">            <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">            <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">            destroySingleton(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// (5.创建Bean)创建Bean实例：原型</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">        <span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">prototypeInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          beforePrototypeCreation(beanName);</span><br><span class="line">          prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">          afterPrototypeCreation(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// (4.选择scope策略)创建Bean实例：根据bean的scope创建</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">scopeName</span> <span class="operator">=</span> mbd.getScope();</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasLength(scopeName)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No scope name defined for bean ´&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Scope</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="built_in">this</span>.scopes.get(scopeName);</span><br><span class="line">        <span class="keyword">if</span> (scope == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="type">Object</span> <span class="variable">scopedInstance</span> <span class="operator">=</span> scope.get(beanName, () -&gt; &#123;</span><br><span class="line">            beforePrototypeCreation(beanName);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">              afterPrototypeCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          beanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ScopeNotActiveException</span>(beanName, scopeName, ex);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      beanCreation.tag(<span class="string">&quot;exception&quot;</span>, ex.getClass().toString());</span><br><span class="line">      beanCreation.tag(<span class="string">&quot;message&quot;</span>, String.valueOf(ex.getMessage()));</span><br><span class="line">      cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">      beanCreation.end();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> adaptBeanInstance(name, beanInstance, requiredType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🍁阶段1-处理名称，检查缓存"><a href="#🍁阶段1-处理名称，检查缓存" class="headerlink" title="🍁阶段1  处理名称，检查缓存"></a>🍁阶段1  处理名称，检查缓存</h2><p>这一步会处理别名，将<strong>别名解析为实际名称</strong></p><p>对 FactoryBean 也会特殊处理，如果以 <strong>&amp;</strong> 开头表示要获取 FactoryBean 本身，否则表示要获取其产品</p><p>这里针对单例对象会检查<strong>一级、二级、三级</strong>缓存</p><ul><li>singletonFactories 三级缓存，存放<strong>单例工厂</strong>对象</li><li>earlySingletonObjects 二级缓存，存放<strong>单例工厂的产品</strong>对象，如果发生循环依赖，产品是<strong>代理</strong>；无循环依赖，产品是<strong>原始对象</strong></li><li>singletonObjects 一级缓存，存放<strong>单例成品</strong>对象</li></ul><h2 id="🍁阶段2-处理父子容器"><a href="#🍁阶段2-处理父子容器" class="headerlink" title="🍁阶段2  处理父子容器"></a>🍁阶段2  处理父子容器</h2><p>如果当前容器根据名字找不到这个 bean，此时若父容器存在，则<strong>执行父容器</strong>的 getBean 流程</p><p>父子容器的 bean 名称可以重复</p><h2 id="🍁阶段3-处理-dependsOn"><a href="#🍁阶段3-处理-dependsOn" class="headerlink" title="🍁阶段3  处理 dependsOn"></a>🍁阶段3  处理 dependsOn</h2><p>如果当前 bean 有通过 dependsOn 指定了<strong>非显式依赖</strong>的 bean，这一步会提前创建这些dependsOn 的 bean</p><blockquote><p>所谓非显式依赖，就是指两个 bean 之间不存在直接依赖关系，但需要控制它们的<strong>创建先后顺序</strong></p></blockquote><h2 id="🍁阶段4-选择-scope-策略"><a href="#🍁阶段4-选择-scope-策略" class="headerlink" title="🍁阶段4  选择 scope 策略"></a>🍁阶段4  选择 scope 策略</h2><p>scope理解为从xxx范围找到这个bean</p><ul><li>singleton scope表示从单例池范围内获取bean，如果没有，则创建并放入单例池</li><li>propotype scope表示从不缓存bean，每次都创建新的bean</li><li>request scope表示从request对象范围内获取bean，如果没有，则创建并放入request</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestScope</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        testRequestScope();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单例 bean 从 refresh 被创建, 到 close 被销毁, BeanFactory 会记录哪些 bean 要调用销毁方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testSingletonScope</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        context.registerBean(<span class="string">&quot;bean1&quot;</span>, Bean1.class);</span><br><span class="line">        context.registerBean(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line">        context.refresh(); <span class="comment">// getBean</span></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出：init destroy</span></span><br><span class="line">    <span class="comment">// 多例 bean 从首次 getBean 被创建, 到调用 BeanFactory 的 destroyBean 被销毁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPrototypeScope</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        context.registerBean(<span class="string">&quot;bean1&quot;</span>, Bean1.class, bd -&gt; bd.setScope(<span class="string">&quot;prototype&quot;</span>));</span><br><span class="line">        context.registerBean(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        <span class="type">Bean1</span> <span class="variable">bean</span> <span class="operator">=</span> context.getBean(Bean1.class);</span><br><span class="line">        <span class="comment">// 没谁记录该 bean 要调用销毁方法, 需要我们自行调用</span></span><br><span class="line">        context.getDefaultListableBeanFactory().destroyBean(bean);</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出：init destroy</span></span><br><span class="line">    <span class="comment">// request bean 从首次 getBean 被创建, 到 request 结束前被销毁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testRequestScope</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        context.getDefaultListableBeanFactory().registerScope(<span class="string">&quot;request&quot;</span>, <span class="keyword">new</span> <span class="title class_">RequestScope</span>());</span><br><span class="line">        context.registerBean(<span class="string">&quot;bean1&quot;</span>, Bean1.class, bd -&gt; bd.setScope(<span class="string">&quot;request&quot;</span>));</span><br><span class="line">        context.registerBean(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="type">MockHttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletRequest</span>();</span><br><span class="line">                <span class="comment">// 每个 webRequest 对象会记录哪些 bean 要调用销毁方法</span></span><br><span class="line">                <span class="type">ServletWebRequest</span> <span class="variable">webRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request);</span><br><span class="line">                RequestContextHolder.setRequestAttributes(webRequest);</span><br><span class="line"></span><br><span class="line">                <span class="type">Bean1</span> <span class="variable">bean</span> <span class="operator">=</span> context.getBean(Bean1.class);</span><br><span class="line">                LoggerUtils.get().debug(<span class="string">&quot;&#123;&#125;&quot;</span>, bean);</span><br><span class="line">                LoggerUtils.get().debug(<span class="string">&quot;&#123;&#125;&quot;</span>, request.getAttribute(<span class="string">&quot;bean1&quot;</span>));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// request 请求结束前调用这些销毁方法</span></span><br><span class="line">                webRequest.requestCompleted();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 输出：两个线程的init destroy</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            LoggerUtils.get().debug(<span class="string">&quot;&#123;&#125; - init&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PreDestroy</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">            LoggerUtils.get().debug(<span class="string">&quot;&#123;&#125; - destroy&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🍁阶段5-创建bean"><a href="#🍁阶段5-创建bean" class="headerlink" title="🍁阶段5  创建bean"></a>🍁阶段5  创建bean</h2><img src="/img/22025/bean1.png" alt="img" style="zoom:67%;" /><h3 id="5-1-创建-bean-实例"><a href="#5-1-创建-bean-实例" class="headerlink" title="5.1 创建 bean 实例"></a>5.1 创建 bean 实例</h3><table><thead><tr><th><strong>要点</strong></th><th><strong>总结</strong></th></tr></thead><tbody><tr><td>有自定义 TargetSource 的情况</td><td>由 AnnotationAwareAspectJAutoProxyCreator 创建代理返回</td></tr><tr><td>Supplier 方式创建 bean 实例</td><td>为 Spring 5.0 新增功能，方便编程方式创建  bean  实例</td></tr><tr><td>FactoryMethod 方式  创建 bean  实例</td><td>① 分成静态工厂与实例工厂；② 工厂方法若有参数，需要对工厂方法参数进行解析，利用  resolveDependency；③ 如果有多个工厂方法候选者，还要进一步按权重筛选</td></tr><tr><td><strong>AutowiredAnnotationBeanPostProcessor</strong></td><td>① 优先选择带 <strong>@Autowired</strong> 注解的构造；② 若有唯一的带参构造，也会入选</td></tr><tr><td>mbd.getPreferredConstructors</td><td>选择所有公共构造，这些构造之间按权重筛选</td></tr><tr><td><strong>采用默认构造</strong></td><td>如果上面的后处理器和 BeanDefiniation 都没找到构造，采用默认构造，即使是私有的</td></tr></tbody></table><h3 id="5-2-依赖注入"><a href="#5-2-依赖注入" class="headerlink" title="5.2 依赖注入"></a>5.2 依赖注入</h3><table><thead><tr><th><strong>要点</strong></th><th><strong>总结</strong></th></tr></thead><tbody><tr><td><strong>AutowiredAnnotationBeanPostProcessor</strong>（注解匹配）</td><td>识别  <strong>@Autowired</strong> 及 <strong>@Value</strong> 标注的成员，封装为  InjectionMetadata 进行依赖注入</td></tr><tr><td><strong>CommonAnnotationBeanPostProcessor</strong>（注解匹配）</td><td>识别  <strong>@Resource</strong> 标注的成员，封装为  InjectionMetadata 进行依赖注入</td></tr><tr><td>resolveDependency</td><td>用来查找要装配的值，可以识别：① Optional；② ObjectFactory 及 ObjectProvider；③ @Lazy 注解；④ @Value 注解（${  }, #{ }, 类型转换）；⑤ 集合类型（Collection，Map，数组等）；⑥ 泛型和  @Qualifier（用来区分类型歧义）；⑦ primary  及名字匹配（用来区分类型歧义）</td></tr><tr><td><strong>AUTOWIRE_BY_NAME</strong>（根据名字匹配）</td><td>根据成员名字找 bean 对象，修改 mbd 的 propertyValues，不会考虑简单类型的成员</td></tr><tr><td><strong>AUTOWIRE_BY_TYPE</strong>（根据类型匹配）</td><td>根据成员类型执行 resolveDependency 找到依赖注入的值，修改  mbd 的 propertyValues</td></tr><tr><td><strong>applyPropertyValues（即xml中的&lt;property name ref|value&#x2F;&gt;,精确指定）</strong></td><td>根据 mbd 的 propertyValues 进行依赖注入（即xml中 &#96;&lt;property name ref</td></tr></tbody></table><p>优先级：优先级最低：@Autowired匹配；优先级次之：AUTOWIRE_BY_NAME；优先级最高：精确指定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试如果对同一属性进行的 @Autowired 注入、AUTOWIRE_BY_NAME、精确指定注入名称, 优先级是怎样的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInjection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());</span><br><span class="line">        context.registerBean(<span class="string">&quot;bean1&quot;</span>, Bean1.class, bd -&gt; &#123;</span><br><span class="line">            <span class="comment">// 优先级最高的：精确指定注入 bean 的名称 &lt;property name=&quot;bean3&quot; ref=&quot;bean2&quot;/&gt;</span></span><br><span class="line">            bd.getPropertyValues().add(<span class="string">&quot;bean3&quot;</span>, <span class="keyword">new</span> <span class="title class_">RuntimeBeanReference</span>(<span class="string">&quot;bean2&quot;</span>));</span><br><span class="line">            <span class="comment">// 优先级次之的：通过 AUTOWIRE_BY_NAME 匹配</span></span><br><span class="line">            ((RootBeanDefinition) bd).setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_NAME);</span><br><span class="line">        &#125;);</span><br><span class="line">        context.registerBean(<span class="string">&quot;bean2&quot;</span>, Bean2.class);</span><br><span class="line">        context.registerBean(<span class="string">&quot;bean3&quot;</span>, Bean3.class);</span><br><span class="line">        context.registerBean(<span class="string">&quot;bean4&quot;</span>, Bean4.class);</span><br><span class="line"></span><br><span class="line">        context.refresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">        MyInterface bean;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 优先级最低的：@Autowired 匹配</span></span><br><span class="line">        <span class="meta">@Autowired</span> <span class="meta">@Qualifier(&quot;bean4&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBean3</span><span class="params">(MyInterface bean)</span> &#123;</span><br><span class="line">            System.out.println(bean);</span><br><span class="line">            <span class="built_in">this</span>.bean = bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean3</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean4</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-初始化"><a href="#5-3-初始化" class="headerlink" title="5.3 初始化"></a>5.3 初始化</h3><table><thead><tr><th><strong>要点</strong></th><th><strong>总结</strong></th></tr></thead><tbody><tr><td><strong>内置 Aware 接口的装配</strong></td><td>包括 BeanNameAware，BeanFactoryAware 等</td></tr><tr><td><strong>扩展 Aware 接口的装配</strong></td><td>由 ApplicationContextAwareProcessor 解析，执行时机在  postProcessBeforeInitialization</td></tr><tr><td><strong>@PostConstruct</strong></td><td>由 CommonAnnotationBeanPostProcessor 解析，执行时机在 postProcessBeforeInitialization</td></tr><tr><td><strong>InitializingBean</strong></td><td>通过接口回调执行初始化</td></tr><tr><td><strong>initMethod</strong></td><td>根据 BeanDefinition 得到的初始化方法执行初始化，即 <code>&lt;bean init-method&gt;</code>或@Bean(initMethod)</td></tr><tr><td><strong>创建 aop 代理</strong></td><td>由 AnnotationAwareAspectJAutoProxyCreator 创建，执行时机在postProcessAfterInitialization</td></tr></tbody></table><p>优先级：4-&gt;2-&gt;1-&gt;3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInitialization</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        context.registerBean(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line">        <span class="comment">// &lt;bean init-method=&quot;initMethod&quot;&gt;</span></span><br><span class="line">        context.registerBean(<span class="string">&quot;bean1&quot;</span>, Bean1.class, bd -&gt; bd.setInitMethodName(<span class="string">&quot;initMethod&quot;</span>));</span><br><span class="line">        context.refresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span>, BeanFactoryAware &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initMethod</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">            System.out.println(<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-注册可销毁bean"><a href="#5-4-注册可销毁bean" class="headerlink" title="5.4 注册可销毁bean"></a>5.4 注册可销毁bean</h3><p>在这一步判断并登记可销毁 bean</p><ul><li><p>判断依据 </p></li><li><ul><li>如果实现了 DisposableBean 或 AutoCloseable 接口，则为可销毁 bean</li><li>如果自定义了 destroyMethod，则为可销毁 bean</li><li>如果采用 @Bean  没有指定 destroyMethod，则采用自动推断方式获取销毁方法名（close，shutdown） </li><li>如果有 @PreDestroy  标注的方法</li></ul></li><li><p>存储位置 </p></li><li><ul><li>singleton scope 的可销毁 bean 会存储于 beanFactory 的成员当中</li><li>自定义 scope 的可销毁 bean 会存储于对应的域对象当中</li><li>prototype scope 不会存储，需要自己找到此对象销毁</li></ul></li><li><p>存储时都会封装为 DisposableBeanAdapter 类型对销毁方法的调用进行适配</p></li></ul><h2 id="🍁阶段6-类型转换"><a href="#🍁阶段6-类型转换" class="headerlink" title="🍁阶段6  类型转换"></a>🍁阶段6  类型转换</h2><p>如果 getBean 的 requiredType 参数与实际得到的对象类型不同，会尝试进行<strong>类型转换</strong></p><h2 id="🍁阶段7-销毁-bean"><a href="#🍁阶段7-销毁-bean" class="headerlink" title="🍁阶段7  销毁 bean"></a>🍁阶段7  销毁 bean</h2><ul><li><p>销毁时机</p></li><li><ul><li>singleton bean 的销毁在 ApplicationContext.close 时，此时会找到所有 DisposableBean 的名字，逐一销毁</li><li>自定义 scope bean 的销毁在作用域对象生命周期结束时</li><li>prototype bean 的销毁可以通过自己手动调用 AutowireCapableBeanFactory.destroyBean 方法执行销毁</li></ul></li><li><p>同一 bean 中不同形式销毁方法的调用次序 </p></li><li><ul><li>优先后处理器销毁，即 @PreDestroy  </li><li>其次 DisposableBean 接口销毁</li><li>最后 destroyMethod 销毁（包括自定义名称，推断名称，AutoCloseable 接口 多选一）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC初始化流程</title>
      <link href="/posts/57880/"/>
      <url>/posts/57880/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁IOC初始化"><a href="#🍁IOC初始化" class="headerlink" title="🍁IOC初始化"></a>🍁IOC初始化</h2><p>我们知道，在Spring中，IOC的本质是容器对bean的管理，IoC容器的接口类是ApplicationContext，容器必须调用 refresh 才能正常工作</p><h3 id="refresh源码"><a href="#refresh源码" class="headerlink" title="refresh源码"></a>refresh源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="type">StartupStep</span> <span class="variable">contextRefresh</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.refresh&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="type">StartupStep</span> <span class="variable">beanPostProcess</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.beans.post-process&quot;</span>);</span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line">            beanPostProcess.end();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            destroyBeans();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">            <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">            contextRefresh.end();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h3><p>refresh中主要会调12个方法</p><ol><li>prepareRefresh——做好准备工作</li><li>obtainFreshBeanFactory——创建或获取BeanFactory</li><li>prepareBeanFactory——准备BeanFactory</li><li>postProcessBeanFactory——子类扩展BeanFactory</li><li>invokeBeanFactoryPostProcessors ——后处理扩展BeanFactory</li><li>registerBeanPostProcessors——准备Bean后处理器</li><li>initMessageSource——为ApplicationContext提供国际化功能</li><li>initApplicationEventMulticaster——为ApplicationContext提供事件发布器</li><li>onRefresh——留给子类扩展</li><li>registerListeners——为ApplicationContext准备监听器</li><li>finishBeanFactoryInitialization——初始化单例Bean，执行Bean后处理器扩展</li><li>finishRefresh——准备生命周期管理器，发布ContextRefreshed事件</li></ol><p><strong>功能分类</strong></p><p> 【1】 为准备环境 </p><p> <strong>【2 3 4 5 6】 为准备 BeanFactory（重点）</strong> </p><p> 【7 8 9 10 12】 为准备 ApplicationContext </p><p> 【11】 为初始化 BeanFactory 中非延迟单例 bean</p><h2 id="🍁1-prepareRefresh"><a href="#🍁1-prepareRefresh" class="headerlink" title="🍁1. prepareRefresh"></a>🍁1. prepareRefresh</h2><blockquote><p>这一步创建和准备了 Environment 对象，它作为 ApplicationContext 的一个成员变量</p></blockquote><p>Environment 对象的作用之一是为后续 <strong>@Value</strong>，值注入时提供<strong>键值</strong> </p><p>Environment 分成三个主要部分</p><ul><li><ul><li>systemProperties - 保存 java 环境键值</li><li>systemEnvironment - 保存系统环境键值</li><li>自定义 PropertySource - 保存自定义键值，例如来自于 *.properties 文件的键值</li></ul></li></ul><img src="/img/57880/refresh.png" alt="img" style="zoom:67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如何获得和解析 @Value 内容</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestEnvironment</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IOException &#123;</span><br><span class="line">        <span class="comment">// 1) 获得 @Value 的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=======================&gt; 仅获取 @Value 值&quot;</span>);</span><br><span class="line">        <span class="type">QualifierAnnotationAutowireCandidateResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QualifierAnnotationAutowireCandidateResolver</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> resolver.getSuggestedValue(<span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Bean1.class.getDeclaredField(<span class="string">&quot;name&quot;</span>), <span class="literal">false</span>));</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2) 解析 @Value 的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=======================&gt; 获取 @Value 值, 并解析$&#123;&#125;&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">javaHome</span> <span class="operator">=</span> resolver.getSuggestedValue(<span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Bean1.class.getDeclaredField(<span class="string">&quot;javaHome&quot;</span>), <span class="literal">false</span>));</span><br><span class="line">        System.out.println(javaHome);</span><br><span class="line">        System.out.println(getEnvironment().resolvePlaceholders(javaHome.toString()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3) 解析 SpEL 表达式</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=======================&gt; 获取 @Value 值, 并解析#&#123;&#125;&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">expression</span> <span class="operator">=</span> resolver.getSuggestedValue(<span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Bean1.class.getDeclaredField(<span class="string">&quot;expression&quot;</span>), <span class="literal">false</span>));</span><br><span class="line">        System.out.println(expression);</span><br><span class="line">        <span class="type">String</span> <span class="variable">v1</span> <span class="operator">=</span> getEnvironment().resolvePlaceholders(expression.toString());</span><br><span class="line">        System.out.println(v1);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">StandardBeanExpressionResolver</span>().evaluate(v1, <span class="keyword">new</span> <span class="title class_">BeanExpressionContext</span>(<span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>(),<span class="literal">null</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Environment <span class="title function_">getEnvironment</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">StandardEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardEnvironment</span>();</span><br><span class="line">        env.getPropertySources().addLast(<span class="keyword">new</span> <span class="title class_">ResourcePropertySource</span>(<span class="string">&quot;jdbc&quot;</span>, <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;jdbc.properties&quot;</span>)));</span><br><span class="line">        <span class="keyword">return</span> env;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">        <span class="meta">@Value(&quot;hello&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> String javaHome;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Value(&quot;#&#123;&#x27;class version:&#x27; + &#x27;$&#123;java.class.version&#125;&#x27;&#125;&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> String expression;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🍁2-obtainFreshBeanFactory"><a href="#🍁2-obtainFreshBeanFactory" class="headerlink" title="🍁2. obtainFreshBeanFactory"></a>🍁2. obtainFreshBeanFactory</h2><blockquote><p>这一步获取（或创建） BeanFactory，它也是作为 ApplicationContext 的一个成员变量</p></blockquote><p><strong>BeanFactory 的作用是负责 bean 的创建、依赖注入和初始化，bean 的各项特征由 BeanDefinition 定义</strong> </p><ul><li><ul><li>BeanDefinition 作为 bean 的设计蓝图，规定了 bean 的特征，如单例多例、依赖关系、初始销毁方法等</li><li>BeanDefinition 的来源有多种多样，可以是通过 xml 获得、配置类获得、组件扫描获得，也可以是编程添加</li></ul></li></ul><p>所有的 BeanDefinition 会存入 BeanFactory 中的 <strong>beanDefinitionMap</strong> 集合</p><img src="/img/57880/refresh2.png" alt="img" style="zoom:67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 演示各种 BeanDefinition 的来源</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBeanDefinition</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;========================&gt; 一开始&quot;</span>);</span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line">        System.out.println(Arrays.toString(beanFactory.getBeanDefinitionNames()));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;========================&gt; 1) 从 xml 获取 &quot;</span>);</span><br><span class="line">        <span class="type">XmlBeanDefinitionReader</span> <span class="variable">reader1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(beanFactory);</span><br><span class="line">        reader1.loadBeanDefinitions(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;bd.xml&quot;</span>));</span><br><span class="line">        System.out.println(Arrays.toString(beanFactory.getBeanDefinitionNames())); </span><br><span class="line">        <span class="comment">//[bean1]</span></span><br><span class="line">        System.out.println(<span class="string">&quot;========================&gt; 2) 从配置类获取 &quot;</span>);</span><br><span class="line">        beanFactory.registerBeanDefinition(<span class="string">&quot;config1&quot;</span>, BeanDefinitionBuilder.genericBeanDefinition(Config1.class).getBeanDefinition());</span><br><span class="line">    <span class="comment">// 识别处理bean</span></span><br><span class="line">        <span class="type">ConfigurationClassPostProcessor</span> <span class="variable">postProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationClassPostProcessor</span>();</span><br><span class="line">        postProcessor.postProcessBeanDefinitionRegistry(beanFactory);</span><br><span class="line">        System.out.println(Arrays.toString(beanFactory.getBeanDefinitionNames()));</span><br><span class="line">    <span class="comment">//[bean1,config1,bean2]</span></span><br><span class="line">        System.out.println(<span class="string">&quot;========================&gt; 3) 扫描获取 &quot;</span>);</span><br><span class="line">        <span class="type">ClassPathBeanDefinitionScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(beanFactory);</span><br><span class="line">        scanner.scan(<span class="string">&quot;day04.refresh.sub&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(beanFactory.getBeanDefinitionNames()));</span><br><span class="line">        <span class="comment">//[bean1,config1,bean2,bean3,其他和包扫描相关的bean]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config1</span> &#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> Bean2 <span class="title function_">bean2</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🍁3-prepareBeanFactory"><a href="#🍁3-prepareBeanFactory" class="headerlink" title="🍁3. prepareBeanFactory"></a>🍁3. prepareBeanFactory</h2><blockquote><p>这一步会进一步<strong>完善 BeanFactory</strong>，为它的各项成员变量赋值</p></blockquote><p>beanExpressionResolver 用来解析 SpEL，常见实现为 StandardBeanExpressionResolver</p><p>propertyEditorRegistrars 会注册类型转换器 </p><ul><li><ul><li>它在这里使用了 ResourceEditorRegistrar 实现类</li><li>并应用 ApplicationContext 提供的 Environment 完成 ${ } 解析</li></ul></li></ul><p>registerResolvableDependency 来注册 beanFactory 以及 ApplicationContext，让它们也能用于依赖注入</p><p>beanPostProcessors 是 bean 后处理器集合，会工作在 bean 的生命周期各个阶段，此处会添加两个： </p><ul><li><ul><li>ApplicationContextAwareProcessor 用来解析 Aware 接口</li><li>ApplicationListenerDetector 用来识别容器中 ApplicationListener 类型的 bean</li></ul></li></ul><img src="/img/57880/refresh3.png" alt="img" style="zoom:67%;" /><h2 id="🍁4-postProcessBeanFactory"><a href="#🍁4-postProcessBeanFactory" class="headerlink" title="🍁4. postProcessBeanFactory"></a>🍁4. postProcessBeanFactory</h2><blockquote><p>这一步是空实现，留给子类扩展</p></blockquote><p>一般 Web 环境的 ApplicationContext 都要利用它注册新的 Scope，完善 Web 下的 BeanFactory</p><p>这里体现的是<strong>模板方法</strong>设计模式</p><h2 id="🍁5-invokeBeanFactoryPostProcessors"><a href="#🍁5-invokeBeanFactoryPostProcessors" class="headerlink" title="🍁5. invokeBeanFactoryPostProcessors"></a>🍁5. invokeBeanFactoryPostProcessors</h2><blockquote><p>这一步会调用 beanFactory 后处理器</p></blockquote><p>beanFactory 后处理器，充当 beanFactory 的扩展点，可以用来<strong>补充或修改</strong> BeanDefinition</p><p>常见的 beanFactory 后处理器有 </p><ul><li><ul><li><strong>ConfigurationClassPostProcessor</strong> – 解析 @Configuration、@Bean、@Import、@PropertySource  等 </li><li>PropertySourcesPlaceHolderConfigurer – 替换 BeanDefinition 中的 ${ }</li><li>MapperScannerConfigurer – 补充 Mapper 接口对应的 BeanDefinition</li></ul></li></ul><img src="/img/57880/refresh4.png" alt="img" style="zoom:67%;" /><h2 id="🍁6-registerBeanPostProcessors"><a href="#🍁6-registerBeanPostProcessors" class="headerlink" title="🍁6. registerBeanPostProcessors"></a>🍁6. registerBeanPostProcessors</h2><blockquote><p>这一步是继续从 beanFactory 中找出 bean 后处理器，添加至 beanPostProcessors 集合中</p></blockquote><p>bean 后处理器，充当 bean 的扩展点，可以工作在 bean 的实例化、依赖注入、初始化阶段，常见的有： </p><ul><li><ul><li><strong>Autowired</strong>AnnotationBeanPostProcessor 功能有：解析 <strong>@Autowired，@Value</strong>  注解 </li><li>CommonAnnotationBeanPostProcessor 功能有：解析 @Resource，@PostConstruct，@PreDestroy  </li><li>AnnotationAwareAspectJAutoProxyCreator 功能有：为符合<strong>切点的目标</strong> bean 自动创建代理</li></ul></li></ul><img src="/img/57880/refresh5.png" alt="img" style="zoom:67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> context.getDefaultListableBeanFactory();</span><br><span class="line">        beanFactory.registerBeanDefinition(<span class="string">&quot;bean1&quot;</span>, BeanDefinitionBuilder.genericBeanDefinition(Bean1.class).getBeanDefinition());</span><br><span class="line">        beanFactory.registerBeanDefinition(<span class="string">&quot;bean2&quot;</span>, BeanDefinitionBuilder.genericBeanDefinition(Bean2.class).getBeanDefinition());</span><br><span class="line">        beanFactory.registerBeanDefinition(<span class="string">&quot;bean3&quot;</span>, BeanDefinitionBuilder.genericBeanDefinition(Bean3.class).getBeanDefinition());</span><br><span class="line">        beanFactory.registerBeanDefinition(<span class="string">&quot;aspect1&quot;</span>, BeanDefinitionBuilder.genericBeanDefinition(Aspect1.class).getBeanDefinition());</span><br><span class="line">        <span class="comment">// 输出：foo(仅调用foo方法)</span></span><br><span class="line">        beanFactory.registerBeanDefinition(<span class="string">&quot;processor1&quot;</span>,</span><br><span class="line">                                           BeanDefinitionBuilder.genericBeanDefinition(AutowiredAnnotationBeanPostProcessor.class).getBeanDefinition());</span><br><span class="line">        <span class="comment">// 多输出：&quot;发生了依赖注入...&quot; + bean2</span></span><br><span class="line">        beanFactory.registerBeanDefinition(<span class="string">&quot;processor2&quot;</span>,</span><br><span class="line">                                           BeanDefinitionBuilder.genericBeanDefinition(CommonAnnotationBeanPostProcessor.class).getBeanDefinition());</span><br><span class="line">        <span class="comment">// 多输出：&quot;发生了依赖注入...&quot; + bean3</span></span><br><span class="line">        beanFactory.registerBeanDefinition(<span class="string">&quot;processor3&quot;</span>,</span><br><span class="line">                                           BeanDefinitionBuilder.genericBeanDefinition(AnnotationAwareAspectJAutoProxyCreator.class).getBeanDefinition());</span><br><span class="line">    <span class="comment">// 在foo前多输出：before...</span></span><br><span class="line">        context.refresh();</span><br><span class="line">        beanFactory.getBean(Bean1.class).foo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">        Bean2 bean2;</span><br><span class="line">        Bean3 bean3;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBean2</span><span class="params">(Bean2 bean2)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;发生了依赖注入...&quot;</span> + bean2);</span><br><span class="line">            <span class="built_in">this</span>.bean2 = bean2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Resource</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBean3</span><span class="params">(Bean3 bean3)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;发生了依赖注入...&quot;</span> + bean3);</span><br><span class="line">            <span class="built_in">this</span>.bean3 = bean3;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean3</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Aspect</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Aspect1</span> &#123;</span><br><span class="line">            <span class="meta">@Before(&quot;execution(* foo())&quot;)</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🍁7-initMessageSource"><a href="#🍁7-initMessageSource" class="headerlink" title="🍁7. initMessageSource"></a>🍁7. initMessageSource</h2><blockquote><p>这一步是为 ApplicationContext 添加 messageSource 成员，实现<strong>国际化</strong>功能</p></blockquote><p>去 beanFactory 内找名为 messageSource 的 bean，如果没有，则提供空的 MessageSource 实现</p><img src="/img/57880/refresh6.png" alt="img" style="zoom:67%;" /><h2 id="🍁8-initApplicationContextEventMulticaster"><a href="#🍁8-initApplicationContextEventMulticaster" class="headerlink" title="🍁8. initApplicationContextEventMulticaster"></a>🍁8. initApplicationContextEventMulticaster</h2><blockquote><p>这一步为 ApplicationContext 添加<strong>事件广播器</strong>成员，即 applicationContextEventMulticaster，它的作用是发布事件给监听器</p></blockquote><p>去 beanFactory 找名为 applicationEventMulticaster 的 bean 作为事件广播器，若没有，会创建默认的事件广播器</p><p>之后就可以调用 ApplicationContext.publishEvent(事件对象) 来发布事件</p><img src="/img/57880/refresh7.png" alt="img" style="zoom:67%;" /><h2 id="🍁9-onRefresh"><a href="#🍁9-onRefresh" class="headerlink" title="🍁9. onRefresh"></a>🍁9. onRefresh</h2><blockquote><p>这一步是空实现，留给子类扩展</p></blockquote><p>SpringBoot 中的子类在这里准备了 WebServer，即内嵌 web 容器(Tomcat)</p><p>体现的是模板方法设计模式</p><h2 id="🍁10-registerListeners"><a href="#🍁10-registerListeners" class="headerlink" title="🍁10. registerListeners"></a>🍁10. registerListeners</h2><blockquote><p>这一步会从多种途径找到事件监听器，并添加至 applicationEventMulticaster</p></blockquote><p>事件监听器顾名思义，用来接收事件广播器发布的事件，有如下来源 </p><ul><li><ul><li>事先编程添加的</li><li>来自容器中的 bean</li><li>来自于 @EventListener  的解析</li></ul></li></ul><p>要实现事件监听器，只需要实现 ApplicationListener 接口，重写其中 onApplicationEvent(E e) 方法即可</p><img src="/img/57880/refresh8.png" alt="img" style="zoom:67%;" /><h2 id="🍁11-finishBeanFactoryInitialization"><a href="#🍁11-finishBeanFactoryInitialization" class="headerlink" title="🍁11. finishBeanFactoryInitialization"></a>🍁11. finishBeanFactoryInitialization</h2><blockquote><p>这一步会将 beanFactory 的成员补充完毕，并初始化所有非延迟单例 bean</p></blockquote><p>conversionService 也是一套转换机制，作为对 PropertyEditor 的补充</p><p>embeddedValueResolvers 即<strong>内嵌值</strong>解析器，用来解析 @Value  中的 ${ }，借用的是 Environment 的功能 </p><p>singletonObjects 即单例池，缓存所有单例对象 </p><ul><li><ul><li>对象的创建都分三个阶段，每一阶段都有不同的 bean 后处理器参与进来，扩展功能</li></ul></li></ul><img src="/img/57880/refresh9.png" alt="img" style="zoom:67%;" /><h2 id="🍁12-finishRefresh"><a href="#🍁12-finishRefresh" class="headerlink" title="🍁12. finishRefresh"></a>🍁12. finishRefresh</h2><blockquote><p>这一步会为 ApplicationContext 添加 lifecycleProcessor 成员，用来控制容器内<strong>需要生命周期管理</strong>的 bean</p></blockquote><p>如果容器中有名称为 lifecycleProcessor 的 bean 就用它，否则创建默认的生命周期管理器</p><p>准备好生命周期管理器，就可以实现 </p><ul><li><ul><li>调用 context 的 start，即可触发所有实现 LifeCycle 接口 bean 的 start</li><li>调用 context 的 stop，即可触发所有实现 LifeCycle 接口 bean 的 stop</li></ul></li></ul><p>发布 ContextRefreshed 事件，整个 refresh 执行完成</p><img src="/img/57880/refresh10.png" alt="img" style="zoom:67%;" />]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring循环依赖</title>
      <link href="/posts/40377/"/>
      <url>/posts/40377/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁循环依赖的产生"><a href="#🍁循环依赖的产生" class="headerlink" title="🍁循环依赖的产生"></a>🍁循环依赖的产生</h2><p>bean 的创建要遵循一定的步骤，必须是<strong>创建、注入、初始化</strong>三步，顺序不能乱：</p><img src="/img/40377/ReDI1.png" alt="image-20210903085238916.png" style="zoom: 67%;" /><h3 id="set-方法（包括成员变量）的循环依赖（属性依赖）"><a href="#set-方法（包括成员变量）的循环依赖（属性依赖）" class="headerlink" title="set 方法（包括成员变量）的循环依赖（属性依赖）"></a>set 方法（包括成员变量）的循环依赖（属性依赖）</h3><p>如A中需要setB，B中需要setA，说明：</p><img src="/img/40377/ReDI2.png" alt="image-20210903085454603.png" style="zoom: 50%;" /><p>可以在【a 创建】和【a set 注入 b】之间加入 b 的整个流程来解决 ，【b set 注入 a】 时可以成功，因为之前 a 的实例已经创建完毕 ，这样 a 的顺序，及 b 的顺序都能得到保障</p><h3 id="构造方法的循环依赖"><a href="#构造方法的循环依赖" class="headerlink" title="构造方法的循环依赖"></a>构造方法的循环依赖</h3><p>A的构造函数传入B，B的构造函数传入A，说明：</p><img src="/img/40377/ReDI3.png" alt="image-20210903085906315.png" style="zoom:50%;" /><h2 id="🍁解决set循环依赖"><a href="#🍁解决set循环依赖" class="headerlink" title="🍁解决set循环依赖"></a>🍁解决set循环依赖</h2><p>Spring提供了三级缓存解决这类循环依赖问题</p><p>🚩注意：这里的一级二级三级概念不一定与Spring相同，重要的是理解流程</p><h3 id="一级缓存——singletonObjects"><a href="#一级缓存——singletonObjects" class="headerlink" title="一级缓存——singletonObjects"></a>一级缓存——singletonObjects</h3><p><strong>底层代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Cache of singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, Object&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure><p>已经实例化并且属性赋值，这里的对象是<strong>成熟对象</strong></p><p><strong>示例</strong></p><img src="/img/40377/ReDI4.png" alt="img" style="zoom:67%;" /><p>作用是保证单例对象<strong>仅被创建一次</strong></p><ul><li>第一次走 <code>getBean(&quot;a&quot;)</code> 流程后，最后会将<strong>成品</strong> a 放入 <strong>singletonObjects</strong> 一级缓存</li><li>后续再走 <code>getBean(&quot;a&quot;)</code> 流程时，<strong>先从一级缓存中找</strong>，这时已经有成品 a，就无需再次创建</li></ul><p><strong>不能解决set循环依赖的原因</strong></p><img src="/img/40377/ReDI5.png" alt="img" style="zoom:67%;" /><ul><li>无论是获取 bean a 还是获取 bean b，走的方法都是同一个 getBean 方法，假设先走 <code>getBean(&quot;a&quot;)</code></li><li>当 a 的实例对象创建，接下来执行 <code>a.setB()</code> 时，需要走 <code>getBean(&quot;b&quot;)</code> 流程，红色箭头 1</li><li>当 b 的实例对象创建，接下来执行 <code>b.setA()</code> 时，又回到了 <code>getBean(&quot;a&quot;)</code> 的流程，红色箭头 2</li><li>但此时 singletonObjects 一级缓存内<strong>没有成品</strong>的 a，陷入了死循环</li></ul><h3 id="二级缓存——singletonFactories"><a href="#二级缓存——singletonFactories" class="headerlink" title="二级缓存——singletonFactories"></a>二级缓存——singletonFactories</h3><p><strong>底层代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Cache of singleton factories: bean name --&gt; ObjectFactory */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, ObjectFactory&lt;?&gt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>单例工厂的缓存，这里的对象是<strong>半成品对象</strong></p><p><strong>示例</strong></p><img src="/img/40377/ReDI6.png" alt="img" style="zoom:67%;" /><ul><li>一级缓存不能解决set循环依赖，则再增加一个 <strong>singletonFactories</strong> 缓存</li><li>在依赖注入前，即 <code>a.setB()</code> 以及 <code>b.setA()</code> 将 a 及 b 的<strong>半成品对象</strong>（未完成依赖注入和初始化）放入此缓存</li><li>执行依赖注入时，先看看 singletonFactories 缓存中是否有<strong>半成品的对象</strong>，如果有拿来注入，顺利走完流程</li></ul><p><strong>如何解决set循环依赖</strong></p><ul><li><code>a = new A()</code> 执行之后就会把这个半成品的 a 放入 <strong>singletonFactories 缓存</strong>，即 <code>factories.put(a)</code></li><li>接下来执行 <code>a.setB()</code>，走入 <code>getBean(&quot;b&quot;)</code> 流程，红色箭头 3</li><li>这回再执行到 <code>b.setA()</code> 时，需要一个 a 对象，此时singletonFactories中有a对象</li><li><code>factories.get()</code> 在 <strong>singletonFactories  缓存</strong>中就可以找到，红色箭头 4 和 5</li><li>b 的流程能够顺利走完，将 b 成品放入 singletonObject 一级缓存，返回到 a 的依赖注入流程，红色箭头 6</li></ul><p><strong>二级缓存无法正确处理set循环依赖并且包含有代理创建的场景</strong></p><img src="/img/40377/ReDI7.png" alt="img" style="zoom:67%;" /><ul><li>spring 默认要求，在 <code>a.init</code> 完成之后才能创建代理 <code>pa = proxy(a)</code></li><li>由于 a 的代理创建时机靠后，在执行 <code>factories.put(a)</code> 向 singletonFactories 中放入的还是<strong>原始对象</strong></li><li>接下来箭头 3、4、5 这几步 b 对象拿到和注入的都是原始对象，而不是代理对象</li></ul><h3 id="三级缓存——earlySingletonObjects"><a href="#三级缓存——earlySingletonObjects" class="headerlink" title="三级缓存——earlySingletonObjects"></a>三级缓存——earlySingletonObjects</h3><p><strong>底层代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Cache of early singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>已经实例化但尚未属性赋值，这里的对象是<strong>半成品对象</strong></p><p><strong>示例</strong></p><img src="/img/40377/ReDI8.png" alt="img" style="zoom:67%;" /><p>正常分析的话，只需要将代理的创建时机放在依赖注入之前即可，但 spring 仍然希望<strong>代理的创建时机在 init 之后</strong>，只有出现循环依赖时，才会将代理的创建时机提前。所以解决思路稍显复杂：</p><ul><li>图中 <code>factories.put(fa)</code> 放入的既不是原始对象，也不是代理对象而是<strong>工厂对象 fa</strong></li><li>当检查出发生<strong>循环依赖时，fa 的产品就是代理 pa</strong>，<strong>没有发生循环依赖，fa 的产品是原始对象 a</strong></li><li>假设出现了循环依赖，拿到了 singletonFactories 中的工厂对象，通过在依赖注入前获得了 pa，红色箭头 5</li><li>这回 <code>b.setA()</code> 注入的就是代理对象，保证了正确性，红色箭头 7</li><li>还需要把 pa 存入新加的 <strong>earlySingletonObjects 缓存</strong>，红色箭头 6</li><li><code>a.init</code> 完成后，<strong>无需二次创建代理</strong>，earlySingletonObjects 已经缓存pa，蓝色箭头 9</li></ul><p>当成品对象产生，放入 singletonObject 后，singletonFactories 和 earlySingletonObjects 就中的对象就没有用处，<strong>清除即可</strong></p><p>🚩<strong>总结：一级单例，二级set，三级代理</strong></p><h2 id="🍁解决构造循环依赖"><a href="#🍁解决构造循环依赖" class="headerlink" title="🍁解决构造循环依赖"></a>🍁解决构造循环依赖</h2><blockquote><p>前面的三级缓存方案并不能解决构造循环依赖的问题，但是也有别的方案</p></blockquote><h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>思路1</p><ul><li>a 注入 <strong>b 的代理对象</strong>，这样能够保证 a 的流程走通</li><li>后续需要用到 b 的真实对象时，可以通过代理间接访问</li></ul><img src="/img/40377/ReDI9.png" alt="img" style="zoom:67%;" /><p>思路2</p><ul><li>a 注入 <strong>b 的工厂对象</strong>，让 b 的实例创建被推迟，这样能够保证 a 的流程先走通</li><li>后续需要用到 b 的真实对象时，再通过 ObjectFactory 工厂间接访问</li></ul><img src="/img/40377/ReDI10.png" alt="img" style="zoom:67%;" /><h3 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h3><p><strong>用 @Lazy 为构造方法参数生成代理（思路1）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App60_1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="keyword">private</span> B b;</span><br><span class="line">    <span class="comment">// 创建B的代理</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="meta">@Lazy</span> B b)</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;A(B b) &#123;&#125;&quot;</span>, b.getClass());</span><br><span class="line">            <span class="built_in">this</span>.b = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;B(&#123;&#125;)&quot;</span>, a);</span><br><span class="line">            <span class="built_in">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        context.registerBean(<span class="string">&quot;a&quot;</span>, A.class);</span><br><span class="line">        context.registerBean(<span class="string">&quot;b&quot;</span>, B.class);</span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());</span><br><span class="line">        context.refresh();</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h3><p><strong>用 ObjectProvider延迟依赖对象的创建（思路2）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App60_2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="keyword">private</span> ObjectProvider&lt;B&gt; b;</span><br><span class="line">    <span class="comment">// ObjectProvider是ObjectFactory的子类型</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(ObjectProvider&lt;B&gt; b)</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;A(&#123;&#125;)&quot;</span>, b);</span><br><span class="line">            <span class="built_in">this</span>.b = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;B(&#123;&#125;)&quot;</span>, a);</span><br><span class="line">            <span class="built_in">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        context.registerBean(<span class="string">&quot;a&quot;</span>, A.class);</span><br><span class="line">        context.registerBean(<span class="string">&quot;b&quot;</span>, B.class);</span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());</span><br><span class="line">        context.refresh();</span><br><span class="line">    <span class="comment">// b.getObject()获得真正的b</span></span><br><span class="line">        System.out.println(context.getBean(A.class).b.getObject());</span><br><span class="line">        System.out.println(context.getBean(B.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案3"><a href="#方案3" class="headerlink" title="方案3"></a>方案3</h3><p><strong>用 Provider 接口解决，原理上与 ObjectProvider 一样，Provider 接口是独立的 jar 包，需要加入依赖（思路2）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.inject&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javax.inject&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App60_4</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="keyword">private</span> Provider&lt;B&gt; b;</span><br><span class="line">    <span class="comment">// 和ObjectProvider一样的解决方案</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(Provider&lt;B&gt; b)</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;A(&#123;&#125;&#125;)&quot;</span>, b);</span><br><span class="line">            <span class="built_in">this</span>.b = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;B(&#123;&#125;&#125;)&quot;</span>, a);</span><br><span class="line">            <span class="built_in">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        context.registerBean(<span class="string">&quot;a&quot;</span>, A.class);</span><br><span class="line">        context.registerBean(<span class="string">&quot;b&quot;</span>, B.class);</span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());</span><br><span class="line">        context.refresh();</span><br><span class="line">    <span class="comment">// b.get()获得真正的b</span></span><br><span class="line">        System.out.println(context.getBean(A.class).b.get());</span><br><span class="line">        System.out.println(context.getBean(B.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案4"><a href="#方案4" class="headerlink" title="方案4"></a>方案4</h3><p><strong>用 @Scope 产生代理（思路1）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App60_3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        <span class="comment">// 扫描Bean工厂</span></span><br><span class="line">        <span class="type">ClassPathBeanDefinitionScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(context.getDefaultListableBeanFactory());</span><br><span class="line">        scanner.scan(<span class="string">&quot;com.itheima.app60.sub&quot;</span>);</span><br><span class="line">        context.refresh();</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 配合组件扫描</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(B b)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;A(B b) &#123;&#125;&quot;</span>, b.getClass());</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;init()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Scope(proxyMode = ScopedProxyMode.TARGET_CLASS)</span> <span class="comment">// 产生B的代理</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;B(&#123;&#125;)&quot;</span>, a);</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;init()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOP通知类型</title>
      <link href="/posts/39227/"/>
      <url>/posts/39227/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁AOP通知"><a href="#🍁AOP通知" class="headerlink" title="🍁AOP通知"></a>🍁AOP通知</h2><blockquote><p>AOP通知<strong>描述了抽取的共性功能</strong>，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置</p></blockquote><p>共有5种通知类型:</p><ul><li>前置通知</li><li>后置通知</li><li><strong>环绕通知(重点)</strong></li><li>返回后通知(了解)</li><li>抛出异常后通知(了解)</li></ul><p>图示：</p><p><img src="/img/39227/AOP1.png" alt="AOP1"></p><p>(1)<code>前置通知</code>：追加功能到方法执行前，在代码1或者代码2添加内容</p><p>(2)<code>后置通知</code>：追加功能到方法执行后，不管方法执行的过程中有没有抛出异常都会执行，在代码5添加内容</p><p>(3)<code>返回后通知</code>：追加功能到方法执行后，只有方法正常执行结束后才进行，在代码3添加内容，如果方法执行抛出异常，返回后通知将不会被添加</p><p>(4)<code>抛出异常后通知</code>：追加功能到方法抛出异常后，只有方法执行出异常才进行，在代码4添加内容，只有方法抛出异常后才会被添加</p><p>(5)<code>环绕通知</code>：环绕通知功能比较强大，它可以追加功能到方法执行的前后，这也是比较常用的方式，它可以实现其他四种通知类型的功能</p><h2 id="🍁代码演示说明"><a href="#🍁代码演示说明" class="headerlink" title="🍁代码演示说明"></a>🍁代码演示说明</h2><p>为了更好的说明几种通知，引入代码示例，在此基础上进行演示，假设其他配置都已经正常</p><p>添加BookDao和BookDaoImpl类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao update ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao select is running ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加通知类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 声明切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span> <span class="comment">// 切入点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;around before advice ...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;around after advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturning advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🍁1-前置通知"><a href="#🍁1-前置通知" class="headerlink" title="🍁1.前置通知"></a>🍁1.前置通知</h2><p>在before方法上添加<code>@Before注解</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="comment">//此处也可以写成 @Before(&quot;MyAdvice.pt()&quot;),不建议</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before advice ...</span><br><span class="line">book dao update ...</span><br></pre></td></tr></table></figure><h2 id="🍁2-后置通知"><a href="#🍁2-后置通知" class="headerlink" title="🍁2.后置通知"></a>🍁2.后置通知</h2><p>在after方法上添加<code>@After注解</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@After(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">book dao update ...</span><br><span class="line">after advice ...</span><br></pre></td></tr></table></figure><h2 id="🍁3-环绕通知"><a href="#🍁3-环绕通知" class="headerlink" title="🍁3.环绕通知"></a>🍁3.环绕通知</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ul><li>在around方法上添加<code>@Around注解</code></li><li>必须要能对原始操作进行调用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;around before advice ...&quot;</span>);</span><br><span class="line">        <span class="comment">//表示对原始操作的调用</span></span><br><span class="line">        pjp.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;around after advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before advice ...</span><br><span class="line">book dao update ...</span><br><span class="line">after advice ...</span><br></pre></td></tr></table></figure><h3 id="原始方法有返回值的处理"><a href="#原始方法有返回值的处理" class="headerlink" title="原始方法有返回值的处理"></a>原始方法有返回值的处理</h3><p>对BookDao中的select方法添加环绕通知</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(int com.itheima.dao.BookDao.select())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around(&quot;pt2()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">aroundSelect</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;around before advice ...&quot;</span>);</span><br><span class="line">        <span class="comment">//表示对原始操作的调用</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed(); <span class="comment">// 返回Object类型</span></span><br><span class="line">        System.out.println(<span class="string">&quot;around after advice ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>返回Object是Object类型更通用</p></li><li><p>在环绕通知中是可以对原始方法返回值进行修改的</p></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>环绕通知必须依赖形参ProceedingJoinPoint才能实现对原始方法的调用，进而实现原始方法调用前后同时添加通知</li><li>通知中如果未使用ProceedingJoinPoint对原始方法进行调用将<strong>跳过</strong>原始方法的执行</li><li>对原始方法的调用可以不接收返回值，通知方法设置成void即可，如果接收返回值，最好设定为Object类型</li><li>原始方法的返回值如果是void类型，通知方法的返回值类型可以设置成void,也可以设置成Object</li><li>由于无法预知原始方法运行后是否会抛出异常，因此环绕通知方法必须要处理Throwable异常</li></ol><h2 id="🍁4-返回后通知"><a href="#🍁4-返回后通知" class="headerlink" title="🍁4.返回后通知"></a>🍁4.返回后通知</h2><p>在afterReturning方法上添加<code>@AfterReturning注解</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(int com.itheima.dao.BookDao.select())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AfterReturning(&quot;pt2()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturning advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">book dao select is running ...</span><br><span class="line">afterReturning advice ...</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure><p>区别：返回后通知是需要在原始方法<code>select</code>正常执行后才会被执行，如果<code>select()</code>方法执行的过程中出现了异常，那么返回后通知是不会被执行。</p><p>​后置通知是不管原始方法有没有抛出异常都会被执行。</p><h2 id="🍁5-异常后通知"><a href="#🍁5-异常后通知" class="headerlink" title="🍁5.异常后通知"></a>🍁5.异常后通知</h2><p>在afterThrowing方法上添加<code>@AfterThrowing注解</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(int com.itheima.dao.BookDao.select())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;pt2()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// select()方法中添加一行代码int i = 1/0</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">book dao select is running ...</span><br><span class="line">afterThrowing advice ...</span><br><span class="line">Exception in main XXX(异常代码)</span><br></pre></td></tr></table></figure><h2 id="🍁通知注解总结"><a href="#🍁通知注解总结" class="headerlink" title="🍁通知注解总结"></a>🍁通知注解总结</h2><h3 id="Before"><a href="#Before" class="headerlink" title="@Before"></a>@Before</h3><table><thead><tr><th>名称</th><th>@Before</th></tr></thead><tbody><tr><td>类型</td><td>方法注解</td></tr><tr><td>位置</td><td>通知方法定义上方</td></tr><tr><td>作用</td><td>设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前运行</td></tr></tbody></table><h3 id="After"><a href="#After" class="headerlink" title="@After"></a>@After</h3><table><thead><tr><th>名称</th><th>@After</th></tr></thead><tbody><tr><td>类型</td><td>方法注解</td></tr><tr><td>位置</td><td>通知方法定义上方</td></tr><tr><td>作用</td><td>设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法后运行</td></tr></tbody></table><h3 id="AfterReturning"><a href="#AfterReturning" class="headerlink" title="@AfterReturning"></a>@AfterReturning</h3><table><thead><tr><th>名称</th><th>@AfterReturning</th></tr></thead><tbody><tr><td>类型</td><td>方法注解</td></tr><tr><td>位置</td><td>通知方法定义上方</td></tr><tr><td>作用</td><td>设置当前通知方法与切入点之间绑定关系，当前通知方法在原始切入点方法正常执行完毕后执行</td></tr></tbody></table><h3 id="AfterThrowing"><a href="#AfterThrowing" class="headerlink" title="@AfterThrowing"></a>@AfterThrowing</h3><table><thead><tr><th>名称</th><th>@AfterThrowing</th></tr></thead><tbody><tr><td>类型</td><td>方法注解</td></tr><tr><td>位置</td><td>通知方法定义上方</td></tr><tr><td>作用</td><td>设置当前通知方法与切入点之间绑定关系，当前通知方法在原始切入点方法运行抛出异常后执行</td></tr></tbody></table><h3 id="Around"><a href="#Around" class="headerlink" title="@Around"></a>@Around</h3><table><thead><tr><th>名称</th><th>@Around</th></tr></thead><tbody><tr><td>类型</td><td>方法注解</td></tr><tr><td>位置</td><td>通知方法定义上方</td></tr><tr><td>作用</td><td>设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前后运行</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringAOP</title>
      <link href="/posts/19494/"/>
      <url>/posts/19494/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁理解AOP"><a href="#🍁理解AOP" class="headerlink" title="🍁理解AOP"></a>🍁理解AOP</h2><h3 id="什么是AOP？"><a href="#什么是AOP？" class="headerlink" title="什么是AOP？"></a>什么是AOP？</h3><blockquote><p>像OOP(Object Oriented Programming)面向对象编程一样，<strong>AOP(Aspect Oriented Programming)面向切面编程</strong>，也是一种编程范式，指导开发者如何组织程序结构</p></blockquote><h3 id="AOP的作用"><a href="#AOP的作用" class="headerlink" title="AOP的作用"></a>AOP的作用</h3><blockquote><p>在不惊动原始设计的基础上为其进行<strong>功能增强</strong></p><p>实现这样的功能即<strong>代理模式</strong></p></blockquote><h3 id="AOP的核心概念"><a href="#AOP的核心概念" class="headerlink" title="AOP的核心概念"></a>AOP的核心概念</h3><p>直接解释AOP的核心概念是比较困难的，先从一个简单的案例说起：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//记录程序当前执行执行（开始时间）</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//业务执行万次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">10000</span>;i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录程序当前执行时间（结束时间）</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//计算时间差</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">totalTime</span> <span class="operator">=</span> endTime-startTime;</span><br><span class="line">        <span class="comment">//输出信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;执行万次消耗时间：&quot;</span> + totalTime + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao update ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao delete ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao select ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码是在BookDaoImpl中对<code>save</code>方法中有计算万次执行消耗的时间。</p><p>但是从容器中获取bookDao对象后，分别执行其<code>save</code>,<code>delete</code>,<code>update</code>和<code>select</code>方法，会有以下结果：</p><p><img src="/img/19494/AOP1.png" alt="AOP1"></p><p>对于计算万次执行消耗的时间只有save方法有，为什么delete和update方法也会有呢?</p><p>实际上这里就是使用了Spring的AOP，在不惊动原有设计(代码)的前提下，想给谁添加功能就给谁添加，即<code>无入侵式</code></p><p><strong>核心概念引入</strong></p><p><img src="/img/19494/AOP2.png" alt="AOP2"></p><p>(1)对上面的案例中BookServiceImpl中有<code>save</code>,<code>update</code>,<code>delete</code>和<code>select</code>方法，这些方法称为<code>连接点</code></p><p>(2)在BookServiceImpl的四个方法中，<code>update</code>和<code>delete</code>只有打印没有计算万次执行消耗时间，但是在运行的时候已经有该功能，那也就是说<code>update</code>和<code>delete</code>方法都已经被增强，所以对于需要增强的方法称为<code>切入点</code></p><p>(3)执行BookServiceImpl的update和delete方法的时候都被添加了一个计算万次执行消耗时间的功能，将这个功能抽取到一个方法中，换句话说就是<strong>存放共性功能的方法</strong>，称为<code>通知</code></p><p>(4)通知是要增强的内容，会有多个，切入点是需要被增强的方法，也会有多个，那哪个切入点需要添加哪个通知，就需要提前将它们之间的关系描述清楚，那么对于通知和切入点之间的关系描述，称为<code>切面</code></p><p>(5)通知是一个方法，方法不能独立存在需要被写在一个类中，这个类称为<code>通知类</code></p><p><strong>核心概念总结</strong></p><p>**连接点(JoinPoint)**：程序执行过程中的任意位置，粒度为执行方法、抛出异常、设置变量等</p><ul><li>在SpringAOP中，理解为方法的执行</li></ul><p>**切入点(Pointcut)**：匹配连接点的式子</p><ul><li>在SpringAOP中，一个切入点可以描述一个具体方法，也可也匹配多个方法<ul><li>一个具体的方法:如com.dao包下的BookDao接口中的无形参无返回值的save方法</li><li>匹配多个方法:所有的save方法，所有的get开头的方法，所有以Dao结尾的接口中的任意方法，所有带有一个参数的方法</li></ul></li><li>连接点范围要比切入点范围大，是切入点的方法也一定是连接点，但是是连接点的方法就不一定要被增强，所以可能不是切入点。</li></ul><p><strong>通知(Advice)</strong>:在切入点处执行的操作，也就是共性功能</p><ul><li>在SpringAOP中，功能最终以方法的形式呈现</li></ul><p><strong>通知类</strong>：定义通知的类</p><p><strong>切面(Aspect)</strong>:描述通知与切入点的对应关系。</p><h2 id="🍁AOP案例"><a href="#🍁AOP案例" class="headerlink" title="🍁AOP案例"></a>🍁AOP案例</h2><h3 id="前置说明"><a href="#前置说明" class="headerlink" title="前置说明"></a>前置说明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao update ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现有接口BookDao和其实现类BookDaoImpl</p><p>目前打印save方法的时候，因为方法中有打印系统时间，所以运行的时候是可以看到系统时间，对于update方法来说，就没有该功能。使用SpringAOP的方式在不改变update方法的前提下让其具有打印系统时间的功能。</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><p>仅说明AOP相关的配置，默认依赖等全部配置完毕</p><h4 id="1-定义通知类"><a href="#1-定义通知类" class="headerlink" title="1.定义通知类"></a>1.定义通知类</h4><p>通知就是将共性功能抽取出来后形成的方法，这里指的就是当前系统时间的打印</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类名和方法名无要求</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-定义切入点"><a href="#2-定义切入点" class="headerlink" title="2.定义切入点"></a>2.定义切入点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="comment">// 要增强的是update方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>切入点定义依托一个不具有实际意义的方法进行，即<strong>无参数、无返回值、方法体无实际逻辑</strong>。</li><li><strong>切入点表达式execution</strong>(@Pointcut中的内容)有专门的编写格式</li></ul><h4 id="3-制作切面"><a href="#3-制作切面" class="headerlink" title="3.制作切面"></a>3.制作切面</h4><p>切面是用来描述通知和切入点之间的关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// Before描述通知和切入点之间的关系</span></span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绑定切入点与通知关系，并指定通知添加到原始连接点的具体执行<code>位置</code></p><p><img src="/img/19494/AOP3.png" alt="AOP3"></p><p>🚩@Before翻译过来是之前，也就是说通知会在切入点方法执行之前执行，除此之前还有其他四种类型，这就是<code>通知类型</code></p><h4 id="4-将通知类配给容器并标识其为切面类"><a href="#4-将通知类配给容器并标识其为切面类" class="headerlink" title="4.将通知类配给容器并标识其为切面类"></a>4.将通知类配给容器并标识其为切面类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加入以下两个注解</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-开启注解格式AOP功能"><a href="#5-开启注解格式AOP功能" class="headerlink" title="5.开启注解格式AOP功能"></a>5.开启注解格式AOP功能</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="comment">// 加入此注解</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-运行App类"><a href="#6-运行App类" class="headerlink" title="6.运行App类"></a>6.运行App类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br><span class="line">        bookDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1618998676535</span><br><span class="line">book dao update ...</span><br></pre></td></tr></table></figure><p>可以看到在update方法前加入了时间戳，方法增强成功。</p><h2 id="🍁注解说明"><a href="#🍁注解说明" class="headerlink" title="🍁注解说明"></a>🍁注解说明</h2><h3 id="EnableAspectJAutoProxy"><a href="#EnableAspectJAutoProxy" class="headerlink" title="@EnableAspectJAutoProxy"></a>@EnableAspectJAutoProxy</h3><table><thead><tr><th>名称</th><th>@EnableAspectJAutoProxy</th></tr></thead><tbody><tr><td>类型</td><td>配置类注解</td></tr><tr><td>位置</td><td>配置类定义上方</td></tr><tr><td>作用</td><td>开启注解格式AOP功能</td></tr></tbody></table><h3 id="Aspect"><a href="#Aspect" class="headerlink" title="@Aspect"></a>@Aspect</h3><table><thead><tr><th>名称</th><th>@Aspect</th></tr></thead><tbody><tr><td>类型</td><td>类注解</td></tr><tr><td>位置</td><td>切面类定义上方</td></tr><tr><td>作用</td><td>设置当前类为AOP切面类</td></tr></tbody></table><h3 id="Pointcut"><a href="#Pointcut" class="headerlink" title="@Pointcut"></a>@Pointcut</h3><table><thead><tr><th>名称</th><th>@Pointcut</th></tr></thead><tbody><tr><td>类型</td><td>方法注解</td></tr><tr><td>位置</td><td>切入点方法定义上方</td></tr><tr><td>作用</td><td>设置切入点方法</td></tr><tr><td>属性</td><td>value（默认）：切入点表达式</td></tr></tbody></table><h3 id="Before"><a href="#Before" class="headerlink" title="@Before"></a>@Before</h3><table><thead><tr><th>名称</th><th>@Before</th></tr></thead><tbody><tr><td>类型</td><td>方法注解</td></tr><tr><td>位置</td><td>通知方法定义上方</td></tr><tr><td>作用</td><td>设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前运行</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注解注入比较</title>
      <link href="/posts/24359/"/>
      <url>/posts/24359/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁-Autowired"><a href="#🍁-Autowired" class="headerlink" title="🍁@Autowired"></a>🍁@Autowired</h2><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p><strong>字段属性上方</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> HelloDao helloDao;</span><br></pre></td></tr></table></figure><p><strong>set方法上方</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> HelloDao helloDao;</span><br><span class="line"><span class="keyword">public</span> HelloDao <span class="title function_">getHelloDao</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> helloDao;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHelloDao</span><span class="params">(HelloDao helloDao)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.helloDao = helloDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法形参前面</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private HelloDao helloDao;</span><br><span class="line">//@Autowired</span><br><span class="line">public HelloServiceImpl(@Autowired HelloDao helloDao) &#123;</span><br><span class="line">this.helloDao = helloDao;</span><br><span class="line">&#125;</span><br><span class="line">// 构造器注入也可不写@Autowired，也可以注入成功。</span><br></pre></td></tr></table></figure><p>🚩将@Autowired写在被注入的成员变量上，setter或者构造器上，就不用在xml文件中配置</p><h3 id="类型相同问题"><a href="#类型相同问题" class="headerlink" title="类型相同问题"></a>类型相同问题</h3><p>如果有多个类型一样的Bean候选者，则默认根据<strong>设定的属性名称</strong>进行获取。配合**@Qualifier**使用，@Qualifier(“XXX”) 中的 XX是 Bean 的名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;helloWorldDao&quot;)</span></span><br><span class="line"><span class="keyword">private</span> HelloDao helloDao;</span><br><span class="line"><span class="comment">// 发现多个HelloDao,注入名称为helloWorldDao 的Bean组件</span></span><br></pre></td></tr></table></figure><h3 id="SpringBoot中的使用"><a href="#SpringBoot中的使用" class="headerlink" title="SpringBoot中的使用"></a>SpringBoot中的使用</h3><p>使用@Bean+@Autowired进行组件注入，将@Autowired加到参数上，也可以省略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">getPerson</span><span class="params">(<span class="meta">@Autowired</span> Car car)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @Autowired可以省略</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、@Autowired是<strong>Spring自带</strong>的注解，通过AutowiredAnnotationBeanPostProcessor 类实现的依赖注入</p><p>2、@Autowired可以作用在CONSTRUCTOR、METHOD、PARAMETER、FIELD、ANNOTATION_TYPE</p><p>3、@Autowired默认是<strong>根据类型（byType ）</strong>进行自动装配的</p><p>4、如果有多个类型一样的Bean候选者，需要指定按照名称（byName ）进行装配，则需要配合**@Qualifier**</p><h2 id="🍁-Resource"><a href="#🍁-Resource" class="headerlink" title="🍁@Resource"></a>🍁@Resource</h2><h3 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperMan</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Car car;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型相同问题-1"><a href="#类型相同问题-1" class="headerlink" title="类型相同问题"></a>类型相同问题</h3><p>默认根据属性名称进行自动装配的，如果有多个类型一样的Bean候选者，则可以通过<strong>name</strong>进行指定进行注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperMan</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;BMW&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Car car;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按照属性名称 car 注入容器中的组件。如果容器中BMW还有BYD两种类型组件。指定加入BMW</span></span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>1、@Resource在javax.annotation包下</p><p>2、@Resource可以作用TYPE、FIELD、METHOD上</p><p>3、@Resource是默认根据属性名称进行自动装配的，如果有多个类型一样的Bean候选者，则可以通过name进行指定进行注入</p><h2 id="🍁-Inject-了解"><a href="#🍁-Inject-了解" class="headerlink" title="🍁@Inject(了解)"></a>🍁@Inject(了解)</h2><h3 id="使用方式-2"><a href="#使用方式-2" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inject</span></span><br><span class="line"><span class="keyword">private</span> Car car;</span><br></pre></td></tr></table></figure><h3 id="类型相同问题-2"><a href="#类型相同问题-2" class="headerlink" title="类型相同问题"></a>类型相同问题</h3><p>默认根据类型进行自动装配的，如果需要按名称进行装配，则需要配合@Named</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inject</span></span><br><span class="line"><span class="meta">@Named(&quot;BMW&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Car car;</span><br></pre></td></tr></table></figure><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>1、@Inject需要导入javax.inject.Inject jar包</p><p>2、@Inject可以作用CONSTRUCTOR、METHOD、FIELD上</p><p>3、@Inject是根据类型进行自动装配的，如果需要按名称进行装配，则需要配合@Named</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringIOC</title>
      <link href="/posts/17382/"/>
      <url>/posts/17382/</url>
      
        <content type="html"><![CDATA[<h2 id="🍁理解IOC"><a href="#🍁理解IOC" class="headerlink" title="🍁理解IOC"></a>🍁理解IOC</h2><h3 id="IOC概念"><a href="#IOC概念" class="headerlink" title="IOC概念"></a>IOC概念</h3><blockquote><p>Inversion of Control，“控制反转”，<strong>是一种设计思想</strong>。</p><p>将设计好的对象交给容器控制，而不是传统的在对象内部直接控制。</p></blockquote><p>传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象。</p><p><strong>示例：</strong></p><p>传统程序设计是主动去创建相关对象然后再组合起来：</p><p><img src="/img/17382/spring-framework-ioc-1.png" alt="spring-framework-ioc-1"></p><p>有了IoC&#x2F;DI的容器后，在客户端类中不再主动去创建这些对象：</p><p><img src="/img/17382/spring-framework-ioc-2.png" alt="spring-framework-ioc-2"></p><p>🚩<strong>优点：把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活</strong>。</p><h3 id="DI概念"><a href="#DI概念" class="headerlink" title="DI概念"></a>DI概念</h3><blockquote><p>Dependency Injection，即依赖注入：组件之间依赖关系由容器在运行期决定，即由容器动态的将某个依赖关系注入到组件之中。</p></blockquote><p>应用程序<strong>依赖</strong>于IoC容器，IoC容器<strong>注入</strong>应用程序某个对象，应用程序依赖的对象。</p><p>🚩<strong>优点：只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现</strong>。</p><p>🚩<strong>IoC是设计思想，DI是实现方式</strong></p><h2 id="🍁IOC配置的三种方式"><a href="#🍁IOC配置的三种方式" class="headerlink" title="🍁IOC配置的三种方式"></a>🍁IOC配置的三种方式</h2><h3 id="xml配置"><a href="#xml配置" class="headerlink" title="xml配置"></a>xml配置</h3><blockquote><p>将bean的信息配置.xml文件里，通过Spring加载文件为我们创建bean。</p></blockquote><p><strong>步骤：</strong></p><ol><li>配置xx.xml文件</li><li>声明命名空间和配置bean</li></ol><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string"> http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;!-- services --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;userService&quot;</span> class=<span class="string">&quot;tech.pdai.springframework.service.UserServiceImpl&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;userDao&quot;</span> ref=<span class="string">&quot;userDao&quot;</span>/&gt;</span><br><span class="line">        &lt;!-- additional collaborators and configuration <span class="keyword">for</span> <span class="built_in">this</span> bean go here --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;!-- more bean definitions <span class="keyword">for</span> services go here --&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>优点</strong>： 可以适用于任何场景，结构清晰，通俗易懂。</li><li><strong>缺点</strong>： 配置繁琐，不易维护，枯燥无味，扩展性差。</li></ul><h3 id="Java-配置"><a href="#Java-配置" class="headerlink" title="Java 配置"></a>Java 配置</h3><blockquote><p>将类的创建交给我们配置的<strong>JavaConfig类</strong>来完成，Spring只负责维护和管理。</p></blockquote><p><strong>步骤：</strong></p><ol><li>创建一个配置类， 添加**@Configuration注解**声明为配置类。</li><li>创建方法，方法上加上**@bean**，该方法用于创建实例并返回，该实例创建后会交给spring管理，方法名建议与实例名相同（首字母小写）。注：实例类不需要加任何注解。</li></ol><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeansConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> user dao</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;userDao&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserDaoImpl <span class="title function_">userDao</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> user service</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;userService&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserServiceImpl <span class="title function_">userService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UserServiceImpl</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        userService.setUserDao(userDao());</span><br><span class="line">        <span class="keyword">return</span> userService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>优点</strong>：适用于任何场景，配置方便，因为是纯Java代码，扩展性高，十分灵活。</li><li><strong>缺点</strong>：由于是采用Java类的方式，声明不明显，如果大量配置，可读性比较差。</li></ul><h3 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置"></a>注解配置</h3><blockquote><p>通过在类上加注解的方式，来声明一个类交给Spring管理，Spring会自动扫描带有**@Component，@Controller，@Service，@Repository**这四个注解的类，然后帮我们创建并管理，前提是需要先配置Spring的注解扫描器。</p></blockquote><p><strong>步骤：</strong></p><ul><li>对类添加@Component相关的注解，比如@Controller，@Service，@Repository。</li><li>设置ComponentScan的basePackage, 比如<code>&lt;context:component-scan base-package=&#39;tech.pdai.springframework&#39;&gt;</code>, 或者<code>@ComponentScan(&quot;tech.pdai.springframework&quot;)</code>注解，或者 <code>new AnnotationConfigApplicationContext(&quot;tech.pdai.springframework&quot;)</code>指定扫描的basePackage。</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * user dao impl.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDaoImpl userDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * find user list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> user list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findUserList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.findUserList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>优点</strong>：开发便捷，通俗易懂，方便维护。</li><li><strong>缺点</strong>：具有局限性，对于一些第三方资源，无法添加注解。只能采用XML或JavaConfig的方式配置。</li></ul><h2 id="🍁DI的三种方式"><a href="#🍁DI的三种方式" class="headerlink" title="🍁DI的三种方式"></a>🍁DI的三种方式</h2><h3 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h3><p><strong>步骤：</strong></p><ul><li><p>需要new UserServiceImpl()创建对象, 所以需要默认构造函数</p></li><li><p>调用setUserDao()函数注入userDao的值, 所以需要setUserDao()函数</p></li></ul><p><strong>代码：</strong></p><p>在XML配置中，property都是setter方式注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string"> http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;!-- services --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;userService&quot;</span> class=<span class="string">&quot;tech.pdai.springframework.service.UserServiceImpl&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;userDao&quot;</span> ref=<span class="string">&quot;userDao&quot;</span>/&gt;</span><br><span class="line">        &lt;!-- additional collaborators and configuration <span class="keyword">for</span> <span class="built_in">this</span> bean go here --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;!-- more bean definitions <span class="keyword">for</span> services go here --&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>对应的service类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * user dao impl.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> UserDaoImpl userDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * init.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * find user list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> user list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findUserList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.userDao.findUserList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set dao.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userDao user dao</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDaoImpl userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数注入"><a href="#构造函数注入" class="headerlink" title="构造函数注入"></a>构造函数注入</h3><p>XML配置中，<code>&lt;constructor-arg&gt;</code>是通过构造函数参数注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string"> http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;!-- services --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;userService&quot;</span> class=<span class="string">&quot;tech.pdai.springframework.service.UserServiceImpl&quot;</span>&gt;</span><br><span class="line">        &lt;constructor-arg name=<span class="string">&quot;userDao&quot;</span> ref=<span class="string">&quot;userDao&quot;</span>/&gt;</span><br><span class="line">        &lt;!-- additional collaborators and configuration <span class="keyword">for</span> <span class="built_in">this</span> bean go here --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;!-- more bean definitions <span class="keyword">for</span> services go here --&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>对应的service类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * user dao impl.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserDaoImpl userDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * init.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userDaoImpl user dao impl</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">(UserDaoImpl userDaoImpl)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDaoImpl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * find user list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> user list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findUserList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.userDao.findUserList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标签<code>&lt;constructor-arg&gt;</code>中</p><ul><li>name属性对应的值为构造函数中方法<strong>形参的参数名</strong>，必须要保持一致。</li><li>ref属性指向的是spring的IOC容器中其他bean对象。</li></ul><h3 id="注解注入（自动装配）"><a href="#注解注入（自动装配）" class="headerlink" title="注解注入（自动装配）"></a>注解注入（自动装配）</h3><p>@Autowired最常用，修饰符有三个属性：Constructor，byType，byName。默认按照<strong>byType</strong>注入。</p><ul><li><strong>constructor</strong>：通过构造方法进行自动注入，spring会匹配与构造方法参数类型一致的bean进行注入，如果有一个多参数的构造方法，一个只有一个参数的构造方法，在容器中查找到多个匹配多参数构造方法的bean，那么spring会优先将bean注入到<strong>多参数的构造方法</strong>中。</li><li><strong>byName</strong>：被注入bean的id名必须与set方法<strong>后半截匹配</strong>，并且id名称的第一个单词首字母必须小写，这一点与手动set注入有点不同。</li><li><strong>byType</strong>：查找所有的set方法，将符合参数类型的bean注入。</li></ul><p>代码：</p><p>在Service类中（在开发中最常见的情况）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * user dao impl.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDaoImpl userDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * find user list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> user list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findUserList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.findUserList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadPoolExecutor</title>
      <link href="/posts/47319/"/>
      <url>/posts/47319/</url>
      
        <content type="html"><![CDATA[<h3 id="🍁ThreadPoolExecutor简介"><a href="#🍁ThreadPoolExecutor简介" class="headerlink" title="🍁ThreadPoolExecutor简介"></a>🍁ThreadPoolExecutor简介</h3><p>先来看一个简单示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleThreadPool</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkerThread</span>(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">            executor.execute(worker);</span><br><span class="line">          &#125;</span><br><span class="line">        executor.shutdown(); <span class="comment">// This will make the executor accept no new threads and finish all existing threads in the queue</span></span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) &#123; <span class="comment">// Wait until all threads are finish,and also you can use &quot;executor.awaitTermination();&quot; to wait</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> Start. Command = <span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> Start. Command = <span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> Start. Command = <span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> Start. Command = <span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> Start. Command = <span class="number">4</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> End.</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> End.</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> End.</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> End.</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> Start. Command = <span class="number">8</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> End.</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> Start. Command = <span class="number">9</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> Start. Command = <span class="number">7</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> Start. Command = <span class="number">6</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> Start. Command = <span class="number">5</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> End.</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> End.</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> End.</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> End.</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> End.</span><br><span class="line">Finished all threads</span><br></pre></td></tr></table></figure><p>程序创建了固定大小为5个工作线程的线程池。然后分配给线程池10个工作，因为线程池大小为5，它将启动5个工作线程先处理5个工作，其他的工作则处于等待状态，一旦有工作完成，空闲下来工作线程就会捡取等待队列里的其他工作进行执行。</p><h3 id="🍁七个参数"><a href="#🍁七个参数" class="headerlink" title="🍁七个参数"></a>🍁七个参数</h3><img src="/img/47319/ThreadPoolExecuter.png" alt="ThreadPoolExecuter" style="zoom:67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure><p><code>corePoolSize</code> 线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize, 即使有其他空闲线程能够执行新来的任务, 也会继续创建线程；如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。<strong>核心线程数目可以为0</strong></p><p><code>workQueue</code> 用来保存等待被执行的任务的阻塞队列. 在JDK中提供了如下阻塞队列: </p><p>​<code>ArrayBlockingQueue</code>: 基于数组结构的有界阻塞队列，按FIFO排序任务；</p><p>​<code>LinkedBlockingQueue</code>: 基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQueue；</p><p>​<code>SynchronousQueue</code>: 一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue；</p><p>​<code>PriorityBlockingQueue</code>: 具有优先级的无界阻塞队列；</p><p><code>maximumPoolSize </code> 线程池中允许的最大线程数，<strong>核心线程+救急线程</strong>的最大数目。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize；当阻塞队列是无界队列, 则maximumPoolSize则不起作用, 因为无法提交至核心线程池的线程会一直持续地放入workQueue.</p><p><code>keepAliveTime </code> 线程空闲时的存活时间，即当线程没有任务执行时，该线程继续存活的时间；默认情况下，该参数只在线程数大于corePoolSize时才有用, 超过这个时间的空闲线程将被终止；</p><p><code>unit </code> keepAliveTime的单位</p><p><code>threadFactory </code> 创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名。默认为DefaultThreadFactory</p><p><code>handler </code> 线程池的<strong>饱和策略</strong>，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略:</p><p>​<code>AbortPolicy</code>: 直接抛出异常，默认策略；</p><p>​<code>CallerRunsPolicy</code>: 用调用者所在的线程来执行任务；</p><p>​<code>DiscardOldestPolicy</code>: 丢弃阻塞队列中靠最前的任务，并执行当前任务；</p><p>​<code>DiscardPolicy</code>: 直接丢弃任务；</p><h3 id="🍁Execute原理"><a href="#🍁Execute原理" class="headerlink" title="🍁Execute原理"></a>🍁Execute原理</h3><p>当一个任务提交至线程池之后:</p><ol><li>线程池首先当前运行的线程数量是否少于corePoolSize。如果是，则创建一个新的工作线程来执行任务。如果都在执行任务，则进入2.</li><li>判断BlockingQueue是否已经满了，倘若还没有满，则将线程放入BlockingQueue。否则进入3.</li><li>如果创建一个新的工作线程将使当前运行的线程数量超过maximumPoolSize，则交给RejectedExecutionHandler来处理任务。</li></ol><h3 id="🍁三种类型"><a href="#🍁三种类型" class="headerlink" title="🍁三种类型"></a>🍁三种类型</h3><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池的线程数量达corePoolSize后，即使线程池没有可执行任务时，也不会释放线程。</p><p>FixedThreadPool的工作队列为无界队列LinkedBlockingQueue(队列容量为Integer.MAX_VALUE), 这会导致以下问题:</p><ul><li>线程池里的线程数量不超过corePoolSize,这导致了maximumPoolSize和keepAliveTime将会是个无用参数</li><li>由于使用了无界队列, 所以FixedThreadPool永远不会拒绝, 即饱和策略失效</li></ul><h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化的线程池中只有一个线程，如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行。</p><p>由于使用了无界队列, 所以SingleThreadPool永远不会拒绝, 即饱和策略失效</p><h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                    <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池的线程数可达到Integer.MAX_VALUE，内部使用SynchronousQueue作为阻塞队列； 和newFixedThreadPool创建的线程池不同，newCachedThreadPool在没有任务执行时，当线程的空闲时间超过keepAliveTime，会自动释放线程资源，当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销； 执行过程与前两种稍微不同:</p><ul><li>主线程调用SynchronousQueue的offer()方法放入task, 倘若此时线程池中有空闲的线程尝试读取 SynchronousQueue的task, 即调用了SynchronousQueue的poll(), 那么主线程将该task交给空闲线程. 否则执行(2)</li><li>当线程池为空或者没有空闲的线程, 则创建新的线程执行任务.</li><li>执行完任务的线程倘若在60s内仍空闲, 则会被终止. 因此长时间空闲的CachedThreadPool不会持有任何线程资源</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的锁</title>
      <link href="/posts/51432/"/>
      <url>/posts/51432/</url>
      
        <content type="html"><![CDATA[<h3 id="🍁总览"><a href="#🍁总览" class="headerlink" title="🍁总览"></a>🍁总览</h3><p>Java中往往是按照是否含有某一特性来定义锁，如下图所示：</p><img src="/img/51432/java-lock-1.png" alt="java-lock-1" style="zoom: 67%;" /><h3 id="🍁乐观锁-VS-悲观锁"><a href="#🍁乐观锁-VS-悲观锁" class="headerlink" title="🍁乐观锁 VS 悲观锁"></a>🍁乐观锁 VS 悲观锁</h3><blockquote><p>对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候<strong>会先加锁</strong>，确保数据不会被别的线程修改。<strong>synchronized关键字和Lock的实现类</strong>都是悲观锁。</p><p>而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以<strong>不会添加锁</strong>，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。最常采用的是<strong>CAS算法</strong>实现。</p></blockquote><img src="/img/51432/java-lock-2.png" alt="java-lock-2" style="zoom: 50%;" /><ul><li><strong>悲观锁适合写操作多的场景</strong>，先加锁可以保证写操作时数据正确。</li><li><strong>乐观锁适合读操作多的场景</strong>，不加锁的特点能够使其读操作的性能大幅提升。</li></ul><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// ------------------------- 悲观锁的调用方式 -------------------------</span><br><span class="line">// synchronized</span><br><span class="line">public synchronized void testMethod() &#123;</span><br><span class="line">// 操作同步资源</span><br><span class="line">&#125;</span><br><span class="line">// ReentrantLock</span><br><span class="line">private ReentrantLock lock = new ReentrantLock(); // 需要保证多个线程使用的是同一个锁</span><br><span class="line">public void modifyPublicResources() &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">// 操作同步资源</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ------------------------- 乐观锁的调用方式 -------------------------</span><br><span class="line">private AtomicInteger atomicInteger = new AtomicInteger();  // 需要保证多个线程使用的是同一个AtomicInteger</span><br><span class="line">atomicInteger.incrementAndGet(); //执行自增1</span><br></pre></td></tr></table></figure><h3 id="🍁自旋锁-VS-非自旋锁"><a href="#🍁自旋锁-VS-非自旋锁" class="headerlink" title="🍁自旋锁 VS 非自旋锁"></a>🍁自旋锁 VS 非自旋锁</h3><p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p><p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程<strong>不放弃CPU的执行时间</strong>，看看持有锁的线程是否很快就会释放锁。</p><blockquote><p>而为了让当前线程“稍等一下”，我们需让当前线程进行<strong>自旋</strong>，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就<strong>可以不必阻塞而是直接获取同步资源</strong>，从而避免切换线程的开销。这就是<strong>自旋锁</strong>。</p></blockquote><img src="/img/51432/java-lock-4.png" alt="java-lock-4" style="zoom:50%;" /><h3 id="🍁无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁"><a href="#🍁无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁" class="headerlink" title="🍁无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁"></a>🍁无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</h3><p>这四种锁是专门针对synchronized的。</p><p>无锁 –&gt; 偏向锁 –&gt; 轻量级锁 –&gt; 重量级锁</p><blockquote><p>偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。轻量级锁通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。</p></blockquote><h3 id="🍁公平锁-VS-非公平锁"><a href="#🍁公平锁-VS-非公平锁" class="headerlink" title="🍁公平锁 VS 非公平锁"></a>🍁公平锁 VS 非公平锁</h3><blockquote><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的<strong>第一个线程才能获得锁</strong>。</p><p>优点：等待锁的线程不会饿死。</p><p>缺点：整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p><hr><p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以<strong>无需阻塞直接获取到锁</strong>，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。</p><p>优点：可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。</p><p>缺点：处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p></blockquote><p>示例：</p><img src="/img/51432/java-lock-7.png" alt="java-lock-7" style="zoom:50%;" /><p>假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。</p><img src="/img/51432/java-lock-8.png" alt="java-lock-8" style="zoom:50%;" /><p>对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。</p><h3 id="🍁可重入锁-VS-非可重入锁"><a href="#🍁可重入锁-VS-非可重入锁" class="headerlink" title="🍁可重入锁 VS 非可重入锁"></a>🍁可重入锁 VS 非可重入锁</h3><blockquote><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再<strong>进入该线程的内层方法会自动获取锁</strong>（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中<strong>ReentrantLock和synchronized</strong>都是可重入锁。</p></blockquote><p>可重入锁的一个优点是可一定程度避免死锁。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法1执行...&quot;</span>);</span><br><span class="line">        doOthers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doOthers</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法2执行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解释</span></span><br><span class="line">类中的两个方法都是被内置锁<span class="keyword">synchronized</span>修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作</span><br><span class="line">如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁</span><br></pre></td></tr></table></figure><p>示例：</p><img src="/img/51432/java-lock-12.png" alt="java-lock-12" style="zoom:50%;" /><p>假设有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。</p><img src="/img/51432/java-lock-13.png" alt="java-lock-13" style="zoom:50%;" /><p>但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。</p><h3 id="🍁独享锁-排他锁-VS-共享锁"><a href="#🍁独享锁-排他锁-VS-共享锁" class="headerlink" title="🍁独享锁(排他锁) VS 共享锁"></a>🍁独享锁(排他锁) VS 共享锁</h3><blockquote><p><strong>独享锁也叫排他锁</strong>，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。<strong>JDK中的synchronized和JUC中Lock的实现类就是互斥锁</strong>。</p><p><strong>共享锁</strong>是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程<strong>只能读数据，不能修改数据</strong>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile</title>
      <link href="/posts/27530/"/>
      <url>/posts/27530/</url>
      
        <content type="html"><![CDATA[<h3 id="🍁volatile简介"><a href="#🍁volatile简介" class="headerlink" title="🍁volatile简介"></a>🍁volatile简介</h3><p>线程安全产生的三个主要的问题是：原子性、可见性和有序性。volatile关键字可以<strong>解决可见性和有序性</strong>，但<strong>不能解决原子性</strong>。</p><h3 id="🍁原子性（×）"><a href="#🍁原子性（×）" class="headerlink" title="🍁原子性（×）"></a>🍁原子性（×）</h3><blockquote><p>多线程下，不同线程的<strong>指令发生了交错</strong>导致的共享变量的读写混乱</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如对于一个减法操作，有可能由三个指令组成，操作时需要保证三指令一致</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">subtract</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> balance;</span><br><span class="line">    b -= <span class="number">5</span>;</span><br><span class="line">    balance = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>volatile 并不能解决原子性</strong>，用悲观锁或乐观锁解决</p><h3 id="🍁可见性（√）"><a href="#🍁可见性（√）" class="headerlink" title="🍁可见性（√）"></a>🍁可见性（√）</h3><blockquote><p>由于编译器优化、或缓存优化、或 CPU 指令重排序优化导致的<strong>对共享变量所做的修改另外的线程看不到</strong></p></blockquote><p>用 volatile 修饰共享变量，能够<strong>防止编译器等优化</strong>发生，让一个线程对共享变量的修改对另一个线程可见</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForeverLoop</span> &#123;</span><br><span class="line">    <span class="comment">// volatile 修饰共享变量，能够防止编译器等优化发生</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">            get().debug(<span class="string">&quot;modify stop to true...&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            get().debug(<span class="string">&quot;&#123;&#125;&quot;</span>, stop);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            get().debug(<span class="string">&quot;&#123;&#125;&quot;</span>, stop);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        foo();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 如果while循环了特别多次（几百万次），超过了jit的阈值，便认为这个条件一直不变</span></span><br><span class="line">    <span class="comment">// 比如这里的！stop一直认为是true</span></span><br><span class="line">    <span class="comment">// 用volatile修饰stop可以防止编译器优化进而解决线程的可见性问题</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        get().debug(<span class="string">&quot;stopped... c:&#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🍁有序性（√）"><a href="#🍁有序性（√）" class="headerlink" title="🍁有序性（√）"></a>🍁有序性（√）</h3><blockquote><p>由于编译器优化、或缓存优化、或 CPU 指令重排序优化导致指令的<strong>实际执行顺序与编写顺序不一致</strong></p></blockquote><p>用 volatile 修饰共享变量会在读、写共享变量时加入不同的<strong>屏障</strong>，阻止其他读写操作越过屏障，从而达到<strong>阻止重排序</strong>的效果</p><ul><li>volatile <strong>变量写</strong>加的屏障是阻止上方其它写操作越过屏障排到 volatile 变量写<strong>之下</strong></li><li>volatile <strong>变量读</strong>加的屏障是阻止下方其它读操作越过屏障排到 volatile 变量读<strong>之上</strong></li><li>volatile 读写加入的屏障只能防止同一线程内的指令重排</li></ul><p>🚩关键字：上读下写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JCStressTest</span></span><br><span class="line"><span class="meta">@Outcome(id = &#123;&quot;0, 0&quot;, &quot;1, 1&quot;, &quot;0, 1&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ACCEPTABLE&quot;)</span></span><br><span class="line"><span class="meta">@Outcome(id = &quot;1, 0&quot;, expect = Expect.FORBIDDEN, desc = &quot;FORBIDDEN&quot;)</span></span><br><span class="line"><span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Case2</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">()</span> &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// volatile修饰的y,写加的屏障是阻止上方其它写操作越过屏障</span></span><br><span class="line">        <span class="comment">// ^^^^^^^^^^^^^^</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(II_Result r)</span> &#123;</span><br><span class="line">        r.r1 = y;</span><br><span class="line">        <span class="comment">// volatile修饰的y,读加的屏障是阻止下方其它读操作越过屏障</span></span><br><span class="line">        <span class="comment">// VVVVVVVVVVVVVV</span></span><br><span class="line">        r.r2 = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🍁场景示例"><a href="#🍁场景示例" class="headerlink" title="🍁场景示例"></a>🍁场景示例</h3><p>单例模式的实现之一：<strong>懒汉式双检锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            syschronized(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：</p><p>实例化一个对象可以分为三个步骤：</p><ol><li>分配内存空间</li><li>初始化对象</li><li>将内存空间的地址赋值给对应的引用</li></ol><p>由于操作系统可以<code>对指令进行重排序</code> ，可能将一个未初始化的对象引用暴露出来。给私有的静态变量加上volatile关键字就可以防止指令重排序</p>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC总览</title>
      <link href="/posts/64049/"/>
      <url>/posts/64049/</url>
      
        <content type="html"><![CDATA[<h3 id="🍁JUC简介"><a href="#🍁JUC简介" class="headerlink" title="🍁JUC简介"></a>🍁JUC简介</h3><blockquote><p><strong>java.util.concurrent</strong> （JUC）并发编程包是专门为 Java 并发编程设计的</p></blockquote><p>JUC包提供了五大方面的内容：</p><p>锁（locks）部分：提供适合各类场合的锁工具；<br>原子变量（atomic）部分：原子变量类相关，是构建非阻塞算法的基础；<br>并发框架（executor）部分：提供线程池相关类型；<br>并发容器（collections） 部分：提供一系列并发容器相关类型；<br>同步工具（tools）部分：提供相对独立，且场景丰富的各类同步工具，如信号量、闭锁、栅栏等功能；</p><p><img src="/img/64049/java-thread-x-juc-overview.png" alt="java-thread-x-juc-overview"></p><h3 id="🍁Lock框架和Tools类"><a href="#🍁Lock框架和Tools类" class="headerlink" title="🍁Lock框架和Tools类"></a>🍁Lock框架和Tools类</h3><h4 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h4><p><img src="/img/64049/java-thread-x-juc-overview-lock.png" alt="java-thread-x-juc-overview-lock"></p><h4 id="接口-Condition"><a href="#接口-Condition" class="headerlink" title="接口: Condition"></a>接口: Condition</h4><p>Lock 替代了 <strong>synchronized</strong> 方法和语句的使用，Condition 替代了 Object 监视器方法(wait、notify 和 notifyAll)的使用。可以通过**await(),signal()**来休眠&#x2F;唤醒线程。</p><hr><h4 id="接口-Lock"><a href="#接口-Lock" class="headerlink" title="接口: Lock"></a>接口: Lock</h4><p>Lock实现提供了比使用synchronized方法和语句可获得的<strong>更广泛的锁定操作</strong>。此实现允许更灵活的结构，可以支持多个相关的Condition对象。</p><hr><h4 id="接口-ReadWriteLock"><a href="#接口-ReadWriteLock" class="headerlink" title="接口: ReadWriteLock"></a>接口: ReadWriteLock</h4><p>维护了<strong>一对</strong>相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 writer，读取锁可以由多个 reader 线程同时保持。写入锁是独占的。</p><hr><h4 id="锁常用类-LockSupport"><a href="#锁常用类-LockSupport" class="headerlink" title="锁常用类: LockSupport"></a>锁常用类: LockSupport</h4><p>用来创建锁和其他同步类的<strong>基本线程阻塞原语</strong>。LockSupport的功能和Thread中的 Thread.suspend()和Thread.resume()有点类似，LockSupport中的<strong>park() 和 unpark()</strong> 的作用分别是阻塞线程和解除阻塞线程。但是park()和unpark()不会遇到Thread.suspend 和 Thread.resume所可能引发的死锁问题。</p><hr><h4 id="🎈锁常用类-ReentrantLock"><a href="#🎈锁常用类-ReentrantLock" class="headerlink" title="🎈锁常用类: ReentrantLock"></a>🎈锁常用类: ReentrantLock</h4><p>一个可重入的互斥锁 Lock，它具有与使用 <strong>synchronized</strong> 方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。</p><hr><h4 id="锁常用类-ReentrantReadWriteLock"><a href="#锁常用类-ReentrantReadWriteLock" class="headerlink" title="锁常用类: ReentrantReadWriteLock"></a>锁常用类: ReentrantReadWriteLock</h4><p>ReentrantReadWriteLock是读写锁接口<strong>ReadWriteLock的实现类</strong>，它包括Lock子类ReadLock和WriteLock。ReadLock是共享锁，WriteLock是独占锁。</p><h3 id="🍁Collections-并发集合"><a href="#🍁Collections-并发集合" class="headerlink" title="🍁Collections: 并发集合"></a>🍁Collections: 并发集合</h3><h4 id="总览-1"><a href="#总览-1" class="headerlink" title="总览"></a>总览</h4><p><img src="/img/64049/java-thread-x-juc-overview-collections.png" alt="java-thread-x-juc-overview-collections"></p><h4 id="🎈Map-ConcurrentHashMap"><a href="#🎈Map-ConcurrentHashMap" class="headerlink" title="🎈Map: ConcurrentHashMap"></a>🎈Map: ConcurrentHashMap</h4><p>线程安全的HashMap。ConcurrentHashMap在JDK 7之前是通过Lock和segment(分段锁)实现，JDK 8 之后改为CAS+synchronized来保证并发安全。</p><hr><h4 id="List-CopyOnWriteArrayList"><a href="#List-CopyOnWriteArrayList" class="headerlink" title="List: CopyOnWriteArrayList"></a>List: CopyOnWriteArrayList</h4><p>ArrayList 的一个线程安全的变体，其中所有可变操作(add、set 等等)都是通过对底层数组进行一次新的复制来实现的，开销大。</p><p>1.当遍历操作的数量大大超过可变操作的数量时，这种方法可能比其他替代方法更有效。</p><p>2.在不能或不想进行同步遍历，但又需要从并发线程中排除冲突时，也很有用</p><h3 id="🍁Atomic-原子类"><a href="#🍁Atomic-原子类" class="headerlink" title="🍁Atomic: 原子类"></a>🍁Atomic: 原子类</h3><h4 id="总览-2"><a href="#总览-2" class="headerlink" title="总览"></a>总览</h4><p>其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由JVM从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。实际上是借助硬件的相关指令来实现的，不会阻塞线程</p><h4 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h4><p>乐观锁的典型代表</p><h3 id="🍁Executors-线程池"><a href="#🍁Executors-线程池" class="headerlink" title="🍁Executors: 线程池"></a>🍁Executors: 线程池</h3><h4 id="总览-3"><a href="#总览-3" class="headerlink" title="总览"></a>总览</h4><p><img src="/img/64049/java-thread-x-juc-executors.png" alt="java-thread-x-juc-executors"></p><h4 id="接口-Executor"><a href="#接口-Executor" class="headerlink" title="接口: Executor"></a>接口: Executor</h4><p>Executor接口提供一种将任务提交与每个任务将如何运行的<strong>机制</strong>(包括线程使用的细节、调度等)分离开来的方法。通常使用 Executor 而不是显式地创建线程。</p><hr><h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><p>FutureTask 为 Future 提供了基础实现，如获取任务执行结果(get)和取消任务(cancel)等。如果任务尚未完成，获取任务执行结果时将会阻塞。一旦执行结束，任务就不能被重启或取消(除非使用runAndReset执行计算)。FutureTask 常用来封装 Callable 和 Runnable，也可以作为一个任务提交到线程池中执行。除了作为一个独立的类之外，此类也提供了一些功能性函数供我们创建自定义 task 类使用。FutureTask 的线程安全由<strong>CAS</strong>来保证。</p><hr><h4 id="🎈ThreadPoolExecutor"><a href="#🎈ThreadPoolExecutor" class="headerlink" title="🎈ThreadPoolExecutor"></a>🎈ThreadPoolExecutor</h4><p>ThreadPoolExecutor实现了AbstractExecutorService接口，也是一个 ExecutorService，它使用可能的几个池线程之一执行每个提交的任务，通常使用 Executors 工厂方法配置。 线程池可以解决两个不同问题: 由于减少了每个任务调用的开销，它们通常可以在执行大量异步任务时提供增强的性能，并且还可以提供绑定和管理资源(包括执行任务集时使用的线程)的方法。每个 ThreadPoolExecutor 还维护着一些基本的统计数据，如完成的任务数。</p><hr><h4 id="核心-ScheduledThreadExecutor"><a href="#核心-ScheduledThreadExecutor" class="headerlink" title="核心: ScheduledThreadExecutor"></a>核心: ScheduledThreadExecutor</h4><p>ScheduledThreadPoolExecutor实现ScheduledExecutorService接口，可安排在给定的延迟后运行命令，或者定期执行命令。需要多个辅助线程时，或者要求 ThreadPoolExecutor 具有<strong>额外的灵活性或功能</strong>时。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程使用方式</title>
      <link href="/posts/58290/"/>
      <url>/posts/58290/</url>
      
        <content type="html"><![CDATA[<h3 id="🍁实现Runnable接口"><a href="#🍁实现Runnable接口" class="headerlink" title="🍁实现Runnable接口"></a>🍁实现Runnable接口</h3><p>需要实现run()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 Thread 调用 <strong>start()</strong> 方法来启动线程:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyRunnable</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instance);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上是把线程和任务分开了</p><h3 id="🍁实现Callable接口"><a href="#🍁实现Callable接口" class="headerlink" title="🍁实现Callable接口"></a>🍁实现Callable接口</h3><p>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="type">MyCallable</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">    <span class="comment">// 利用FutureTask封装返回值</span></span><br><span class="line">    FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(mc);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🍁继承-Thread-类"><a href="#🍁继承-Thread-类" class="headerlink" title="🍁继承 Thread 类"></a>🍁继承 Thread 类</h3><p>也是需要实现 <strong>run()</strong> 方法，因为 Thread 类也实现了 Runable 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">    mt.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当调用 <strong>start()</strong> 方法启动一个线程时，虚拟机会将该线程放入<strong>就绪队列</strong>中等待被调度，当一个线程被调度时会执行该线程的 <strong>run()</strong> 方法</p></blockquote><h3 id="🍁实现接口方式比较继承方式"><a href="#🍁实现接口方式比较继承方式" class="headerlink" title="🍁实现接口方式比较继承方式"></a>🍁实现接口方式比较继承方式</h3><p>实现接口更好:</p><ul><li>Java 不支持多继承，继承了 Thread 类就无法继承其它类，但是可以实现多个接口</li><li>实现接口可能只要求可执行就行，继承整个 Thread 类开销过大</li><li>Runnable 更容易与线程池等高级 API 配合</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程状态</title>
      <link href="/posts/3d00/"/>
      <url>/posts/3d00/</url>
      
        <content type="html"><![CDATA[<h3 id="🍁线程6种状态"><a href="#🍁线程6种状态" class="headerlink" title="🍁线程6种状态"></a>🍁线程6种状态</h3><p><img src="/img/3d00/ThreadStatus.png" alt="ThreadStatus"></p><h4 id="新建-New"><a href="#新建-New" class="headerlink" title="新建(New)"></a>新建(New)</h4><p>​当一个线程对象被创建，但还未调用 <strong>start 方法</strong>时处于新建状态,  此时未与操作系统底层线程关联</p><h4 id="可运行-Runnable"><a href="#可运行-Runnable" class="headerlink" title="可运行(Runnable)"></a>可运行(Runnable)</h4><p>​调用了 start 方法，就会由新建进入可运行</p><p>​可能正在运行，也可能正在等待 CPU 时间片。包含了操作系统线程状态中的 <strong>Running 和 Ready</strong></p><h4 id="死亡-Terminated"><a href="#死亡-Terminated" class="headerlink" title="死亡(Terminated)"></a>死亡(Terminated)</h4><p>​可以是线程结束任务之后自己结束，或者产生了异常而结束</p><h4 id="阻塞-Blocking"><a href="#阻塞-Blocking" class="headerlink" title="阻塞(Blocking)"></a>阻塞(Blocking)</h4><p>​当获取锁失败后，由可运行进入 Monitor 的阻塞队列阻塞，此时不占用 cpu 时间<br>​当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的阻塞线程，唤醒后的线程进入可运行状态</p><h4 id="无限期等待-Waiting"><a href="#无限期等待-Waiting" class="headerlink" title="无限期等待(Waiting)"></a>无限期等待(Waiting)</h4><p>​等待其它线程显式地唤醒，否则不会被分配 CPU 时间片</p><table><thead><tr><th align="center">常见进入方法</th><th align="center">常见退出方法</th></tr></thead><tbody><tr><td align="center">没有设置 Timeout 参数的 Object.wait() 方法</td><td align="center">Object.notify() &#x2F; Object.notifyAll()</td></tr><tr><td align="center">没有设置 Timeout 参数的 Thread.join() 方法</td><td align="center">被调用的线程执行完毕</td></tr></tbody></table><h4 id="限期等待-Timed-Waiting"><a href="#限期等待-Timed-Waiting" class="headerlink" title="限期等待(Timed Waiting)"></a>限期等待(Timed Waiting)</h4><p>​无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒</p><table><thead><tr><th align="center">常见进入方法</th><th align="center">常见退出方法</th></tr></thead><tbody><tr><td align="center">Thread.sleep() 方法</td><td align="center">时间结束</td></tr><tr><td align="center">设置了 Timeout 参数的 Object.wait() 方法</td><td align="center">时间结束 &#x2F; Object.notify() &#x2F; Object.notifyAll()</td></tr><tr><td align="center">设置了 Timeout 参数的 Thread.join() 方法</td><td align="center">时间结束 &#x2F; 被调用的线程执行完毕</td></tr></tbody></table><blockquote><p>阻塞和等待的区别：阻塞是被动的，它是在等待获取一个排它锁；而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入</p></blockquote><h3 id="🍁wait-vs-sleep"><a href="#🍁wait-vs-sleep" class="headerlink" title="🍁wait vs sleep"></a>🍁wait vs sleep</h3><h4 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h4><p>​wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入<strong>阻塞状态</strong></p><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><p>●  方法归属不同<br>    sleep(long) 是 <strong>Thread</strong> 的静态方法<br>    而 wait()，wait(long) 都是 <strong>Object</strong> 的成员方法，每个对象都有<br>●  醒来时机不同<br>    执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来<br>    wait(long) 和 wait() 还可以被 <strong>notify</strong> 唤醒，wait() 如果不唤醒就一直等下去<br>    它们都可以被打断唤醒<br>●  锁特性不同（重点）<br>    wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制<br>    wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃 cpu，但你们还可以用）<br>    而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（我放弃 cpu，你们也用不了）</p><blockquote><p><strong>wait扔掉锁睡觉，sleep抱着锁睡觉</strong></p></blockquote><h3 id="🍁线程间的协作"><a href="#🍁线程间的协作" class="headerlink" title="🍁线程间的协作"></a>🍁线程间的协作</h3><blockquote><p>当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调</p></blockquote><h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><p>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">        B(A a) &#123;</span><br><span class="line">            <span class="built_in">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                a.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(a);</span><br><span class="line">        b.start();</span><br><span class="line">        a.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure><p>解释：</p><p>虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 <strong>join()</strong> 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够<strong>保证 a 线程的输出先于 b 线程的输出</strong></p><h4 id="wait-x2F-notify-x2F-notifyAll"><a href="#wait-x2F-notify-x2F-notifyAll" class="headerlink" title="wait() &#x2F; notify() &#x2F; notifyAll()"></a>wait() &#x2F; notify() &#x2F; notifyAll()</h4><p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotifyExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="type">WaitNotifyExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitNotifyExample</span>();</span><br><span class="line">    executorService.execute(() -&gt; example.after());</span><br><span class="line">    executorService.execute(() -&gt; example.before());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">before</span><br><span class="line">after</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li>它们都属于 Object 的一部分，而不属于 Thread。</li><li>只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateExeception。</li><li>使用 wait() 挂起期间，<strong>线程会释放锁</strong>。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁</li></ul><h4 id="await-x2F-signal-x2F-signalAll"><a href="#await-x2F-signal-x2F-signalAll" class="headerlink" title="await() &#x2F; signal() &#x2F; signalAll()"></a>await() &#x2F; signal() &#x2F; signalAll()</h4><p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。相比于 wait() 这种等待方式，await() 可以<strong>指定等待的条件</strong>，因此更加灵活</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AwaitSignalExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">// 使用 Lock 来获取一个 Condition 对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="type">AwaitSignalExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AwaitSignalExample</span>();</span><br><span class="line">    executorService.execute(() -&gt; example.after());</span><br><span class="line">    executorService.execute(() -&gt; example.before());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">before</span><br><span class="line">after</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/posts/11306/"/>
      <url>/posts/11306/</url>
      
        <content type="html"><![CDATA[<h3 id="🍁方案描述"><a href="#🍁方案描述" class="headerlink" title="🍁方案描述"></a>🍁方案描述</h3><blockquote><p>快排的方案之<strong>双边循环快排（hoare 霍尔分区方案改）</strong></p></blockquote><p>使用双指针，每一趟能够确定一个基准点的位置</p><ol><li>选择最左元素作为基准点元素</li><li>j 指针负责从右向左找比基准点小的元素，i 指针负责从左向右找比基准点大的元素，一旦找到二者交换，直至 i，j 相交</li><li>最后基准点与 i（此时 i 与 j 相等）交换，i 即为分区位置</li></ol><h3 id="🍁代码实现"><a href="#🍁代码实现" class="headerlink" title="🍁代码实现"></a>🍁代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 辅助交换函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 确定基准点，返回基准点索引</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> l,<span class="type">int</span> h)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pv</span> <span class="operator">=</span> a[l]; <span class="comment">//基准点元素</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> h;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="comment">// j 从右找小的</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; a[j] &gt; pv)&#123;</span><br><span class="line">            j -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i 从左找大的</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; a[i] &lt;= pv)&#123;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 二者交换</span></span><br><span class="line">    swap(a,i,j);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后基准点与 i（此时 i 与 j 相等）交换，i 即为分区位置</span></span><br><span class="line">    swap(a,l,j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主函数，与partition的参数相同，可快速手撕</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> l,<span class="type">int</span> h)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= h)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(a,l,h);</span><br><span class="line">    quick(a,l,p-<span class="number">1</span>);</span><br><span class="line">    quick(a,p+<span class="number">1</span>,h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🍁注意事项"><a href="#🍁注意事项" class="headerlink" title="🍁注意事项"></a>🍁注意事项</h3><ol><li>基准点在左边，并且要先 j 后 i </li><li>内循环中也要加上”i&lt;j”条件，while( **i** **&lt; j** &amp;&amp; a[j] &gt; pv ) j– </li><li>这里是**&lt;&#x3D;**，因为左边开始位置在基准点上，while ( <strong>i</strong> <strong>&lt; j</strong> &amp;&amp; a[i] <strong>&lt;&#x3D;</strong> pv ) i++</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Synchronized</title>
      <link href="/posts/49469/"/>
      <url>/posts/49469/</url>
      
        <content type="html"><![CDATA[<h3 id="🍁Synchronized简介"><a href="#🍁Synchronized简介" class="headerlink" title="🍁Synchronized简介"></a>🍁Synchronized简介</h3><p>Synchronized关键字是一种线程互斥同步方案，有以下特点：</p><p>一把锁只能同时被一个线程获取，没有获得锁的线程只能等待（<strong>悲观锁</strong>）</p><p>每个实例都对应有自己的一把锁(<strong>this</strong>),不同实例之间互不影响（例外：锁对象是*.class以及synchronized修饰的是static方法的时候，所有对象公用同一把锁）</p><p>synchronized修饰的方法，<strong>无论方法正常执行完毕还是抛出异常</strong>，都会释放锁</p><h3 id="🍁Synchronized使用"><a href="#🍁Synchronized使用" class="headerlink" title="🍁Synchronized使用"></a>🍁Synchronized使用</h3><h4 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h4><p>包括同步代码块锁(自己指定锁对象)和方法锁(默认锁对象为this,当前实例对象)</p><h5 id="代码块形式"><a href="#代码块形式" class="headerlink" title="代码块形式"></a>代码块形式</h5><blockquote><p>手动指定锁定对象，也可是是this,也可以是自定义的锁</p></blockquote><p>锁为this示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedObjectLock</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">SynchronizedObjectLock</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedObjectLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 同步代码块形式——锁为this,两个线程使用的锁是一样的,线程1必须要等到线程0释放了该锁后，才能执行</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instance);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">我是线程Thread-<span class="number">0</span></span><br><span class="line">Thread-<span class="number">0</span>结束</span><br><span class="line">我是线程Thread-<span class="number">1</span></span><br><span class="line">Thread-<span class="number">1</span>结束</span><br></pre></td></tr></table></figure><p>锁为自定义示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedObjectLock</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">SynchronizedObjectLock</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedObjectLock</span>();</span><br><span class="line">    <span class="comment">// 创建2把锁</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">block1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">block2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这个代码块使用的是第一把锁，当他释放后，后面的代码块由于使用的是第二把锁，因此可以马上执行</span></span><br><span class="line">        <span class="keyword">synchronized</span> (block1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;block1锁,我是线程&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;block1锁,&quot;</span>+Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (block2) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;block2锁,我是线程&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;block2锁,&quot;</span>+Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instance);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// 可以看到当第一个线程在执行完第一段同步代码块之后，第二个同步代码块可以马上得到执行，因为他们使用的锁不是同一把</span></span><br><span class="line">block1锁,我是线程Thread-<span class="number">0</span></span><br><span class="line">block1锁,Thread-<span class="number">0</span>结束</span><br><span class="line">block2锁,我是线程Thread-<span class="number">0</span>　　</span><br><span class="line">block1锁,我是线程Thread-<span class="number">1</span></span><br><span class="line">block2锁,Thread-<span class="number">0</span>结束</span><br><span class="line">block1锁,Thread-<span class="number">1</span>结束</span><br><span class="line">block2锁,我是线程Thread-<span class="number">1</span></span><br><span class="line">block2锁,Thread-<span class="number">1</span>结束</span><br></pre></td></tr></table></figure><h5 id="方法锁"><a href="#方法锁" class="headerlink" title="方法锁"></a>方法锁</h5><blockquote><p>synchronized修饰普通方法，锁对象默认为this</p></blockquote><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedObjectLock</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">SynchronizedObjectLock</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedObjectLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 方法上加关键字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instance);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">我是线程Thread-<span class="number">0</span></span><br><span class="line">Thread-<span class="number">0</span>结束</span><br><span class="line">我是线程Thread-<span class="number">1</span></span><br><span class="line">Thread-<span class="number">1</span>结束</span><br></pre></td></tr></table></figure><h4 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h4><p>synchronize修饰静态的方法或指定锁对象为Class对象</p><h5 id="修饰静态方法"><a href="#修饰静态方法" class="headerlink" title="修饰静态方法"></a>修饰静态方法</h5><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedObjectLock</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">SynchronizedObjectLock</span> <span class="variable">instance1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedObjectLock</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">SynchronizedObjectLock</span> <span class="variable">instance2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedObjectLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// synchronized用在静态方法上，默认的锁就是当前所在的Class类，所以无论是哪个线程访问它，需要的锁都只有一把</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instance1);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instance2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">我是线程Thread-<span class="number">0</span></span><br><span class="line">Thread-<span class="number">0</span>结束</span><br><span class="line">我是线程Thread-<span class="number">1</span></span><br><span class="line">Thread-<span class="number">1</span>结束</span><br></pre></td></tr></table></figure><p>🚩注意：和修饰普通方法的区别：对于普通方法而言是每个实例有一把锁，对于静态方法而言是类上的锁，实例的线程共用</p><h5 id="指定锁对象为Class对象"><a href="#指定锁对象为Class对象" class="headerlink" title="指定锁对象为Class对象"></a>指定锁对象为Class对象</h5><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedObjectLock</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">SynchronizedObjectLock</span> <span class="variable">instance1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedObjectLock</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">SynchronizedObjectLock</span> <span class="variable">instance2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedObjectLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 所有线程需要的锁都是同一把</span></span><br><span class="line">        <span class="keyword">synchronized</span>(SynchronizedObjectLock.class)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instance1);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instance2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">我是线程Thread-<span class="number">0</span></span><br><span class="line">Thread-<span class="number">0</span>结束</span><br><span class="line">我是线程Thread-<span class="number">1</span></span><br><span class="line">Thread-<span class="number">1</span>结束</span><br></pre></td></tr></table></figure><h3 id="🍁Synchronized与Lock的区别"><a href="#🍁Synchronized与Lock的区别" class="headerlink" title="🍁Synchronized与Lock的区别"></a>🍁Synchronized与Lock的区别</h3><p>● 语法层面<br>  ○ synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现<br>  ○ Lock 是<strong>接口</strong>，源码由 jdk 提供，用 java 语言实现<br>  ○ 使用 synchronized 时，退出同步代码块锁会自动释放，而使用 Lock 时，需要手动调用 unlock()释放锁<br>● 功能层面<br>  ○ 二者均属于悲观锁，都具备基本的互斥、同步、锁重入功能<br>  ○ Lock 提供了许多 synchronized 不具备的功能，例如获取等待状态、公平锁、<strong>可打断、可超时</strong>、多条件变量<br>  ○ Lock 有适合不同场景的实现，如 <strong>ReentrantLock</strong>， ReentrantReadWriteLock<br>● 性能层面<br>  ○ 在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖<br>  ○ 在竞争激烈时，Lock 的实现通常会提供更好的性能</p><h3 id="🍁Synchronized注意事项"><a href="#🍁Synchronized注意事项" class="headerlink" title="🍁Synchronized注意事项"></a>🍁Synchronized注意事项</h3><ul><li>锁对象<strong>不能为空</strong>，因为锁的信息都保存在对象头里</li><li>作用域不宜过大，影响程序执行的速度，控制范围过大，编写代码也容易出错</li><li>避免死锁</li><li>在能选择的情况下，既不要用Lock也不要用synchronized关键字，用java.util.concurrent包（JUC）中的各种各样的类，如果不用该包下的类，在满足业务的情况下，尽量使用synchronized关键字</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal</title>
      <link href="/posts/19329/"/>
      <url>/posts/19329/</url>
      
        <content type="html"><![CDATA[<h4 id="🍁ThreadLocal简介"><a href="#🍁ThreadLocal简介" class="headerlink" title="🍁ThreadLocal简介"></a>🍁ThreadLocal简介</h4><p>ThreadLocal是一个将在多线程中为每一个线程创建单独的变量副本的类; 当使用ThreadLocal来维护变量时, ThreadLocal会为每个线程创建<strong>单独的变量副本</strong>, 避免因多线程操作共享变量而导致的数据不一致的情况</p><blockquote><p>关键词：<strong>线程间隔离，线程内共享</strong></p></blockquote><h4 id="🍁ThreadLocal简单示例"><a href="#🍁ThreadLocal简单示例" class="headerlink" title="🍁ThreadLocal简单示例"></a>🍁ThreadLocal简单示例</h4><p>以网上示例最多的数据库链接管理为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThreadLocal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个线程内调用, 得到的是同一个 Connection 对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                LoggerUtils.get(<span class="string">&quot;t&quot;</span>).debug(<span class="string">&quot;&#123;&#125;&quot;</span>, Utils.getConnection());</span><br><span class="line">                LoggerUtils.get(<span class="string">&quot;t&quot;</span>).debug(<span class="string">&quot;&#123;&#125;&quot;</span>, Utils.getConnection());</span><br><span class="line">                LoggerUtils.get(<span class="string">&quot;t&quot;</span>).debug(<span class="string">&quot;&#123;&#125;&quot;</span>, Utils.getConnection());</span><br><span class="line">            &#125;, <span class="string">&quot;t&quot;</span> + (i + <span class="number">1</span>)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多个线程调用, 得到的是自己的 Connection 对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                LoggerUtils.get(<span class="string">&quot;t&quot;</span>).debug(<span class="string">&quot;&#123;&#125;&quot;</span>, Utils.getConnection());</span><br><span class="line">            &#125;, <span class="string">&quot;t&quot;</span> + (i + <span class="number">1</span>)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Utils</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Connection&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> tl.get(); <span class="comment">// 到当前线程获取资源</span></span><br><span class="line">            <span class="keyword">if</span> (conn == <span class="literal">null</span>) &#123;</span><br><span class="line">                conn = innerGetConnection(); <span class="comment">// 创建新的连接对象</span></span><br><span class="line">                tl.set(conn); <span class="comment">// 将资源存入当前线程</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> conn;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Connection <span class="title function_">innerGetConnection</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/test?useSSL=false&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="🍁ThreadLocal原理"><a href="#🍁ThreadLocal原理" class="headerlink" title="🍁ThreadLocal原理"></a>🍁ThreadLocal原理</h4><p>每个线程内有一个 ThreadLocalMap 类型的成员变量，用来存储资源对象</p><blockquote><p>初始化代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先调用我们上面写的重载过后的initialValue方法, 产生一个Connection对象;</li><li>继续查看当前线程的threadLocals是不是空的, 如果ThreadLocalMap已被初始化, 那么直接将产生的对象添加到ThreadLocalMap中, 如果没有初始化, 则创建并添加对象到其中;</li></ul><blockquote><p>调用 <strong>set</strong> 方法，就是以 <strong>ThreadLocal 自己作为 key</strong>，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>调用 <strong>get</strong> 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (threadLocals != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> threadLocals.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先获取当前线程对象t, 然后从线程t中获取到ThreadLocalMap的成员属性threadLocals</li><li>如果当前线程的threadLocals已经初始化(即不为null) 并且存在以当前ThreadLocal对象为Key的值, 则直接返回当前线程要获取的对象(例中为Connection);</li><li>如果当前线程的threadLocals已经初始化(即不为null)但是不存在以当前ThreadLocal对象为Key的的对象, 那么重新创建一个Connection对象, 并且添加到当前线程的threadLocals Map中,并返回</li><li>如果当前线程的threadLocals属性还没有被初始化, 则重新创建一个ThreadLocalMap对象, 并且创建一个Connection对象并添加到ThreadLocalMap对象中并返回</li></ul><blockquote><p>调用 <strong>remove</strong> 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</p></blockquote><h4 id="🍁ThreadLocalMap对象"><a href="#🍁ThreadLocalMap对象" class="headerlink" title="🍁ThreadLocalMap对象"></a>🍁ThreadLocalMap对象</h4><h5 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h5><blockquote><ul><li>没有实现Map接口;</li><li>没有public的方法, 最多有一个default的构造方法, 因为这个ThreadLocalMap的方法仅仅在ThreadLocal类中调用, 属于静态内部类</li><li>ThreadLocalMap的Entry实现继承了WeakReference&lt;ThreadLocal&lt;?&gt;&gt;，即弱引用</li><li>该方法仅仅用了一个Entry数组来存储Key, Value; Entry并不是链表形式, 而是每个bucket里面仅仅放一个Entry</li></ul></blockquote><p>以一个示例解释：</p><p><img src="/img/19329/ThreadLocalMap1.png" alt="image.png"></p><ul><li>key 的 hash 值统一分配</li><li>初始容量 <strong>16</strong>，扩容因子 <strong>2&#x2F;3</strong>，扩容<strong>容量翻倍</strong></li><li>key 索引冲突后用<strong>开放寻址法</strong>解决冲突</li></ul><h5 id="key-被设计为弱引用"><a href="#key-被设计为弱引用" class="headerlink" title="key 被设计为弱引用"></a><strong>key 被设计为弱引用</strong></h5><blockquote><p>弱引用：key被释放内存，value还在</p></blockquote><p>Thread 可能需要长时间运行（如线程池中的线程），如果 key 不再使用，需要在内存不足（GC，<strong>垃圾回收</strong>）时释放其占用的内存</p><h5 id="ThreadLocalMap内存释放时机"><a href="#ThreadLocalMap内存释放时机" class="headerlink" title="ThreadLocalMap内存释放时机"></a><strong>ThreadLocalMap内存释放时机</strong></h5><ul><li>被动 GC 释放 key</li></ul><p>​仅是让 key 的内存释放，关联 value 的内存并不会释放</p><ul><li>懒惰被动释放 value</li></ul><p>​get key 时，发现是 null key，则释放其 value 内存</p><p>​get原本不存在的key，会创建一个key，而value为null</p><p><img src="/img/19329/ThreadLocalMap2.png" alt="image.png"></p><p>​set key 时，会使用启发式扫描，清除临近的 null key 的 value 内存，启发次数与元素个数，是否发现 null key 有关</p><p><img src="/img/19329/ThreadLocalMap3.png" alt="image.png"></p><p><img src="/img/19329/ThreadLocalMap4.png" alt="image.png"></p><p>​set 8 时会将临近的9、10全部释放，而14由于距离远不会</p><ul><li>主动 remove 释放 key，value</li></ul><p>​会同时释放 key，value 的内存，也会清除临近的 null key 的 value 内存</p><p>​推荐使用它，因为一般使用 ThreadLocal 时都把它作为静态变量（即强引用），因此无法被动依靠 GC 回收</p><h4 id="🍁ThreadLocal应用场景"><a href="#🍁ThreadLocal应用场景" class="headerlink" title="🍁ThreadLocal应用场景"></a>🍁ThreadLocal应用场景</h4><ul><li>每个线程维护了一个“序列号”</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerialNum</span> &#123;</span><br><span class="line">    <span class="comment">// The next serial number to be assigned</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">nextSerialNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ThreadLocal</span> <span class="variable">serialNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>() &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">synchronized</span> Object <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(nextSerialNum++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((Integer) (serialNum.get())).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Session的管理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadLocal</span> <span class="variable">threadSession</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title function_">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException &#123;  </span><br><span class="line">    <span class="type">Session</span> <span class="variable">s</span> <span class="operator">=</span> (Session) threadSession.get();  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;  </span><br><span class="line">            s = getSessionFactory().openSession();  </span><br><span class="line">            threadSession.set(s);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (HibernateException ex) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InfrastructureException</span>(ex);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> s;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li>在线程内部创建ThreadLocal</li></ul><p>​在多线程的类(如ThreadDemo类)中，创建一个ThreadLocal对象threadXxx，用来保存线程间需要隔离处理的对象xxx。</p><p>​在ThreadDemo类中，创建一个获取要隔离访问的数据的方法getXxx()，在方法中判断，若ThreadLocal对象为null时候，应该new()一个隔离访问类型的对象，并强制转换为要应用的类型。</p><p>​在ThreadDemo类的run()方法中，通过调用getXxx()方法获取要操作的数据，这样可以保证每个线程对应一个数据对象，在任何时刻都操作的是这个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    </span><br><span class="line">    ThreadLocal&lt;Student&gt; StudentThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Student&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">currentThreadName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        System.out.println(currentThreadName + <span class="string">&quot; is running...&quot;</span>);</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> random.nextInt(<span class="number">100</span>);</span><br><span class="line">        System.out.println(currentThreadName + <span class="string">&quot; is set age: &quot;</span>  + age);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">Student</span> <span class="operator">=</span> getStudent(); <span class="comment">//通过这个方法，为每个线程都独立的new一个Student对象，每个线程的的Student对象都可以设置不同的值</span></span><br><span class="line">        Student.setAge(age);</span><br><span class="line">        System.out.println(currentThreadName + <span class="string">&quot; is first get age: &quot;</span> + Student.getAge());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println( currentThreadName + <span class="string">&quot; is second get age: &quot;</span> + Student.getAge());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Student <span class="title function_">getStudent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">Student</span> <span class="operator">=</span> StudentThreadLocal.get();</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == Student) &#123;</span><br><span class="line">            Student = <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">            StudentThreadLocal.set(Student);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Student;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadLocalTest</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalTest</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t,<span class="string">&quot;Thread A&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t,<span class="string">&quot;Thread B&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发基础</title>
      <link href="/posts/1954/"/>
      <url>/posts/1954/</url>
      
        <content type="html"><![CDATA[<h3 id="🍁线程并发不安全原因："><a href="#🍁线程并发不安全原因：" class="headerlink" title="🍁线程并发不安全原因："></a>🍁线程并发不安全原因：</h3><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><blockquote><p>可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1执行的代码</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2执行的代码</span></span><br><span class="line">j = i;</span><br></pre></td></tr></table></figure><p>如上线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><blockquote><p>原子性：一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程1执行</span></span><br><span class="line">i += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程2执行</span></span><br><span class="line">i += <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><code>i += 1</code>需要三条 CPU 指令:</p><ol><li>将变量 i 从内存读取到 CPU寄存器；</li><li>在CPU寄存器中执行 i + 1 操作；</li><li>将最后的结果i写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）</li></ol><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><blockquote><p>有序性：即程序执行的顺序按照代码的先后顺序执行</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;              </span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">i = <span class="number">1</span>;                <span class="comment">//语句1  </span></span><br><span class="line">flag = <span class="literal">true</span>;          <span class="comment">//语句2</span></span><br></pre></td></tr></table></figure><p>从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗? </p><p>不一定，这里可能会发生指令重排序.</p><h3 id="🍁JMM-Java内存模型-解决方案"><a href="#🍁JMM-Java内存模型-解决方案" class="headerlink" title="🍁JMM(Java内存模型)解决方案"></a>🍁JMM(Java内存模型)解决方案</h3><h4 id="原子性-1"><a href="#原子性-1" class="headerlink" title="原子性"></a><strong>原子性</strong></h4><p>Java内存模型只保证了<strong>基本读取和赋值</strong>是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p><hr><h4 id="可见性-1"><a href="#可见性-1" class="headerlink" title="可见性"></a><strong>可见性</strong></h4><p>当一个共享变量被<strong>volatile</strong>修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值</p><p>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。</p><hr><h4 id="有序性-1"><a href="#有序性-1" class="headerlink" title="有序性"></a><strong>有序性</strong></h4><p>也是使用volatile关键字、synchronized和Lock</p><h3 id="🍁线程安全的实现方法"><a href="#🍁线程安全的实现方法" class="headerlink" title="🍁线程安全的实现方法"></a>🍁线程安全的实现方法</h3><h4 id="1-互斥同步"><a href="#1-互斥同步" class="headerlink" title="(1)互斥同步"></a><strong>(1)互斥同步</strong></h4><p>对共享数据进行加锁：<strong>synchronized 和 ReentrantLock</strong></p><p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p><h4 id="2-非阻塞同步"><a href="#2-非阻塞同步" class="headerlink" title="(2)非阻塞同步"></a><strong>(2)非阻塞同步</strong></h4><h5 id="一-CAS"><a href="#一-CAS" class="headerlink" title="(一)CAS"></a>(一)CAS</h5><p>比较并交换(Compare-and-Swap，CAS)。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。</p><p>当执行操作时，<strong>只有当 V 的值等于 A，才将 V 的值更新为 B</strong>。</p><h5 id="二-AtomicInteger"><a href="#二-AtomicInteger" class="headerlink" title="(二)AtomicInteger"></a><strong>(二)AtomicInteger</strong></h5><p>乐观锁：通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较</p><p><strong>(三)ABA</strong></p><p>如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。</p><p>J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题。</p><h4 id="3-无同步方案"><a href="#3-无同步方案" class="headerlink" title="(3)无同步方案"></a><strong>(3)无同步方案</strong></h4><p>一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。</p><h5 id="一-栈封闭"><a href="#一-栈封闭" class="headerlink" title="(一)栈封闭"></a><strong>(一)栈封闭</strong></h5><p>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有。</p><h5 id="二-线程本地存储（Thread-Local-Storage）"><a href="#二-线程本地存储（Thread-Local-Storage）" class="headerlink" title="(二)线程本地存储（Thread Local Storage）"></a><strong>(二)线程本地存储（Thread Local Storage）</strong></h5><p>关键：<strong>线程间隔离，线程内共享</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadLocal</span> <span class="variable">threadLocal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(threadLocal.get());</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">2</span>);</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码输出结果为：1</p><p>解释：thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。</p><p><strong>原理解析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalExample1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadLocal</span> <span class="variable">threadLocal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line">        <span class="type">ThreadLocal</span> <span class="variable">threadLocal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            threadLocal1.set(<span class="number">1</span>);</span><br><span class="line">            threadLocal2.set(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            threadLocal1.set(<span class="number">2</span>);</span><br><span class="line">            threadLocal2.set(<span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码的结构图如下：</p><p><img src="https://www.pdai.tech/images/pics/3646544a-cb57-451d-9e03-d3c4f5e4434a.png" alt="image"></p><p>每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象</p><p>Thread 类中定义了 ThreadLocal.ThreadLocalMap 成员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal(自己)-&gt;value 键值对插入到该 Map 中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用get()方法时，ThreadLocal 自己作为 key，到当前线程中查找关联的资源值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 remove ()方法，以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</p>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长回文子串</title>
      <link href="/posts/52608/"/>
      <url>/posts/52608/</url>
      
        <content type="html"><![CDATA[<h4 id="🍁题目描述"><a href="#🍁题目描述" class="headerlink" title="🍁题目描述"></a>🍁题目描述</h4><p>​给一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><p>​如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><h4 id="🍁思路"><a href="#🍁思路" class="headerlink" title="🍁思路"></a>🍁思路</h4><p>中心扩散法：</p><blockquote><p>顾名思义，即对字符串s进行遍历，每个或每对字符进行中心扩展，记录过程中的最大值。</p><p>比较困难的地方在于，如何对奇数和偶数字符串进行区分？如abba和aba，一个以中间两个b为中心，一个以中间一个b为中心。</p><p>比较巧妙的方式为双指针方法，也即两个指针分别为相同和相差一位进行扩散，返回奇数子串长度和偶数子串长度，再进行比较。</p><p>另外，题目不仅仅返回子串的长度，还有子串本身，所以需要记录子串的开始索引，即代码中的begin，除2的方式统一了奇数和偶数的情况。</p></blockquote><h4 id="🍁代码"><a href="#🍁代码" class="headerlink" title="🍁代码"></a>🍁代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 扩展的辅助函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">expand</span><span class="params">(String s,<span class="type">int</span> c1,<span class="type">int</span> c2)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">while</span>(c1&gt;=<span class="number">0</span>&amp;&amp;c2&lt;len&amp;&amp;s.charAt(c1)==s.charAt(c2))&#123;</span><br><span class="line">            c1 -= <span class="number">1</span>;</span><br><span class="line">            c2 += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c2-c1-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max_len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 最终返回子串的开始索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">odd_len</span> <span class="operator">=</span> expand(s,i,i); <span class="comment">// 奇数扩散</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">even_len</span> <span class="operator">=</span> expand(s,i,i+<span class="number">1</span>); <span class="comment">// 偶数扩散</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">cur_len</span> <span class="operator">=</span> Math.max(odd_len,even_len);</span><br><span class="line">            <span class="keyword">if</span>(cur_len &gt; max_len)&#123;</span><br><span class="line">                max_len = cur_len;</span><br><span class="line">                begin = i - (max_len - <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin,begin+max_len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
